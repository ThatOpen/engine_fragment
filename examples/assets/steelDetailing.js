import{C as we,W as xe,cu as Pe,cv as Me,cw as Ie,cx as Se,cy as ve,cz as Ce,cA as Te,cB as re,cC as ze,cD as Le,I as ke,cE as Ee,cF as Q,cG as Ge,cH as Re,cI as ie,cJ as ae,V as u,cK as _e,j as ce,cL as Ae,O as De,cM as Fe,n as L}from"./virtual-memory-controller-ZSRKHGNY.js";import{x as Oe,r as Ue}from"./index-BR-jkuKE.js";import{a as Be,R as le,m as de}from"./index-CWj6LyOo.js";import{S as He}from"./stats.min-Cj8wREqt.js";import{R as We}from"./RGBELoader-Dncwvf9Q.js";import{G as je,P as Ne}from"./index-BzdGIFlS.js";const $e=document.getElementById("container"),C=new we,Ve=C.get(xe),n=Ve.create();n.scene=new Pe(C);n.renderer=new Oe(C,$e);n.camera=new Me(C);n.renderer.postproduction.enabled=!0;n.renderer.postproduction.style=Ue.COLOR_PEN;C.init();n.camera.controls.setLookAt(12,6,8,0,0,-10);n.renderer.three.shadowMap.enabled=!0;n.renderer.three.shadowMap.type=Ie;n.scene.setup({shadows:{cascade:1,resolution:1024}});await n.scene.updateShadows();n.camera.controls.addEventListener("rest",async()=>{await n.scene.updateShadows()});const qe=new Se(1);n.scene.three.add(qe);const o={length:30,lengthModules:5,columnWidth:.2,columnLength:.2,columnThickness:.03,columnFlangeThickness:.03,basePlateSize:.5,basePlateCrossHeight:.2,basePlateCornerSize:.1,basePlateThickness:.01,startPoints:[[0,0,0],[0,8,0],[0,8,0],[10,10,0],[10,10,0],[20,8,0],[20,8,0],[20,0,0],[20,4,0],[30,4,0],[30,4,0],[30,0,0]]},Je="../../src/multithreading/fragments-thread.ts",r=C.get(ve);r.init(Je);const Ke=e=>{e.wrapS=ae,e.wrapT=ae,e.repeat.set(.2,.2)},Ze=new Ce,me=Ze.load("https://thatopen.github.io/engine_fragment/resources/textures/concrete/Concrete012_2K-JPG_Roughness.jpg");Ke(me);r.core.models.materials.list.onItemSet.add(({key:e,value:t})=>{if("map"in t){const s=new Te({color:t.color,metalness:.9,roughnessMap:me,side:re});r.core.models.materials.list.set(e,s)}});r.core.models.materials.list.onItemSet.add(({value:e})=>{"isLodMaterial"in e&&e.isLodMaterial&&n.renderer.postproduction.basePass.isolatedMaterials.push(e)});r.core.settings.graphicsQuality=1;n.camera.controls.addEventListener("control",()=>{r.core.update()});r.core.models.list.onItemSet.add(({value:e})=>{e.tiles.onItemSet.add(({value:t})=>{if(!("isLODGeometry"in t.geometry)){const s=t.geometry;t.castShadow=!0,t.receiveShadow=!0;const a=s.index.array,d=s.attributes.position.array,m=s.attributes.normal.array,c=new Float32Array(d.length/3*2);for(let l=0;l<a.length;l++){const i=a[l],M=d[i*3],I=d[i*3+1],p=d[i*3+2],W=m[i*3],w=m[i*3+1],x=m[i*3+2],g=Math.abs(W),f=Math.abs(w),R=Math.abs(x);g>f&&g>R?(c[i*2]=I,c[i*2+1]=p):f>g&&f>R?(c[i*2]=M,c[i*2+1]=p):(c[i*2]=M,c[i*2+1]=I)}const b=new ze(c,2);b.onUpload(function(){delete this.array}),s.setAttribute("uv",b)}})});r.core.models.list.onItemSet.add(({value:e})=>{e.tiles.onItemSet.add(({value:t})=>{"isMesh"in t&&t.material[0].opacity===1&&(t.castShadow=!0,t.receiveShadow=!0)}),e.getClippingPlanesEvent=()=>Array.from(n.renderer.three.clippingPlanes)||[]});const Qe=Le.newModel({raw:!0}),h=await r.load(Qe,{modelId:"example",camera:n.camera.three,raw:!0});n.scene.three.add(h.object);await r.core.update(!0);const X=new ke;X.SetWasmPath("/node_modules/web-ifc/",!1);await X.Init();const E=new je(X),Xe=new We;Xe.load("https://thatopen.github.io/engine_fragment/resources/textures/envmaps/san_giuseppe_bridge_2k.hdr",e=>{e.mapping=Ee,n.scene.three.environment=e});const G=new Q,Ye=new Ge({color:16711680}),et=new Re(G,Ye);n.scene.three.add(et);let K=!1;const ne=new Q,tt=new ie({color:"white",side:2}),ot=e=>{const t=new Ae(e,tt);return t.receiveShadow=!0,t.castShadow=!0,t.frustumCulled=!1,t},pe=(e,t,s)=>{const a=new Q;return E.getExtrusion(a,{profilePoints:e,direction:t,length:s}),ot(a)},st=(e,t)=>{const s=new _e(e,t),a=[],d=s.index.array,m=s.attributes.position.array;for(let l=0;l<d.length;l++){const i=d[l];a.push(m[i*3]),a.push(m[i*3+1]),a.push(m[i*3+2])}const c=new ce().makeRotationX(Math.PI/2);return E.transformPoints(a,c)},Y=(e,t,s)=>pe([-e/2,0,-t/2,-e/2,0,t/2,e/2,0,t/2,e/2,0,-t/2],[0,1,0],s),at=(e,t,s)=>{const a=st(e,s);return pe(a,[0,1,0],t)},U=Y(o.basePlateSize,o.basePlateSize,o.basePlateThickness),B=Y(o.basePlateThickness*2,o.basePlateSize/2,o.basePlateCrossHeight),k=Y(o.basePlateCornerSize,o.basePlateCornerSize,o.basePlateThickness),v=at(o.basePlateSize/15,o.basePlateSize/15,6),nt=async()=>{if(!G.attributes.position){console.log("No wire geometry");return}const e=new De,t=[];await r.core.editor.reset(h.modelId);const s=r.core.editor.createMaterial(h.modelId,new ie({color:new Fe(1,1,1),side:re})),a=r.core.editor.createLocalTransform(h.modelId,new ce().identity()),d=U.geometry,m=r.core.editor.createShell(h.modelId,d),c=B.geometry,b=r.core.editor.createShell(h.modelId,c),l=k.geometry,i=r.core.editor.createShell(h.modelId,l),M=v.geometry,I=r.core.editor.createShell(h.modelId,M),p=o.basePlateSize/10,W=o.basePlateThickness,w=new u(1,0,0),x=new u(0,1,0),g=new u(1,0,0),f=new u(0,1,0);e.position.set(0,0,0),e.rotation.set(0,0,0),e.rotation.y=-Math.PI/2,e.updateMatrix(),w.applyMatrix4(e.matrix),x.applyMatrix4(e.matrix),e.rotation.set(0,0,0),e.rotation.z=Math.PI/2,e.updateMatrix(),w.applyMatrix4(e.matrix),x.applyMatrix4(e.matrix),e.rotation.set(0,0,0),e.rotation.y=Math.PI/2,e.updateMatrix(),g.applyMatrix4(e.matrix),f.applyMatrix4(e.matrix),e.rotation.set(0,0,0),e.rotation.z=-Math.PI/2,e.updateMatrix(),g.applyMatrix4(e.matrix),f.applyMatrix4(e.matrix);const R=r.core.editor.createCircleExtrusion(h.modelId,{radius:[W],axes:[{wires:[[0,.06,0,0,-.6+p,0],[p,-.6,0,.15-p,-.6,0],[.15,-.6+p,0,.15,-.5,0]],wireSets:[],circleCurves:[{aperture:Math.PI/2,position:[p,-.6+p,0],radius:p,xDirection:[w.x,w.y,w.z],yDirection:[x.x,x.y,x.z]},{aperture:Math.PI/2,position:[.15-p,-.6+p,0],radius:p,xDirection:[g.x,g.y,g.z],yDirection:[f.x,f.y,f.z]}],order:[0,1,2,0,1],parts:[L.WIRE,L.WIRE,L.WIRE,L.CIRCLE_CURVE,L.CIRCLE_CURVE]}]}),ue=E.getProfilePoints({type:Ne.H,width:o.columnWidth,depth:o.columnLength,thickness:o.columnThickness,flangeThickness:o.columnFlangeThickness}),z=new u,_=new u,P=G.attributes.position.array;for(let y=0;y<P.length;y+=6){const ee=P[y],A=P[y+1],te=P[y+2],oe=P[y+3],j=P[y+4],se=P[y+5];if(z.set(ee,A,te),_.set(oe,j,se),A===0||j===0){const $=A===0,D=$?ee:oe,V=$?A:j,F=$?te:se;U.position.set(D,V,F),U.updateMatrix(),t.push({attributes:{_category:{value:"test"}},globalTransform:U.matrix.clone(),samples:[{localTransform:a,representation:m,material:s}]});const ge=.1;for(let S=0;S<2;S++){const ye=S===0?-.1:ge;B.position.set(D+ye,-.2,F),B.updateMatrix(),t.push({attributes:{_category:{value:"test"}},globalTransform:B.matrix.clone(),samples:[{localTransform:a,representation:b,material:s}]})}const O=o.basePlateSize/2-o.basePlateCornerSize/2,fe=[new u(O,0,O),new u(-.2,0,O),new u(O,0,-.2),new u(-.2,0,-.2)];let q=0;for(const S of fe)k.position.set(D,V+o.basePlateThickness,F),k.position.add(S),k.updateMatrix(),t.push({attributes:{_category:{value:"test"}},globalTransform:k.matrix.clone(),samples:[{localTransform:a,representation:i,material:s}]}),v.position.set(D,V+o.basePlateThickness,F),v.position.add(S),v.updateMatrix(),t.push({attributes:{_category:{value:"test"}},globalTransform:v.matrix.clone(),samples:[{localTransform:a,representation:I,material:s}]}),e.position.copy(v.position),e.rotation.set(0,0,0),(q===0||q===2)&&(e.rotation.y=Math.PI),e.updateMatrix(),t.push({attributes:{_category:{value:"test"}},globalTransform:e.matrix.clone(),samples:[{localTransform:a,representation:R,material:s}]}),q++}const N=_.clone().sub(z).normalize();e.position.copy(z),e.lookAt(_),e.position.set(0,0,0),e.updateMatrix();const he=E.transformPoints([...ue],e.matrix.clone());E.getExtrusion(ne,{profilePoints:he,direction:[N.x,N.y,N.z],length:z.distanceTo(_)});const be=r.core.editor.createShell(h.modelId,ne);e.position.copy(z),e.rotation.set(0,0,0),e.updateMatrix(),t.push({attributes:{_category:{value:"test"}},globalTransform:e.matrix.clone(),samples:[{localTransform:a,representation:be,material:s}]})}await r.core.editor.createElements(h.modelId,t),await r.core.update(!0),K=!1};let J=null;const rt=1e3,it=()=>{K||(K=!0,J&&clearTimeout(J),J=setTimeout(()=>{nt()},rt))},Z=()=>{const e=[],t=o.length/o.lengthModules;for(let s=0;s<o.lengthModules;s++)for(let a=0;a<o.startPoints.length;a++){const d=o.startPoints[a],[m,c,b]=d,l=b+t*s;e.push(new u(m,c,l))}for(let s=0;s<o.lengthModules-1;s++)for(let a=0;a<o.startPoints.length;a++){const d=o.startPoints[a],[m,c,b]=d;if(c===0)continue;const l=b+t*s,i=m,M=c,I=l+t;e.push(new u(m,c,l)),e.push(new u(i,M,I))}G.deleteAttribute("position"),G.setFromPoints(e),it()};Z();Be.init();const[H]=le.create(e=>de`
    <bim-panel style="min-width: 25rem;" id="controls-panel" active label="Element Editor" class="options-menu">

      <bim-panel-section label="Controls">

      <bim-number-input label="Length Modules" slider min=2 max=10 step=1 value=${o.lengthModules} @change=${t=>{o.lengthModules=t.target.value,Z()}}></bim-number-input>

      <bim-number-input label="Length" slider min=10 max=100 step=1 value=${o.length} @change=${t=>{o.length=t.target.value,Z()}}></bim-number-input>
      

      </bim-panel-section>

    </bim-panel>
  `,{});document.body.append(H);const ct=le.create(()=>de`
    <bim-button class="phone-menu-toggler" icon="solar:settings-bold"
      @click=${()=>{H.classList.contains("options-menu-visible")?H.classList.remove("options-menu-visible"):H.classList.add("options-menu-visible")}}>
    </bim-button>
  `);document.body.append(ct);const T=new He;T.showPanel(2);document.body.append(T.dom);T.dom.style.left="0px";T.dom.style.zIndex="unset";n.renderer.onBeforeUpdate.add(()=>T.begin());n.renderer.onAfterUpdate.add(()=>T.end());
