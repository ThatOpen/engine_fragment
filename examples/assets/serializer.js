var Ge=Object.defineProperty;var ke=(a,t,s)=>t in a?Ge(a,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):a[t]=s;var T=(a,t,s)=>(ke(a,typeof t!="symbol"?t+"":t,s),s);import{I as Ne,C as rt,B as wt,V as S,P as we,L as ut,a as $t,T as ts,S as Ke,M as G,b as nt,c as qe,D as $e,F as se,R as je,d as Ae,e as Is,f as Ie,g as ve,E as Ve,G as He,h as Xe}from"./encoding-OofKfb5O.js";import{S as ft,B as Ce,a as Fe}from"./builder-7dwzoAYi.js";class ee extends Ne{constructor(s,e,n,o){super(s,e,n);T(this,"fragment");T(this,"material");T(this,"geometry");if(Array.isArray(e)||(e=[e]),this.material=e,!s.index)throw new Error("The geometry for fragments must be indexed!");this.geometry=s,this.fragment=o;const i=s.index.count;s.groups.length||s.groups.push({start:0,count:i,materialIndex:0})}exportData(){const s=this.geometry.attributes.position.array,e=this.geometry.attributes.normal.array,n=Array.from(this.geometry.index.array),o=[];for(const f of this.geometry.groups){const l=f.materialIndex||0,{start:b,count:h}=f;o.push(b,h,l)}const i=[];if(Array.isArray(this.material))for(const f of this.material){const l=f.opacity,b=f.transparent?1:0,h=new rt(f.color).toArray();i.push(l,b,...h)}const r=Array.from(this.instanceMatrix.array);let c;return this.instanceColor!==null?c=Array.from(this.instanceColor.array):c=[],{position:s,normal:e,index:n,groups:o,materials:i,matrices:r,colors:c}}clone(s){throw new Error("Fragment meshes can't be cloned directly. Use mesh.fragment.clone instead!")}}const Me=0,Ze=1,Ye=2,ne=2,Ps=1.25,ie=1,xs=6*4+4+4,Cs=65535,Je=Math.pow(2,-24),Ts=Symbol("SKIP_GENERATION");function We(a){return a.index?a.index.count:a.attributes.position.count}function jt(a){return We(a)/3}function Qe(a,t=ArrayBuffer){return a>65535?new Uint32Array(new t(4*a)):new Uint16Array(new t(2*a))}function tn(a,t){if(!a.index){const s=a.attributes.position.count,e=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,n=Qe(s,e);a.setIndex(new wt(n,1));for(let o=0;o<s;o++)n[o]=o}}function Pe(a){const t=jt(a),s=a.drawRange,e=s.start/3,n=(s.start+s.count)/3,o=Math.max(0,e),i=Math.min(t,n)-o;return[{offset:Math.floor(o),count:Math.floor(i)}]}function Te(a){if(!a.groups||!a.groups.length)return Pe(a);const t=[],s=new Set,e=a.drawRange,n=e.start/3,o=(e.start+e.count)/3;for(const r of a.groups){const c=r.start/3,f=(r.start+r.count)/3;s.add(Math.max(n,c)),s.add(Math.min(o,f))}const i=Array.from(s.values()).sort((r,c)=>r-c);for(let r=0;r<i.length-1;r++){const c=i[r],f=i[r+1];t.push({offset:Math.floor(c),count:Math.floor(f-c)})}return t}function sn(a){if(a.groups.length===0)return!1;const t=jt(a),s=Te(a).sort((o,i)=>o.offset-i.offset),e=s[s.length-1];e.count=Math.min(t-e.offset,e.count);let n=0;return s.forEach(({count:o})=>n+=o),t!==n}function R(a,t,s){return s.min.x=t[a],s.min.y=t[a+1],s.min.z=t[a+2],s.max.x=t[a+3],s.max.y=t[a+4],s.max.z=t[a+5],s}function en(a){a[0]=a[1]=a[2]=1/0,a[3]=a[4]=a[5]=-1/0}function oe(a){let t=-1,s=-1/0;for(let e=0;e<3;e++){const n=a[e+3]-a[e];n>s&&(s=n,t=e)}return t}function re(a,t){t.set(a)}function ce(a,t,s){let e,n;for(let o=0;o<3;o++){const i=o+3;e=a[o],n=t[o],s[o]=e<n?e:n,e=a[i],n=t[i],s[i]=e>n?e:n}}function os(a,t,s){for(let e=0;e<3;e++){const n=t[a+2*e],o=t[a+2*e+1],i=n-o,r=n+o;i<s[e]&&(s[e]=i),r>s[e+3]&&(s[e+3]=r)}}function Xt(a){const t=a[3]-a[0],s=a[4]-a[1],e=a[5]-a[2];return 2*(t*s+s*e+e*t)}function Ds(a,t,s,e,n=null){let o=1/0,i=1/0,r=1/0,c=-1/0,f=-1/0,l=-1/0,b=1/0,h=1/0,u=1/0,p=-1/0,w=-1/0,y=-1/0;const d=n!==null;for(let _=t*6,x=(t+s)*6;_<x;_+=6){const m=a[_+0],g=a[_+1],I=m-g,C=m+g;I<o&&(o=I),C>c&&(c=C),d&&m<b&&(b=m),d&&m>p&&(p=m);const A=a[_+2],F=a[_+3],v=A-F,P=A+F;v<i&&(i=v),P>f&&(f=P),d&&A<h&&(h=A),d&&A>w&&(w=A);const V=a[_+4],M=a[_+5],D=V-M,B=V+M;D<r&&(r=D),B>l&&(l=B),d&&V<u&&(u=V),d&&V>y&&(y=V)}e[0]=o,e[1]=i,e[2]=r,e[3]=c,e[4]=f,e[5]=l,d&&(n[0]=b,n[1]=h,n[2]=u,n[3]=p,n[4]=w,n[5]=y)}function nn(a,t,s,e){let n=1/0,o=1/0,i=1/0,r=-1/0,c=-1/0,f=-1/0;for(let l=t*6,b=(t+s)*6;l<b;l+=6){const h=a[l+0];h<n&&(n=h),h>r&&(r=h);const u=a[l+2];u<o&&(o=u),u>c&&(c=u);const p=a[l+4];p<i&&(i=p),p>f&&(f=p)}e[0]=n,e[1]=o,e[2]=i,e[3]=r,e[4]=c,e[5]=f}function on(a,t){en(t);const s=a.attributes.position,e=a.index?a.index.array:null,n=jt(a),o=new Float32Array(n*6),i=s.normalized,r=s.array,c=s.offset||0;let f=3;s.isInterleavedBufferAttribute&&(f=s.data.stride);const l=["getX","getY","getZ"];for(let b=0;b<n;b++){const h=b*3,u=b*6;let p=h+0,w=h+1,y=h+2;e&&(p=e[p],w=e[w],y=e[y]),i||(p=p*f+c,w=w*f+c,y=y*f+c);for(let d=0;d<3;d++){let _,x,m;i?(_=s[l[d]](p),x=s[l[d]](w),m=s[l[d]](y)):(_=r[p+d],x=r[w+d],m=r[y+d]);let g=_;x<g&&(g=x),m<g&&(g=m);let I=_;x>I&&(I=x),m>I&&(I=m);const C=(I-g)/2,A=d*2;o[u+A+0]=g+C,o[u+A+1]=C+(Math.abs(g)+C)*Je,g<t[d]&&(t[d]=g),I>t[d+3]&&(t[d+3]=I)}}return o}const lt=32,rn=(a,t)=>a.candidate-t.candidate,yt=new Array(lt).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),rs=new Float32Array(6);function cn(a,t,s,e,n,o){let i=-1,r=0;if(o===Me)i=oe(t),i!==-1&&(r=(t[i]+t[i+3])/2);else if(o===Ze)i=oe(a),i!==-1&&(r=an(s,e,n,i));else if(o===Ye){const c=Xt(a);let f=Ps*n;const l=e*6,b=(e+n)*6;for(let h=0;h<3;h++){const u=t[h],y=(t[h+3]-u)/lt;if(n<lt/4){const d=[...yt];d.length=n;let _=0;for(let m=l;m<b;m+=6,_++){const g=d[_];g.candidate=s[m+2*h],g.count=0;const{bounds:I,leftCacheBounds:C,rightCacheBounds:A}=g;for(let F=0;F<3;F++)A[F]=1/0,A[F+3]=-1/0,C[F]=1/0,C[F+3]=-1/0,I[F]=1/0,I[F+3]=-1/0;os(m,s,I)}d.sort(rn);let x=n;for(let m=0;m<x;m++){const g=d[m];for(;m+1<x&&d[m+1].candidate===g.candidate;)d.splice(m+1,1),x--}for(let m=l;m<b;m+=6){const g=s[m+2*h];for(let I=0;I<x;I++){const C=d[I];g>=C.candidate?os(m,s,C.rightCacheBounds):(os(m,s,C.leftCacheBounds),C.count++)}}for(let m=0;m<x;m++){const g=d[m],I=g.count,C=n-g.count,A=g.leftCacheBounds,F=g.rightCacheBounds;let v=0;I!==0&&(v=Xt(A)/c);let P=0;C!==0&&(P=Xt(F)/c);const V=ie+Ps*(v*I+P*C);V<f&&(i=h,f=V,r=g.candidate)}}else{for(let x=0;x<lt;x++){const m=yt[x];m.count=0,m.candidate=u+y+x*y;const g=m.bounds;for(let I=0;I<3;I++)g[I]=1/0,g[I+3]=-1/0}for(let x=l;x<b;x+=6){let I=~~((s[x+2*h]-u)/y);I>=lt&&(I=lt-1);const C=yt[I];C.count++,os(x,s,C.bounds)}const d=yt[lt-1];re(d.bounds,d.rightCacheBounds);for(let x=lt-2;x>=0;x--){const m=yt[x],g=yt[x+1];ce(m.bounds,g.rightCacheBounds,m.rightCacheBounds)}let _=0;for(let x=0;x<lt-1;x++){const m=yt[x],g=m.count,I=m.bounds,A=yt[x+1].rightCacheBounds;g!==0&&(_===0?re(I,rs):ce(I,rs,rs)),_+=g;let F=0,v=0;_!==0&&(F=Xt(rs)/c);const P=n-_;P!==0&&(v=Xt(A)/c);const V=ie+Ps*(F*_+v*P);V<f&&(i=h,f=V,r=m.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:i,pos:r}}function an(a,t,s,e){let n=0;for(let o=t,i=t+s;o<i;o++)n+=a[o*6+e*2];return n/s}class cs{constructor(){}}function fn(a,t,s,e,n,o){let i=e,r=e+n-1;const c=o.pos,f=o.axis*2;for(;;){for(;i<=r&&s[i*6+f]<c;)i++;for(;i<=r&&s[r*6+f]>=c;)r--;if(i<r){for(let l=0;l<3;l++){let b=t[i*3+l];t[i*3+l]=t[r*3+l],t[r*3+l]=b}for(let l=0;l<6;l++){let b=s[i*6+l];s[i*6+l]=s[r*6+l],s[r*6+l]=b}i++,r--}else return i}}function ln(a,t,s,e,n,o){let i=e,r=e+n-1;const c=o.pos,f=o.axis*2;for(;;){for(;i<=r&&s[i*6+f]<c;)i++;for(;i<=r&&s[r*6+f]>=c;)r--;if(i<r){let l=a[i];a[i]=a[r],a[r]=l;for(let b=0;b<6;b++){let h=s[i*6+b];s[i*6+b]=s[r*6+b],s[r*6+b]=h}i++,r--}else return i}}function hn(a,t){const s=(a.index?a.index.count:a.attributes.position.count)/3,e=s>2**16,n=e?4:2,o=t?new SharedArrayBuffer(s*n):new ArrayBuffer(s*n),i=e?new Uint32Array(o):new Uint16Array(o);for(let r=0,c=i.length;r<c;r++)i[r]=r;return i}function bn(a,t){const s=a.geometry,e=s.index?s.index.array:null,n=t.maxDepth,o=t.verbose,i=t.maxLeafTris,r=t.strategy,c=t.onProgress,f=jt(s),l=a._indirectBuffer;let b=!1;const h=new Float32Array(6),u=new Float32Array(6),p=on(s,h),w=t.indirect?ln:fn,y=[],d=t.indirect?Pe(s):Te(s);if(d.length===1){const m=d[0],g=new cs;g.boundingData=h,nn(p,m.offset,m.count,u),x(g,m.offset,m.count,u),y.push(g)}else for(let m of d){const g=new cs;g.boundingData=new Float32Array(6),Ds(p,m.offset,m.count,g.boundingData,u),x(g,m.offset,m.count,u),y.push(g)}return y;function _(m){c&&c(m/f)}function x(m,g,I,C=null,A=0){if(!b&&A>=n&&(b=!0,o&&(console.warn(`MeshBVH: Max depth of ${n} reached when generating BVH. Consider increasing maxDepth.`),console.warn(s))),I<=i||A>=n)return _(g+I),m.offset=g,m.count=I,m;const F=cn(m.boundingData,C,p,g,I,r);if(F.axis===-1)return _(g+I),m.offset=g,m.count=I,m;const v=w(l,e,p,g,I,F);if(v===g||v===g+I)_(g+I),m.offset=g,m.count=I;else{m.splitAxis=F.axis;const P=new cs,V=g,M=v-g;m.left=P,P.boundingData=new Float32Array(6),Ds(p,V,M,P.boundingData,u),x(P,V,M,u,A+1);const D=new cs,B=v,L=I-M;m.right=D,D.boundingData=new Float32Array(6),Ds(p,B,L,D.boundingData,u),x(D,B,L,u,A+1)}return m}}function un(a,t){const s=a.geometry;t.indirect&&(a._indirectBuffer=hn(s,t.useSharedArrayBuffer),sn(s)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),a._indirectBuffer||tn(s,t);const e=bn(a,t);let n,o,i;const r=[],c=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let b=0;b<e.length;b++){const h=e[b];let u=f(h);const p=new c(xs*u);n=new Float32Array(p),o=new Uint32Array(p),i=new Uint16Array(p),l(0,h),r.push(p)}a._roots=r;return;function f(b){return b.count?1:1+f(b.left)+f(b.right)}function l(b,h){const u=b/4,p=b/2,w=!!h.count,y=h.boundingData;for(let d=0;d<6;d++)n[u+d]=y[d];if(w){const d=h.offset,_=h.count;return o[u+6]=d,i[p+14]=_,i[p+15]=Cs,b+xs}else{const d=h.left,_=h.right,x=h.splitAxis;let m;if(m=l(b+xs,d),m/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return o[u+6]=m/4,m=l(m,_),o[u+7]=x,m}}}class dt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,s){let e=1/0,n=-1/0;for(let o=0,i=t.length;o<i;o++){const c=t[o][s];e=c<e?c:e,n=c>n?c:n}this.min=e,this.max=n}setFromPoints(t,s){let e=1/0,n=-1/0;for(let o=0,i=s.length;o<i;o++){const r=s[o],c=t.dot(r);e=c<e?c:e,n=c>n?c:n}this.min=e,this.max=n}isSeparated(t){return this.min>t.max||t.min>this.max}}dt.prototype.setFromBox=function(){const a=new S;return function(s,e){const n=e.min,o=e.max;let i=1/0,r=-1/0;for(let c=0;c<=1;c++)for(let f=0;f<=1;f++)for(let l=0;l<=1;l++){a.x=n.x*c+o.x*(1-c),a.y=n.y*f+o.y*(1-f),a.z=n.z*l+o.z*(1-l);const b=s.dot(a);i=Math.min(b,i),r=Math.max(b,r)}this.min=i,this.max=r}}();const dn=function(){const a=new S,t=new S,s=new S;return function(n,o,i){const r=n.start,c=a,f=o.start,l=t;s.subVectors(r,f),a.subVectors(n.end,n.start),t.subVectors(o.end,o.start);const b=s.dot(l),h=l.dot(c),u=l.dot(l),p=s.dot(c),y=c.dot(c)*u-h*h;let d,_;y!==0?d=(b*h-p*u)/y:d=0,_=(b+d*h)/u,i.x=d,i.y=_}}(),Ws=function(){const a=new $t,t=new S,s=new S;return function(n,o,i,r){dn(n,o,a);let c=a.x,f=a.y;if(c>=0&&c<=1&&f>=0&&f<=1){n.at(c,i),o.at(f,r);return}else if(c>=0&&c<=1){f<0?o.at(0,r):o.at(1,r),n.closestPointToPoint(r,!0,i);return}else if(f>=0&&f<=1){c<0?n.at(0,i):n.at(1,i),o.closestPointToPoint(i,!0,r);return}else{let l;c<0?l=n.start:l=n.end;let b;f<0?b=o.start:b=o.end;const h=t,u=s;if(n.closestPointToPoint(b,!0,t),o.closestPointToPoint(l,!0,s),h.distanceToSquared(b)<=u.distanceToSquared(l)){i.copy(h),r.copy(b);return}else{i.copy(l),r.copy(u);return}}}}(),pn=function(){const a=new S,t=new S,s=new we,e=new ut;return function(o,i){const{radius:r,center:c}=o,{a:f,b:l,c:b}=i;if(e.start=f,e.end=l,e.closestPointToPoint(c,!0,a).distanceTo(c)<=r||(e.start=f,e.end=b,e.closestPointToPoint(c,!0,a).distanceTo(c)<=r)||(e.start=l,e.end=b,e.closestPointToPoint(c,!0,a).distanceTo(c)<=r))return!0;const w=i.getPlane(s);if(Math.abs(w.distanceToPoint(c))<=r){const d=w.projectPoint(c,t);if(i.containsPoint(d))return!0}return!1}}(),_n=1e-15;function Ss(a){return Math.abs(a)<_n}class ct extends ts{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new S),this.satBounds=new Array(4).fill().map(()=>new dt),this.points=[this.a,this.b,this.c],this.sphere=new Ke,this.plane=new we,this.needsUpdate=!0}intersectsSphere(t){return pn(t,this)}update(){const t=this.a,s=this.b,e=this.c,n=this.points,o=this.satAxes,i=this.satBounds,r=o[0],c=i[0];this.getNormal(r),c.setFromPoints(r,n);const f=o[1],l=i[1];f.subVectors(t,s),l.setFromPoints(f,n);const b=o[2],h=i[2];b.subVectors(s,e),h.setFromPoints(b,n);const u=o[3],p=i[3];u.subVectors(e,t),p.setFromPoints(u,n),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(r,t),this.needsUpdate=!1}}ct.prototype.closestPointToSegment=function(){const a=new S,t=new S,s=new ut;return function(n,o=null,i=null){const{start:r,end:c}=n,f=this.points;let l,b=1/0;for(let h=0;h<3;h++){const u=(h+1)%3;s.start.copy(f[h]),s.end.copy(f[u]),Ws(s,n,a,t),l=a.distanceToSquared(t),l<b&&(b=l,o&&o.copy(a),i&&i.copy(t))}return this.closestPointToPoint(r,a),l=r.distanceToSquared(a),l<b&&(b=l,o&&o.copy(a),i&&i.copy(r)),this.closestPointToPoint(c,a),l=c.distanceToSquared(a),l<b&&(b=l,o&&o.copy(a),i&&i.copy(c)),Math.sqrt(b)}}();ct.prototype.intersectsTriangle=function(){const a=new ct,t=new Array(3),s=new Array(3),e=new dt,n=new dt,o=new S,i=new S,r=new S,c=new S,f=new S,l=new ut,b=new ut,h=new ut,u=new S;function p(w,y,d){const _=w.points;let x=0,m=-1;for(let g=0;g<3;g++){const{start:I,end:C}=l;I.copy(_[g]),C.copy(_[(g+1)%3]),l.delta(i);const A=Ss(y.distanceToPoint(I));if(Ss(y.normal.dot(i))&&A){d.copy(l),x=2;break}const F=y.intersectLine(l,u);if(!F&&A&&u.copy(I),(F||A)&&!Ss(u.distanceTo(C))){if(x<=1)(x===1?d.start:d.end).copy(u),A&&(m=x);else if(x>=2){(m===1?d.start:d.end).copy(u),x=2;break}if(x++,x===2&&m===-1)break}}return x}return function(y,d=null,_=!1){this.needsUpdate&&this.update(),y.isExtendedTriangle?y.needsUpdate&&y.update():(a.copy(y),a.update(),y=a);const x=this.plane,m=y.plane;if(Math.abs(x.normal.dot(m.normal))>1-1e-10){const g=this.satBounds,I=this.satAxes;s[0]=y.a,s[1]=y.b,s[2]=y.c;for(let F=0;F<4;F++){const v=g[F],P=I[F];if(e.setFromPoints(P,s),v.isSeparated(e))return!1}const C=y.satBounds,A=y.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let F=0;F<4;F++){const v=C[F],P=A[F];if(e.setFromPoints(P,t),v.isSeparated(e))return!1}for(let F=0;F<4;F++){const v=I[F];for(let P=0;P<4;P++){const V=A[P];if(o.crossVectors(v,V),e.setFromPoints(o,t),n.setFromPoints(o,s),e.isSeparated(n))return!1}}return d&&(_||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),d.start.set(0,0,0),d.end.set(0,0,0)),!0}else{const g=p(this,m,b);if(g===1&&y.containsPoint(b.end))return d&&(d.start.copy(b.end),d.end.copy(b.end)),!0;if(g!==2)return!1;const I=p(y,x,h);if(I===1&&this.containsPoint(h.end))return d&&(d.start.copy(h.end),d.end.copy(h.end)),!0;if(I!==2)return!1;if(b.delta(r),h.delta(c),r.dot(c)<0){let M=h.start;h.start=h.end,h.end=M}const C=b.start.dot(r),A=b.end.dot(r),F=h.start.dot(r),v=h.end.dot(r),P=A<F,V=C<v;return C!==v&&F!==A&&P===V?!1:(d&&(f.subVectors(b.start,h.start),f.dot(r)>0?d.start.copy(b.start):d.start.copy(h.start),f.subVectors(b.end,h.end),f.dot(r)<0?d.end.copy(b.end):d.end.copy(h.end)),!0)}}}();ct.prototype.distanceToPoint=function(){const a=new S;return function(s){return this.closestPointToPoint(s,a),s.distanceTo(a)}}();ct.prototype.distanceToTriangle=function(){const a=new S,t=new S,s=["a","b","c"],e=new ut,n=new ut;return function(i,r=null,c=null){const f=r||c?e:null;if(this.intersectsTriangle(i,f))return(r||c)&&(r&&f.getCenter(r),c&&f.getCenter(c)),0;let l=1/0;for(let b=0;b<3;b++){let h;const u=s[b],p=i[u];this.closestPointToPoint(p,a),h=p.distanceToSquared(a),h<l&&(l=h,r&&r.copy(a),c&&c.copy(p));const w=this[u];i.closestPointToPoint(w,a),h=w.distanceToSquared(a),h<l&&(l=h,r&&r.copy(w),c&&c.copy(a))}for(let b=0;b<3;b++){const h=s[b],u=s[(b+1)%3];e.set(this[h],this[u]);for(let p=0;p<3;p++){const w=s[p],y=s[(p+1)%3];n.set(i[w],i[y]),Ws(e,n,a,t);const d=a.distanceToSquared(t);d<l&&(l=d,r&&r.copy(a),c&&c.copy(t))}}return Math.sqrt(l)}}();class X{constructor(t,s,e){this.isOrientedBox=!0,this.min=new S,this.max=new S,this.matrix=new G,this.invMatrix=new G,this.points=new Array(8).fill().map(()=>new S),this.satAxes=new Array(3).fill().map(()=>new S),this.satBounds=new Array(3).fill().map(()=>new dt),this.alignedSatBounds=new Array(3).fill().map(()=>new dt),this.needsUpdate=!1,t&&this.min.copy(t),s&&this.max.copy(s),e&&this.matrix.copy(e)}set(t,s,e){this.min.copy(t),this.max.copy(s),this.matrix.copy(e),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}X.prototype.update=function(){return function(){const t=this.matrix,s=this.min,e=this.max,n=this.points;for(let f=0;f<=1;f++)for(let l=0;l<=1;l++)for(let b=0;b<=1;b++){const h=1*f|2*l|4*b,u=n[h];u.x=f?e.x:s.x,u.y=l?e.y:s.y,u.z=b?e.z:s.z,u.applyMatrix4(t)}const o=this.satBounds,i=this.satAxes,r=n[0];for(let f=0;f<3;f++){const l=i[f],b=o[f],h=1<<f,u=n[h];l.subVectors(r,u),b.setFromPoints(l,n)}const c=this.alignedSatBounds;c[0].setFromPointsField(n,"x"),c[1].setFromPointsField(n,"y"),c[2].setFromPointsField(n,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();X.prototype.intersectsBox=function(){const a=new dt;return function(s){this.needsUpdate&&this.update();const e=s.min,n=s.max,o=this.satBounds,i=this.satAxes,r=this.alignedSatBounds;if(a.min=e.x,a.max=n.x,r[0].isSeparated(a)||(a.min=e.y,a.max=n.y,r[1].isSeparated(a))||(a.min=e.z,a.max=n.z,r[2].isSeparated(a)))return!1;for(let c=0;c<3;c++){const f=i[c],l=o[c];if(a.setFromBox(f,s),l.isSeparated(a))return!1}return!0}}();X.prototype.intersectsTriangle=function(){const a=new ct,t=new Array(3),s=new dt,e=new dt,n=new S;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(a.copy(i),a.update(),i=a);const r=this.satBounds,c=this.satAxes;t[0]=i.a,t[1]=i.b,t[2]=i.c;for(let h=0;h<3;h++){const u=r[h],p=c[h];if(s.setFromPoints(p,t),u.isSeparated(s))return!1}const f=i.satBounds,l=i.satAxes,b=this.points;for(let h=0;h<3;h++){const u=f[h],p=l[h];if(s.setFromPoints(p,b),u.isSeparated(s))return!1}for(let h=0;h<3;h++){const u=c[h];for(let p=0;p<4;p++){const w=l[p];if(n.crossVectors(u,w),s.setFromPoints(n,t),e.setFromPoints(n,b),s.isSeparated(e))return!1}}return!0}}();X.prototype.closestPointToPoint=function(){return function(t,s){return this.needsUpdate&&this.update(),s.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),s}}();X.prototype.distanceToPoint=function(){const a=new S;return function(s){return this.closestPointToPoint(s,a),s.distanceTo(a)}}();X.prototype.distanceToBox=function(){const a=["x","y","z"],t=new Array(12).fill().map(()=>new ut),s=new Array(12).fill().map(()=>new ut),e=new S,n=new S;return function(i,r=0,c=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(c||f)&&(i.getCenter(n),this.closestPointToPoint(n,e),i.closestPointToPoint(e,n),c&&c.copy(e),f&&f.copy(n)),0;const l=r*r,b=i.min,h=i.max,u=this.points;let p=1/0;for(let y=0;y<8;y++){const d=u[y];n.copy(d).clamp(b,h);const _=d.distanceToSquared(n);if(_<p&&(p=_,c&&c.copy(d),f&&f.copy(n),_<l))return Math.sqrt(_)}let w=0;for(let y=0;y<3;y++)for(let d=0;d<=1;d++)for(let _=0;_<=1;_++){const x=(y+1)%3,m=(y+2)%3,g=d<<x|_<<m,I=1<<y|d<<x|_<<m,C=u[g],A=u[I];t[w].set(C,A);const v=a[y],P=a[x],V=a[m],M=s[w],D=M.start,B=M.end;D[v]=b[v],D[P]=d?b[P]:h[P],D[V]=_?b[V]:h[P],B[v]=h[v],B[P]=d?b[P]:h[P],B[V]=_?b[V]:h[P],w++}for(let y=0;y<=1;y++)for(let d=0;d<=1;d++)for(let _=0;_<=1;_++){n.x=y?h.x:b.x,n.y=d?h.y:b.y,n.z=_?h.z:b.z,this.closestPointToPoint(n,e);const x=n.distanceToSquared(e);if(x<p&&(p=x,c&&c.copy(e),f&&f.copy(n),x<l))return Math.sqrt(x)}for(let y=0;y<12;y++){const d=t[y];for(let _=0;_<12;_++){const x=s[_];Ws(d,x,e,n);const m=e.distanceToSquared(n);if(m<p&&(p=m,c&&c.copy(e),f&&f.copy(n),m<l))return Math.sqrt(m)}}return Math.sqrt(p)}}();class Qs{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class mn extends Qs{constructor(){super(()=>new ct)}}const Q=new mn;function J(a,t){return t[a+15]===65535}function W(a,t){return t[a+6]}function tt(a,t){return t[a+14]}function st(a){return a+8}function et(a,t){return t[a+6]}function De(a,t){return t[a+7]}class yn{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let s=null;this.setBuffer=e=>{s&&t.push(s),s=e,this.float32Array=new Float32Array(e),this.uint16Array=new Uint16Array(e),this.uint32Array=new Uint32Array(e)},this.clearBuffer=()=>{s=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const E=new yn;let xt,qt;const Lt=[],as=new Qs(()=>new nt);function gn(a,t,s,e,n,o){xt=as.getPrimitive(),qt=as.getPrimitive(),Lt.push(xt,qt),E.setBuffer(a._roots[t]);const i=Ns(0,a.geometry,s,e,n,o);E.clearBuffer(),as.releasePrimitive(xt),as.releasePrimitive(qt),Lt.pop(),Lt.pop();const r=Lt.length;return r>0&&(qt=Lt[r-1],xt=Lt[r-2]),i}function Ns(a,t,s,e,n=null,o=0,i=0){const{float32Array:r,uint16Array:c,uint32Array:f}=E;let l=a*2;if(J(l,c)){const h=W(a,f),u=tt(l,c);return R(a,r,xt),e(h,u,!1,i,o+a,xt)}else{let v=function(V){const{uint16Array:M,uint32Array:D}=E;let B=V*2;for(;!J(B,M);)V=st(V),B=V*2;return W(V,D)},P=function(V){const{uint16Array:M,uint32Array:D}=E;let B=V*2;for(;!J(B,M);)V=et(V,D),B=V*2;return W(V,D)+tt(B,M)};const h=st(a),u=et(a,f);let p=h,w=u,y,d,_,x;if(n&&(_=xt,x=qt,R(p,r,_),R(w,r,x),y=n(_),d=n(x),d<y)){p=u,w=h;const V=y;y=d,d=V,_=x}_||(_=xt,R(p,r,_));const m=J(p*2,c),g=s(_,m,y,i+1,o+p);let I;if(g===ne){const V=v(p),D=P(p)-V;I=e(V,D,!0,i+1,o+p,_)}else I=g&&Ns(p,t,s,e,n,o,i+1);if(I)return!0;x=qt,R(w,r,x);const C=J(w*2,c),A=s(x,C,d,i+1,o+w);let F;if(A===ne){const V=v(w),D=P(w)-V;F=e(V,D,!0,i+1,o+w,x)}else F=A&&Ns(w,t,s,e,n,o,i+1);return!!F}}const Zt=new S,Bs=new S;function xn(a,t,s={},e=0,n=1/0){const o=e*e,i=n*n;let r=1/0,c=null;if(a.shapecast({boundsTraverseOrder:l=>(Zt.copy(t).clamp(l.min,l.max),Zt.distanceToSquared(t)),intersectsBounds:(l,b,h)=>h<r&&h<i,intersectsTriangle:(l,b)=>{l.closestPointToPoint(t,Zt);const h=t.distanceToSquared(Zt);return h<r&&(Bs.copy(Zt),r=h,c=b),h<o}}),r===1/0)return null;const f=Math.sqrt(r);return s.point?s.point.copy(Bs):s.point=Bs.clone(),s.distance=f,s.faceIndex=c,s}const Ot=new S,zt=new S,Ut=new S,fs=new $t,ls=new $t,hs=new $t,ae=new S,fe=new S,le=new S,bs=new S;function wn(a,t,s,e,n,o){let i;return o===qe?i=a.intersectTriangle(e,s,t,!0,n):i=a.intersectTriangle(t,s,e,o!==$e,n),i===null?null:{distance:a.origin.distanceTo(n),point:n.clone()}}function An(a,t,s,e,n,o,i,r,c){Ot.fromBufferAttribute(t,o),zt.fromBufferAttribute(t,i),Ut.fromBufferAttribute(t,r);const f=wn(a,Ot,zt,Ut,bs,c);if(f){e&&(fs.fromBufferAttribute(e,o),ls.fromBufferAttribute(e,i),hs.fromBufferAttribute(e,r),f.uv=ts.getInterpolation(bs,Ot,zt,Ut,fs,ls,hs,new $t)),n&&(fs.fromBufferAttribute(n,o),ls.fromBufferAttribute(n,i),hs.fromBufferAttribute(n,r),f.uv1=ts.getInterpolation(bs,Ot,zt,Ut,fs,ls,hs,new $t)),s&&(ae.fromBufferAttribute(s,o),fe.fromBufferAttribute(s,i),le.fromBufferAttribute(s,r),f.normal=ts.getInterpolation(bs,Ot,zt,Ut,ae,fe,le,new S),f.normal.dot(a.direction)>0&&f.normal.multiplyScalar(-1));const l={a:o,b:i,c:r,normal:new S,materialIndex:0};ts.getNormal(Ot,zt,Ut,l.normal),f.face=l,f.faceIndex=o}return f}function Fs(a,t,s,e,n){const o=e*3;let i=o+0,r=o+1,c=o+2;const f=a.index;a.index&&(i=f.getX(i),r=f.getX(r),c=f.getX(c));const{position:l,normal:b,uv:h,uv1:u}=a.attributes,p=An(s,l,b,h,u,i,r,c,t);return p?(p.faceIndex=e,n&&n.push(p),p):null}function N(a,t,s,e){const n=a.a,o=a.b,i=a.c;let r=t,c=t+1,f=t+2;s&&(r=s.getX(r),c=s.getX(c),f=s.getX(f)),n.x=e.getX(r),n.y=e.getY(r),n.z=e.getZ(r),o.x=e.getX(c),o.y=e.getY(c),o.z=e.getZ(c),i.x=e.getX(f),i.y=e.getY(f),i.z=e.getZ(f)}function In(a,t,s,e,n,o){const{geometry:i,_indirectBuffer:r}=a;for(let c=e,f=e+n;c<f;c++)Fs(i,t,s,c,o)}function vn(a,t,s,e,n){const{geometry:o,_indirectBuffer:i}=a;let r=1/0,c=null;for(let f=e,l=e+n;f<l;f++){let b;b=Fs(o,t,s,f),b&&b.distance<r&&(c=b,r=b.distance)}return c}function Vn(a,t,s,e,n,o,i){const{geometry:r}=s,{index:c}=r,f=r.attributes.position;for(let l=a,b=t+a;l<b;l++){let h;if(h=l,N(i,h*3,c,f),i.needsUpdate=!0,e(i,h,n,o))return!0}return!1}function Cn(a,t=null){t&&Array.isArray(t)&&(t=new Set(t));const s=a.geometry,e=s.index?s.index.array:null,n=s.attributes.position;let o,i,r,c,f=0;const l=a._roots;for(let h=0,u=l.length;h<u;h++)o=l[h],i=new Uint32Array(o),r=new Uint16Array(o),c=new Float32Array(o),b(0,f),f+=o.byteLength;function b(h,u,p=!1){const w=h*2;if(r[w+15]===Cs){const d=i[h+6],_=r[w+14];let x=1/0,m=1/0,g=1/0,I=-1/0,C=-1/0,A=-1/0;for(let F=3*d,v=3*(d+_);F<v;F++){let P=e[F];const V=n.getX(P),M=n.getY(P),D=n.getZ(P);V<x&&(x=V),V>I&&(I=V),M<m&&(m=M),M>C&&(C=M),D<g&&(g=D),D>A&&(A=D)}return c[h+0]!==x||c[h+1]!==m||c[h+2]!==g||c[h+3]!==I||c[h+4]!==C||c[h+5]!==A?(c[h+0]=x,c[h+1]=m,c[h+2]=g,c[h+3]=I,c[h+4]=C,c[h+5]=A,!0):!1}else{const d=h+8,_=i[h+6],x=d+u,m=_+u;let g=p,I=!1,C=!1;t?g||(I=t.has(x),C=t.has(m),g=!I&&!C):(I=!0,C=!0);const A=g||I,F=g||C;let v=!1;A&&(v=b(d,u,g));let P=!1;F&&(P=b(_,u,g));const V=v||P;if(V)for(let M=0;M<3;M++){const D=d+M,B=_+M,L=c[D],H=c[D+3],Z=c[B],Y=c[B+3];c[h+M]=L<Z?L:Z,c[h+M+3]=H>Y?H:Y}return V}}}const he=new nt;function At(a,t,s,e){return R(a,t,he),s.intersectBox(he,e)}function Fn(a,t,s,e,n,o){const{geometry:i,_indirectBuffer:r}=a;for(let c=e,f=e+n;c<f;c++){let l=r?r[c]:c;Fs(i,t,s,l,o)}}function Mn(a,t,s,e,n){const{geometry:o,_indirectBuffer:i}=a;let r=1/0,c=null;for(let f=e,l=e+n;f<l;f++){let b;b=Fs(o,t,s,i?i[f]:f),b&&b.distance<r&&(c=b,r=b.distance)}return c}function Pn(a,t,s,e,n,o,i){const{geometry:r}=s,{index:c}=r,f=r.attributes.position;for(let l=a,b=t+a;l<b;l++){let h;if(h=s.resolveTriangleIndex(l),N(i,h*3,c,f),i.needsUpdate=!0,e(i,h,n,o))return!0}return!1}const be=new S;function Tn(a,t,s,e,n){E.setBuffer(a._roots[t]),Ks(0,a,s,e,n),E.clearBuffer()}function Ks(a,t,s,e,n){const{float32Array:o,uint16Array:i,uint32Array:r}=E,c=a*2;if(J(c,i)){const l=W(a,r),b=tt(c,i);In(t,s,e,l,b,n)}else{const l=st(a);At(l,o,e,be)&&Ks(l,t,s,e,n);const b=et(a,r);At(b,o,e,be)&&Ks(b,t,s,e,n)}}const ue=new S,Dn=["x","y","z"];function Sn(a,t,s,e){E.setBuffer(a._roots[t]);const n=qs(0,a,s,e);return E.clearBuffer(),n}function qs(a,t,s,e){const{float32Array:n,uint16Array:o,uint32Array:i}=E;let r=a*2;if(J(r,o)){const f=W(a,i),l=tt(r,o);return vn(t,s,e,f,l)}else{const f=De(a,i),l=Dn[f],h=e.direction[l]>=0;let u,p;h?(u=st(a),p=et(a,i)):(u=et(a,i),p=st(a));const y=At(u,n,e,ue)?qs(u,t,s,e):null;if(y){const x=y.point[l];if(h?x<=n[p+f]:x>=n[p+f+3])return y}const _=At(p,n,e,ue)?qs(p,t,s,e):null;return y&&_?y.distance<=_.distance?y:_:y||_||null}}const us=new nt,Et=new ct,Rt=new ct,Yt=new G,de=new X,ds=new X;function Bn(a,t,s,e){E.setBuffer(a._roots[t]);const n=$s(0,a,s,e);return E.clearBuffer(),n}function $s(a,t,s,e,n=null){const{float32Array:o,uint16Array:i,uint32Array:r}=E;let c=a*2;if(n===null&&(s.boundingBox||s.computeBoundingBox(),de.set(s.boundingBox.min,s.boundingBox.max,e),n=de),J(c,i)){const l=t.geometry,b=l.index,h=l.attributes.position,u=s.index,p=s.attributes.position,w=W(a,r),y=tt(c,i);if(Yt.copy(e).invert(),s.boundsTree)return R(a,o,ds),ds.matrix.copy(Yt),ds.needsUpdate=!0,s.boundsTree.shapecast({intersectsBounds:_=>ds.intersectsBox(_),intersectsTriangle:_=>{_.a.applyMatrix4(e),_.b.applyMatrix4(e),_.c.applyMatrix4(e),_.needsUpdate=!0;for(let x=w*3,m=(y+w)*3;x<m;x+=3)if(N(Rt,x,b,h),Rt.needsUpdate=!0,_.intersectsTriangle(Rt))return!0;return!1}});for(let d=w*3,_=(y+w)*3;d<_;d+=3){N(Et,d,b,h),Et.a.applyMatrix4(Yt),Et.b.applyMatrix4(Yt),Et.c.applyMatrix4(Yt),Et.needsUpdate=!0;for(let x=0,m=u.count;x<m;x+=3)if(N(Rt,x,u,p),Rt.needsUpdate=!0,Et.intersectsTriangle(Rt))return!0}}else{const l=a+8,b=r[a+6];return R(l,o,us),!!(n.intersectsBox(us)&&$s(l,t,s,e,n)||(R(b,o,us),n.intersectsBox(us)&&$s(b,t,s,e,n)))}}const ps=new G,Ls=new X,Jt=new X,Ln=new S,On=new S,zn=new S,Un=new S;function En(a,t,s,e={},n={},o=0,i=1/0){t.boundingBox||t.computeBoundingBox(),Ls.set(t.boundingBox.min,t.boundingBox.max,s),Ls.needsUpdate=!0;const r=a.geometry,c=r.attributes.position,f=r.index,l=t.attributes.position,b=t.index,h=Q.getPrimitive(),u=Q.getPrimitive();let p=Ln,w=On,y=null,d=null;n&&(y=zn,d=Un);let _=1/0,x=null,m=null;return ps.copy(s).invert(),Jt.matrix.copy(ps),a.shapecast({boundsTraverseOrder:g=>Ls.distanceToBox(g),intersectsBounds:(g,I,C)=>C<_&&C<i?(I&&(Jt.min.copy(g.min),Jt.max.copy(g.max),Jt.needsUpdate=!0),!0):!1,intersectsRange:(g,I)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:A=>Jt.distanceToBox(A),intersectsBounds:(A,F,v)=>v<_&&v<i,intersectsRange:(A,F)=>{for(let v=A,P=A+F;v<P;v++){N(u,3*v,b,l),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let V=g,M=g+I;V<M;V++){N(h,3*V,f,c),h.needsUpdate=!0;const D=h.distanceToTriangle(u,p,y);if(D<_&&(w.copy(p),d&&d.copy(y),_=D,x=V,m=v),D<o)return!0}}}});{const C=jt(t);for(let A=0,F=C;A<F;A++){N(u,3*A,b,l),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let v=g,P=g+I;v<P;v++){N(h,3*v,f,c),h.needsUpdate=!0;const V=h.distanceToTriangle(u,p,y);if(V<_&&(w.copy(p),d&&d.copy(y),_=V,x=v,m=A),V<o)return!0}}}}}),Q.releasePrimitive(h),Q.releasePrimitive(u),_===1/0?null:(e.point?e.point.copy(w):e.point=w.clone(),e.distance=_,e.faceIndex=x,n&&(n.point?n.point.copy(d):n.point=d.clone(),n.point.applyMatrix4(ps),w.applyMatrix4(ps),n.distance=w.sub(n.point).length(),n.faceIndex=m),e)}function Rn(a,t=null){t&&Array.isArray(t)&&(t=new Set(t));const s=a.geometry,e=s.index?s.index.array:null,n=s.attributes.position;let o,i,r,c,f=0;const l=a._roots;for(let h=0,u=l.length;h<u;h++)o=l[h],i=new Uint32Array(o),r=new Uint16Array(o),c=new Float32Array(o),b(0,f),f+=o.byteLength;function b(h,u,p=!1){const w=h*2;if(r[w+15]===Cs){const d=i[h+6],_=r[w+14];let x=1/0,m=1/0,g=1/0,I=-1/0,C=-1/0,A=-1/0;for(let F=d,v=d+_;F<v;F++){const P=3*a.resolveTriangleIndex(F);for(let V=0;V<3;V++){let M=P+V;M=e?e[M]:M;const D=n.getX(M),B=n.getY(M),L=n.getZ(M);D<x&&(x=D),D>I&&(I=D),B<m&&(m=B),B>C&&(C=B),L<g&&(g=L),L>A&&(A=L)}}return c[h+0]!==x||c[h+1]!==m||c[h+2]!==g||c[h+3]!==I||c[h+4]!==C||c[h+5]!==A?(c[h+0]=x,c[h+1]=m,c[h+2]=g,c[h+3]=I,c[h+4]=C,c[h+5]=A,!0):!1}else{const d=h+8,_=i[h+6],x=d+u,m=_+u;let g=p,I=!1,C=!1;t?g||(I=t.has(x),C=t.has(m),g=!I&&!C):(I=!0,C=!0);const A=g||I,F=g||C;let v=!1;A&&(v=b(d,u,g));let P=!1;F&&(P=b(_,u,g));const V=v||P;if(V)for(let M=0;M<3;M++){const D=d+M,B=_+M,L=c[D],H=c[D+3],Z=c[B],Y=c[B+3];c[h+M]=L<Z?L:Z,c[h+M+3]=H>Y?H:Y}return V}}}const pe=new S;function Gn(a,t,s,e,n){E.setBuffer(a._roots[t]),js(0,a,s,e,n),E.clearBuffer()}function js(a,t,s,e,n){const{float32Array:o,uint16Array:i,uint32Array:r}=E,c=a*2;if(J(c,i)){const l=W(a,r),b=tt(c,i);Fn(t,s,e,l,b,n)}else{const l=st(a);At(l,o,e,pe)&&js(l,t,s,e,n);const b=et(a,r);At(b,o,e,pe)&&js(b,t,s,e,n)}}const _e=new S,kn=["x","y","z"];function Nn(a,t,s,e){E.setBuffer(a._roots[t]);const n=Hs(0,a,s,e);return E.clearBuffer(),n}function Hs(a,t,s,e){const{float32Array:n,uint16Array:o,uint32Array:i}=E;let r=a*2;if(J(r,o)){const f=W(a,i),l=tt(r,o);return Mn(t,s,e,f,l)}else{const f=De(a,i),l=kn[f],h=e.direction[l]>=0;let u,p;h?(u=st(a),p=et(a,i)):(u=et(a,i),p=st(a));const y=At(u,n,e,_e)?Hs(u,t,s,e):null;if(y){const x=y.point[l];if(h?x<=n[p+f]:x>=n[p+f+3])return y}const _=At(p,n,e,_e)?Hs(p,t,s,e):null;return y&&_?y.distance<=_.distance?y:_:y||_||null}}const _s=new nt,Gt=new ct,kt=new ct,Wt=new G,me=new X,ms=new X;function Kn(a,t,s,e){E.setBuffer(a._roots[t]);const n=Xs(0,a,s,e);return E.clearBuffer(),n}function Xs(a,t,s,e,n=null){const{float32Array:o,uint16Array:i,uint32Array:r}=E;let c=a*2;if(n===null&&(s.boundingBox||s.computeBoundingBox(),me.set(s.boundingBox.min,s.boundingBox.max,e),n=me),J(c,i)){const l=t.geometry,b=l.index,h=l.attributes.position,u=s.index,p=s.attributes.position,w=W(a,r),y=tt(c,i);if(Wt.copy(e).invert(),s.boundsTree)return R(a,o,ms),ms.matrix.copy(Wt),ms.needsUpdate=!0,s.boundsTree.shapecast({intersectsBounds:_=>ms.intersectsBox(_),intersectsTriangle:_=>{_.a.applyMatrix4(e),_.b.applyMatrix4(e),_.c.applyMatrix4(e),_.needsUpdate=!0;for(let x=w,m=y+w;x<m;x++)if(N(kt,3*t.resolveTriangleIndex(x),b,h),kt.needsUpdate=!0,_.intersectsTriangle(kt))return!0;return!1}});for(let d=w,_=y+w;d<_;d++){const x=t.resolveTriangleIndex(d);N(Gt,3*x,b,h),Gt.a.applyMatrix4(Wt),Gt.b.applyMatrix4(Wt),Gt.c.applyMatrix4(Wt),Gt.needsUpdate=!0;for(let m=0,g=u.count;m<g;m+=3)if(N(kt,m,u,p),kt.needsUpdate=!0,Gt.intersectsTriangle(kt))return!0}}else{const l=a+8,b=r[a+6];return R(l,o,_s),!!(n.intersectsBox(_s)&&Xs(l,t,s,e,n)||(R(b,o,_s),n.intersectsBox(_s)&&Xs(b,t,s,e,n)))}}const ys=new G,Os=new X,Qt=new X,qn=new S,$n=new S,jn=new S,Hn=new S;function Xn(a,t,s,e={},n={},o=0,i=1/0){t.boundingBox||t.computeBoundingBox(),Os.set(t.boundingBox.min,t.boundingBox.max,s),Os.needsUpdate=!0;const r=a.geometry,c=r.attributes.position,f=r.index,l=t.attributes.position,b=t.index,h=Q.getPrimitive(),u=Q.getPrimitive();let p=qn,w=$n,y=null,d=null;n&&(y=jn,d=Hn);let _=1/0,x=null,m=null;return ys.copy(s).invert(),Qt.matrix.copy(ys),a.shapecast({boundsTraverseOrder:g=>Os.distanceToBox(g),intersectsBounds:(g,I,C)=>C<_&&C<i?(I&&(Qt.min.copy(g.min),Qt.max.copy(g.max),Qt.needsUpdate=!0),!0):!1,intersectsRange:(g,I)=>{if(t.boundsTree){const C=t.boundsTree;return C.shapecast({boundsTraverseOrder:A=>Qt.distanceToBox(A),intersectsBounds:(A,F,v)=>v<_&&v<i,intersectsRange:(A,F)=>{for(let v=A,P=A+F;v<P;v++){const V=C.resolveTriangleIndex(v);N(u,3*V,b,l),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let M=g,D=g+I;M<D;M++){const B=a.resolveTriangleIndex(M);N(h,3*B,f,c),h.needsUpdate=!0;const L=h.distanceToTriangle(u,p,y);if(L<_&&(w.copy(p),d&&d.copy(y),_=L,x=M,m=v),L<o)return!0}}}})}else{const C=jt(t);for(let A=0,F=C;A<F;A++){N(u,3*A,b,l),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let v=g,P=g+I;v<P;v++){const V=a.resolveTriangleIndex(v);N(h,3*V,f,c),h.needsUpdate=!0;const M=h.distanceToTriangle(u,p,y);if(M<_&&(w.copy(p),d&&d.copy(y),_=M,x=v,m=A),M<o)return!0}}}}}),Q.releasePrimitive(h),Q.releasePrimitive(u),_===1/0?null:(e.point?e.point.copy(w):e.point=w.clone(),e.distance=_,e.faceIndex=x,n&&(n.point?n.point.copy(d):n.point=d.clone(),n.point.applyMatrix4(ys),w.applyMatrix4(ys),n.distance=w.sub(n.point).length(),n.faceIndex=m),e)}function Zn(){return typeof SharedArrayBuffer<"u"}const ss=new E.constructor,vs=new E.constructor,gt=new Qs(()=>new nt),Nt=new nt,Kt=new nt,zs=new nt,Us=new nt;let Es=!1;function Yn(a,t,s,e){if(Es)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Es=!0;const n=a._roots,o=t._roots;let i,r=0,c=0;const f=new G().copy(s).invert();for(let l=0,b=n.length;l<b;l++){ss.setBuffer(n[l]),c=0;const h=gt.getPrimitive();R(0,ss.float32Array,h),h.applyMatrix4(f);for(let u=0,p=o.length;u<p&&(vs.setBuffer(o[l]),i=it(0,0,s,f,e,r,c,0,0,h),vs.clearBuffer(),c+=o[u].length,!i);u++);if(gt.releasePrimitive(h),ss.clearBuffer(),r+=n[l].length,i)break}return Es=!1,i}function it(a,t,s,e,n,o=0,i=0,r=0,c=0,f=null,l=!1){let b,h;l?(b=vs,h=ss):(b=ss,h=vs);const u=b.float32Array,p=b.uint32Array,w=b.uint16Array,y=h.float32Array,d=h.uint32Array,_=h.uint16Array,x=a*2,m=t*2,g=J(x,w),I=J(m,_);let C=!1;if(I&&g)l?C=n(W(t,d),tt(t*2,_),W(a,p),tt(a*2,w),c,i+t,r,o+a):C=n(W(a,p),tt(a*2,w),W(t,d),tt(t*2,_),r,o+a,c,i+t);else if(I){const A=gt.getPrimitive();R(t,y,A),A.applyMatrix4(s);const F=st(a),v=et(a,p);R(F,u,Nt),R(v,u,Kt);const P=A.intersectsBox(Nt),V=A.intersectsBox(Kt);C=P&&it(t,F,e,s,n,i,o,c,r+1,A,!l)||V&&it(t,v,e,s,n,i,o,c,r+1,A,!l),gt.releasePrimitive(A)}else{const A=st(t),F=et(t,d);R(A,y,zs),R(F,y,Us);const v=f.intersectsBox(zs),P=f.intersectsBox(Us);if(v&&P)C=it(a,A,s,e,n,o,i,r,c+1,f,l)||it(a,F,s,e,n,o,i,r,c+1,f,l);else if(v)if(g)C=it(a,A,s,e,n,o,i,r,c+1,f,l);else{const V=gt.getPrimitive();V.copy(zs).applyMatrix4(s);const M=st(a),D=et(a,p);R(M,u,Nt),R(D,u,Kt);const B=V.intersectsBox(Nt),L=V.intersectsBox(Kt);C=B&&it(A,M,e,s,n,i,o,c,r+1,V,!l)||L&&it(A,D,e,s,n,i,o,c,r+1,V,!l),gt.releasePrimitive(V)}else if(P)if(g)C=it(a,F,s,e,n,o,i,r,c+1,f,l);else{const V=gt.getPrimitive();V.copy(Us).applyMatrix4(s);const M=st(a),D=et(a,p);R(M,u,Nt),R(D,u,Kt);const B=V.intersectsBox(Nt),L=V.intersectsBox(Kt);C=B&&it(F,M,e,s,n,i,o,c,r+1,V,!l)||L&&it(F,D,e,s,n,i,o,c,r+1,V,!l),gt.releasePrimitive(V)}}return C}const gs=new X,ye=new nt;class te{static serialize(t,s={}){s={cloneBuffers:!0,...s};const e=t.geometry,n=t._roots,o=t._indirectBuffer,i=e.getIndex();let r;return s.cloneBuffers?r={roots:n.map(c=>c.slice()),index:i.array.slice(),indirectBuffer:o?o.slice():null}:r={roots:n,index:i.array,indirectBuffer:o},r}static deserialize(t,s,e={}){e={setIndex:!0,indirect:!!t.indirectBuffer,...e};const{index:n,roots:o,indirectBuffer:i}=t,r=new te(s,{...e,[Ts]:!0});if(r._roots=o,r._indirectBuffer=i||null,e.setIndex){const c=s.getIndex();if(c===null){const f=new wt(t.index,1,!1);s.setIndex(f)}else c.array!==n&&(c.array.set(n),c.needsUpdate=!0)}return r}get indirect(){return!!this._indirectBuffer}constructor(t,s={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(s=Object.assign({strategy:Me,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[Ts]:!1},s),s.useSharedArrayBuffer&&!Zn())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,s[Ts]||(un(this,s),!t.boundingBox&&s.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new nt)));const{_indirectBuffer:e}=this;this.resolveTriangleIndex=s.indirect?n=>e[n]:n=>n}refit(t=null){return(this.indirect?Rn:Cn)(this,t)}traverse(t,s=0){const e=this._roots[s],n=new Uint32Array(e),o=new Uint16Array(e);i(0);function i(r,c=0){const f=r*2,l=o[f+15]===Cs;if(l){const b=n[r+6],h=o[f+14];t(c,l,new Float32Array(e,r*4,6),b,h)}else{const b=r+xs/4,h=n[r+6],u=n[r+7];t(c,l,new Float32Array(e,r*4,6),u)||(i(b,c+1),i(h,c+1))}}}raycast(t,s=se){const e=this._roots,n=this.geometry,o=[],i=s.isMaterial,r=Array.isArray(s),c=n.groups,f=i?s.side:s,l=this.indirect?Gn:Tn;for(let b=0,h=e.length;b<h;b++){const u=r?s[c[b].materialIndex].side:f,p=o.length;if(l(this,b,u,t,o),r){const w=c[b].materialIndex;for(let y=p,d=o.length;y<d;y++)o[y].face.materialIndex=w}}return o}raycastFirst(t,s=se){const e=this._roots,n=this.geometry,o=s.isMaterial,i=Array.isArray(s);let r=null;const c=n.groups,f=o?s.side:s,l=this.indirect?Nn:Sn;for(let b=0,h=e.length;b<h;b++){const u=i?s[c[b].materialIndex].side:f,p=l(this,b,u,t);p!=null&&(r==null||p.distance<r.distance)&&(r=p,i&&(p.face.materialIndex=c[b].materialIndex))}return r}intersectsGeometry(t,s){let e=!1;const n=this._roots,o=this.indirect?Kn:Bn;for(let i=0,r=n.length;i<r&&(e=o(this,i,t,s),!e);i++);return e}shapecast(t){const s=Q.getPrimitive(),e=this.indirect?Pn:Vn;let{boundsTraverseOrder:n,intersectsBounds:o,intersectsRange:i,intersectsTriangle:r}=t;if(i&&r){const b=i;i=(h,u,p,w,y)=>b(h,u,p,w,y)?!0:e(h,u,this,r,p,w,s)}else i||(r?i=(b,h,u,p)=>e(b,h,this,r,u,p,s):i=(b,h,u)=>u);let c=!1,f=0;const l=this._roots;for(let b=0,h=l.length;b<h;b++){const u=l[b];if(c=gn(this,b,o,i,n,f),c)break;f+=u.byteLength}return Q.releasePrimitive(s),c}bvhcast(t,s,e){let{intersectsRanges:n,intersectsTriangles:o}=e;const i=Q.getPrimitive(),r=this.geometry.index,c=this.geometry.attributes.position,f=this.indirect?p=>{const w=this.resolveTriangleIndex(p);N(i,w*3,r,c)}:p=>{N(i,p*3,r,c)},l=Q.getPrimitive(),b=t.geometry.index,h=t.geometry.attributes.position,u=t.indirect?p=>{const w=t.resolveTriangleIndex(p);N(l,w*3,b,h)}:p=>{N(l,p*3,b,h)};if(o){const p=(w,y,d,_,x,m,g,I)=>{for(let C=d,A=d+_;C<A;C++){u(C),l.a.applyMatrix4(s),l.b.applyMatrix4(s),l.c.applyMatrix4(s),l.needsUpdate=!0;for(let F=w,v=w+y;F<v;F++)if(f(F),i.needsUpdate=!0,o(i,l,F,C,x,m,g,I))return!0}return!1};if(n){const w=n;n=function(y,d,_,x,m,g,I,C){return w(y,d,_,x,m,g,I,C)?!0:p(y,d,_,x,m,g,I,C)}}else n=p}return Yn(this,t,s,n)}intersectsBox(t,s){return gs.set(t.min,t.max,s),gs.needsUpdate=!0,this.shapecast({intersectsBounds:e=>gs.intersectsBox(e),intersectsTriangle:e=>gs.intersectsTriangle(e)})}intersectsSphere(t){return this.shapecast({intersectsBounds:s=>t.intersectsBox(s),intersectsTriangle:s=>s.intersectsSphere(t)})}closestPointToGeometry(t,s,e={},n={},o=0,i=1/0){return(this.indirect?Xn:En)(this,t,s,e,n,o,i)}closestPointToPoint(t,s={},e=0,n=1/0){return xn(this,t,s,e,n)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(e=>{R(0,new Float32Array(e),ye),t.union(ye)}),t}}function ge(a,t,s){return a===null||(a.point.applyMatrix4(t.matrixWorld),a.distance=a.point.distanceTo(s.ray.origin),a.object=t,a.distance<s.near||a.distance>s.far)?null:a}const Rs=new je,xe=new G,Jn=Ae.prototype.raycast;function Wn(a,t){if(this.geometry.boundsTree){if(this.material===void 0)return;xe.copy(this.matrixWorld).invert(),Rs.copy(a.ray).applyMatrix4(xe);const s=this.geometry.boundsTree;if(a.firstHitOnly===!0){const e=ge(s.raycastFirst(Rs,this.material),this,a);e&&t.push(e)}else{const e=s.raycast(Rs,this.material);for(let n=0,o=e.length;n<o;n++){const i=ge(e[n],this,a);i&&t.push(i)}}}else Jn.call(this,a,t)}function Qn(a){return this.boundsTree=new te(this,a),this.boundsTree}function ti(){this.boundsTree=null}const es=class es{static apply(t){es.initialized||(Is.prototype.computeBoundsTree=Qn,Is.prototype.disposeBoundsTree=ti,Ae.prototype.raycast=Wn,es.initialized=!0),t.boundsTree||t.computeBoundsTree()}static dispose(t){t&&t.disposeBoundsTree&&t.disposeBoundsTree()}};T(es,"initialized",!1);let Vs=es,Se=class Be{constructor(t,s,e){T(this,"ids",new Set);T(this,"itemToInstances",new Map);T(this,"instanceToItem",new Map);T(this,"hiddenItems",new Set);T(this,"id");T(this,"mesh");T(this,"capacity",0);T(this,"capacityOffset",10);T(this,"group");T(this,"_originalColors",new Map);T(this,"_settingVisibility",!1);this.mesh=new ee(t,s,e,this),this.id=this.mesh.uuid,this.capacity=e,this.mesh.count=0,this.mesh.geometry.index.count&&Vs.apply(this.mesh.geometry)}get uniqueVertices(){const t=[],s=this.mesh.geometry.getAttribute("position");if(!s)return t;const e=new Set;for(let n=0;n<s.count;n++){const o=s.getX(n),i=s.getY(n),r=s.getZ(n),c=`${o},${i},${r}`;e.has(c)||(e.add(c),t.push(new S(o,i,r)))}return t}dispose(t=!0){if(this.clear(),this.group=void 0,this._originalColors.clear(),this.mesh){if(t){for(const s of this.mesh.material)s.dispose();this.mesh.material=[],Vs.dispose(this.mesh.geometry),this.mesh.geometry&&this.mesh.geometry.dispose(),this.mesh.geometry=null}this.mesh.removeFromParent(),this.mesh.userData={},this.mesh.dispose(),this.mesh.fragment=null,this.mesh=null}}get(t){const s=this.getInstancesIDs(t);if(!s)throw new Error("Item not found!");const e=[],n=[];for(const i of s){const r=new G;if(this.mesh.getMatrixAt(i,r),e.push(r),this.mesh.instanceColor){const c=new rt;this.mesh.getColorAt(i,c),n.push(c)}}const o=n.length?n:void 0;return{id:t,transforms:e,colors:o}}getItemID(t){return this.instanceToItem.get(t)||null}getInstancesIDs(t){return this.itemToInstances.get(t)||null}update(){this.mesh.instanceColor&&(this.mesh.instanceColor.needsUpdate=!0),this.mesh.instanceMatrix.needsUpdate=!0}add(t){var n;let s=0;for(const o of t)s+=o.transforms.length;const e=this.mesh.count+s;if(e>this.capacity){const o=e+this.capacityOffset,i=new ee(this.mesh.geometry,this.mesh.material,o,this);i.count=this.mesh.count,this.capacity=o;const r=this.mesh;(n=r.parent)==null||n.add(i),r.removeFromParent(),this.mesh=i;const c=new G;for(let f=0;f<r.instanceMatrix.count;f++)r.getMatrixAt(f,c),i.setMatrixAt(f,c);if(r.instanceColor){const f=new rt;for(let l=0;l<r.instanceColor.count;l++)r.getColorAt(l,f),i.setColorAt(l,f)}r.dispose()}for(let o=0;o<t.length;o++){const{transforms:i,colors:r,id:c}=t[o];this.itemToInstances.has(c)||this.itemToInstances.set(c,new Set);const f=this.itemToInstances.get(c);this.ids.add(c);for(let l=0;l<i.length;l++){const b=i[l],h=this.mesh.count;if(this.mesh.setMatrixAt(h,b),r){const u=r[l];this.mesh.setColorAt(h,u)}f.add(h),this.instanceToItem.set(h,c),this.mesh.count++}}this.update()}remove(t){if(this.mesh.count!==0){for(const s of t){const e=this.itemToInstances.get(s);if(e===void 0)throw new Error("Instances not found!");for(const n of e){if(this.mesh.count===0)throw new Error("Error with mesh count!");this.putLast(n),this.instanceToItem.delete(n),this.mesh.count--}this.itemToInstances.delete(s),this.ids.delete(s)}this.update()}}clear(){this.hiddenItems.clear(),this.ids.clear(),this.instanceToItem.clear(),this.itemToInstances.clear(),this.mesh.count=0}setVisibility(t,s=this.ids){if(!this._settingVisibility){if(this._settingVisibility=!0,t)for(const e of s){if(!this.ids.has(e)||!this.hiddenItems.has(e))continue;const n=this.itemToInstances.get(e);if(!n)throw new Error("Instances not found!");for(const o of new Set(n))this.mesh.count++,this.putLast(o);this.hiddenItems.delete(e)}else for(const e of s){if(!this.ids.has(e)||this.hiddenItems.has(e))continue;const n=this.itemToInstances.get(e);if(!n)throw new Error("Instances not found!");for(const o of new Set(n))this.putLast(o),this.mesh.count--;this.hiddenItems.add(e)}this.update(),this._settingVisibility=!1}}setColor(t,s=this.ids,e=!1){if(!this.mesh.instanceColor)throw new Error("This fragment doesn't have color per instance!");for(const n of s){if(!this.ids.has(n))continue;const o=this.itemToInstances.get(n);if(!o)throw new Error("Instances not found!");const i=this._originalColors.has(n);i||this._originalColors.set(n,new Map);const r=this._originalColors.get(n);for(const c of new Set(o)){if(!i){const f=new rt;this.mesh.getColorAt(c,f),r.set(c,f)}this.mesh.setColorAt(c,t),e&&r.set(c,t)}}this.mesh.instanceColor.needsUpdate=!0}resetColor(t=this.ids){if(!this.mesh.instanceColor)throw new Error("This fragment doesn't have color per instance!");for(const s of t){if(!this.ids.has(s))continue;const e=this.itemToInstances.get(s);if(!e)throw new Error("Instances not found!");const n=this._originalColors.get(s);if(n)for(const o of new Set(e)){const i=n.get(o);if(!i)throw new Error("Original color not found!");this.mesh.setColorAt(o,i)}}this.mesh.instanceColor.needsUpdate=!0}applyTransform(t,s){const e=new G;for(const n of t){const o=this.getInstancesIDs(n);if(o!==null)for(const i of o)this.mesh.getMatrixAt(i,e),e.premultiply(s),this.mesh.setMatrixAt(i,e)}this.update()}exportData(){const t=this.mesh.exportData(),s=Array.from(this.ids),e=this.id;return{...t,ids:s,id:e}}clone(t=this.ids){const s=new Be(this.mesh.geometry,this.mesh.material,this.capacity),e=[];for(const n of t){const o=this.getInstancesIDs(n);if(o===null)continue;const i=[],r=[];for(const c of o){const f=new G,l=new rt;this.mesh.getMatrixAt(c,f),this.mesh.getColorAt(c,l),i.push(f),r.push(l)}e.push({id:n,transforms:i,colors:r})}return s.add(e),s}putLast(t){if(this.mesh.count===0)return;const s=this.instanceToItem.get(t),e=this.mesh.count-1;if(e===t)return;const n=this.instanceToItem.get(e);if(s===void 0||n===void 0)throw new Error("Keys not found");if(s!==n){const r=this.itemToInstances.get(s),c=this.itemToInstances.get(n);if(!r||!c)throw new Error("Instances not found");if(!r.has(t)||!c.has(e))throw new Error("Malformed fragment structure");r.delete(t),c.delete(e),r.add(e),c.add(t),this.instanceToItem.set(t,n),this.instanceToItem.set(e,s)}const o=new G,i=new G;if(this.mesh.getMatrixAt(t,o),this.mesh.getMatrixAt(e,i),this.mesh.setMatrixAt(t,i),this.mesh.setMatrixAt(e,o),this.mesh.instanceColor!==null){const r=new rt,c=new rt;this.mesh.getColorAt(t,r),this.mesh.getColorAt(e,c),this.mesh.setColorAt(t,c),this.mesh.setColorAt(e,r);const f=this._originalColors.get(s);if(f){const b=f.get(t);b&&(f.delete(t),f.set(e,b))}const l=this._originalColors.get(n);if(l){const b=l.get(e);b&&(l.delete(e),l.set(t,b))}}}},ws=class Pt{constructor(){T(this,"bb",null);T(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilCurve(t,s){return(s||new Pt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilCurve(t,s){return t.setPosition(t.position()+ft),(s||new Pt).__init(t.readInt32(t.position())+t.position(),t)}points(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}data(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,t):null}static startCivilCurve(t){t.startObject(2)}static addPoints(t,s){t.addFieldOffset(0,s,0)}static createPointsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPointsVector(t,s){t.startVector(4,s,4)}static addData(t,s){t.addFieldOffset(1,s,0)}static endCivilCurve(t){return t.endObject()}static createCivilCurve(t,s,e){return Pt.startCivilCurve(t),Pt.addPoints(t,s),Pt.addData(t,e),Pt.endCivilCurve(t)}},Le=class ht{constructor(){T(this,"bb",null);T(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsAlignment(t,s){return(s||new ht).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAlignment(t,s){return t.setPosition(t.position()+ft),(s||new ht).__init(t.readInt32(t.position())+t.position(),t)}vertical(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new ws).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}verticalLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontal(t,s){const e=this.bb.__offset(this.bb_pos,6);return e?(s||new ws).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}absolute(t,s){const e=this.bb.__offset(this.bb_pos,8);return e?(s||new ws).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}absoluteLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}initialPk(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}static startAlignment(t){t.startObject(4)}static addVertical(t,s){t.addFieldOffset(0,s,0)}static createVerticalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startVerticalVector(t,s){t.startVector(4,s,4)}static addHorizontal(t,s){t.addFieldOffset(1,s,0)}static createHorizontalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startHorizontalVector(t,s){t.startVector(4,s,4)}static addAbsolute(t,s){t.addFieldOffset(2,s,0)}static createAbsoluteVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAbsoluteVector(t,s){t.startVector(4,s,4)}static addInitialPk(t,s){t.addFieldFloat32(3,s,0)}static endAlignment(t){return t.endObject()}static createAlignment(t,s,e,n,o){return ht.startAlignment(t),ht.addVertical(t,s),ht.addHorizontal(t,e),ht.addAbsolute(t,n),ht.addInitialPk(t,o),ht.endAlignment(t)}},Oe=class Tt{constructor(){T(this,"bb",null);T(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilData(t,s){return(s||new Tt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilData(t,s){return t.setPosition(t.position()+ft),(s||new Tt).__init(t.readInt32(t.position())+t.position(),t)}alignments(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new Le).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startCivilData(t){t.startObject(2)}static addAlignments(t,s){t.addFieldOffset(0,s,0)}static createAlignmentsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAlignmentsVector(t,s){t.startVector(4,s,4)}static addCoordinationMatrix(t,s){t.addFieldOffset(1,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static endCivilData(t){return t.endObject()}static createCivilData(t,s,e){return Tt.startCivilData(t),Tt.addAlignments(t,s),Tt.addCoordinationMatrix(t,e),Tt.endCivilData(t)}},Zs=class ${constructor(){T(this,"bb",null);T(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragment(t,s){return(s||new $).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragment(t,s){return t.setPosition(t.position()+ft),(s||new $).__init(t.readInt32(t.position())+t.position(),t)}position(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}positionLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}normalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}indexLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}groups(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}groupsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}groupsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}materials(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}materialsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}matrices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}matricesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}matricesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}colors(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}colorsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}colorsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsSize(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsSizeLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsSizeArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,20);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}id(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}capacity(){const t=this.bb.__offset(this.bb_pos,24);return t?this.bb.readUint32(this.bb_pos+t):0}capacityOffset(){const t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readUint32(this.bb_pos+t):0}static startFragment(t){t.startObject(12)}static addPosition(t,s){t.addFieldOffset(0,s,0)}static createPositionVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPositionVector(t,s){t.startVector(4,s,4)}static addNormal(t,s){t.addFieldOffset(1,s,0)}static createNormalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startNormalVector(t,s){t.startVector(4,s,4)}static addIndex(t,s){t.addFieldOffset(2,s,0)}static createIndexVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIndexVector(t,s){t.startVector(4,s,4)}static addGroups(t,s){t.addFieldOffset(3,s,0)}static createGroupsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startGroupsVector(t,s){t.startVector(4,s,4)}static addMaterials(t,s){t.addFieldOffset(4,s,0)}static createMaterialsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMaterialsVector(t,s){t.startVector(4,s,4)}static addMatrices(t,s){t.addFieldOffset(5,s,0)}static createMatricesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMatricesVector(t,s){t.startVector(4,s,4)}static addColors(t,s){t.addFieldOffset(6,s,0)}static createColorsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startColorsVector(t,s){t.startVector(4,s,4)}static addItemsSize(t,s){t.addFieldOffset(7,s,0)}static createItemsSizeVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsSizeVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(8,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addId(t,s){t.addFieldOffset(9,s,0)}static addCapacity(t,s){t.addFieldInt32(10,s,0)}static addCapacityOffset(t,s){t.addFieldInt32(11,s,0)}static endFragment(t){return t.endObject()}static createFragment(t,s,e,n,o,i,r,c,f,l,b,h,u){return $.startFragment(t),$.addPosition(t,s),$.addNormal(t,e),$.addIndex(t,n),$.addGroups(t,o),$.addMaterials(t,i),$.addMatrices(t,r),$.addColors(t,c),$.addItemsSize(t,f),$.addIds(t,l),$.addId(t,b),$.addCapacity(t,h),$.addCapacityOffset(t,u),$.endFragment(t)}},Gs=class Ys{constructor(){T(this,"bb",null);T(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragmentsGroup(t,s){return(s||new Ys).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragmentsGroup(t,s){return t.setPosition(t.position()+ft),(s||new Ys).__init(t.readInt32(t.position())+t.position(),t)}items(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new Zs).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}itemsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}civil(t){const s=this.bb.__offset(this.bb_pos,6);return s?(t||new Oe).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeys(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeysIndices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysIndicesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysIndicesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRels(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRelsIndices(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsIndicesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsIndicesArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}fragmentKeys(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.__string(this.bb_pos+s,t):null}id(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}name(t){const s=this.bb.__offset(this.bb_pos,24);return s?this.bb.__string(this.bb_pos+s,t):null}ifcName(t){const s=this.bb.__offset(this.bb_pos,26);return s?this.bb.__string(this.bb_pos+s,t):null}ifcDescription(t){const s=this.bb.__offset(this.bb_pos,28);return s?this.bb.__string(this.bb_pos+s,t):null}ifcSchema(t){const s=this.bb.__offset(this.bb_pos,30);return s?this.bb.__string(this.bb_pos+s,t):null}maxExpressId(){const t=this.bb.__offset(this.bb_pos,32);return t?this.bb.readUint32(this.bb_pos+t):0}boundingBox(t){const s=this.bb.__offset(this.bb_pos,34);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}boundingBoxLength(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.__vector_len(this.bb_pos+t):0}boundingBoxArray(){const t=this.bb.__offset(this.bb_pos,34);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}opaqueGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,36);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}opaqueGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,36);return t?this.bb.__vector_len(this.bb_pos+t):0}opaqueGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,36);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transparentGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,38);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}transparentGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,38);return t?this.bb.__vector_len(this.bb_pos+t):0}transparentGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,38);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startFragmentsGroup(t){t.startObject(18)}static addItems(t,s){t.addFieldOffset(0,s,0)}static createItemsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startItemsVector(t,s){t.startVector(4,s,4)}static addCivil(t,s){t.addFieldOffset(1,s,0)}static addCoordinationMatrix(t,s){t.addFieldOffset(2,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(3,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addItemsKeys(t,s){t.addFieldOffset(4,s,0)}static createItemsKeysVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysVector(t,s){t.startVector(4,s,4)}static addItemsKeysIndices(t,s){t.addFieldOffset(5,s,0)}static createItemsKeysIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysIndicesVector(t,s){t.startVector(4,s,4)}static addItemsRels(t,s){t.addFieldOffset(6,s,0)}static createItemsRelsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsVector(t,s){t.startVector(4,s,4)}static addItemsRelsIndices(t,s){t.addFieldOffset(7,s,0)}static createItemsRelsIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsIndicesVector(t,s){t.startVector(4,s,4)}static addFragmentKeys(t,s){t.addFieldOffset(8,s,0)}static addId(t,s){t.addFieldOffset(9,s,0)}static addName(t,s){t.addFieldOffset(10,s,0)}static addIfcName(t,s){t.addFieldOffset(11,s,0)}static addIfcDescription(t,s){t.addFieldOffset(12,s,0)}static addIfcSchema(t,s){t.addFieldOffset(13,s,0)}static addMaxExpressId(t,s){t.addFieldInt32(14,s,0)}static addBoundingBox(t,s){t.addFieldOffset(15,s,0)}static createBoundingBoxVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startBoundingBoxVector(t,s){t.startVector(4,s,4)}static addOpaqueGeometriesIds(t,s){t.addFieldOffset(16,s,0)}static createOpaqueGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startOpaqueGeometriesIdsVector(t,s){t.startVector(4,s,4)}static addTransparentGeometriesIds(t,s){t.addFieldOffset(17,s,0)}static createTransparentGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startTransparentGeometriesIdsVector(t,s){t.startVector(4,s,4)}static endFragmentsGroup(t){return t.endObject()}static finishFragmentsGroupBuffer(t,s){t.finish(s)}static finishSizePrefixedFragmentsGroupBuffer(t,s){t.finish(s,void 0,!0)}};class si{constructor(){T(this,"version",1);T(this,"fragmentIDSeparator","|")}import(t){const s=new Ce(t),e=Gs.getRootAsFragmentsGroup(s),n=this.constructFragmentGroup(e),o=e.itemsLength();for(let i=0;i<o;i++){const r=e.items(i);if(!r)continue;const c=this.constructGeometry(r),f=this.constructMaterials(r),l=r.capacity(),b=new Se(c,f,l);b.capacityOffset=r.capacityOffset(),this.setInstances(r,b),this.setID(r,b),n.items.push(b),n.add(b.mesh)}return n}export(t){const s=new Fe(1024),e=[],n=Gs,o=Zs;let i=null;if(t.civilData){const q=[],U=Le,z=Oe;for(const[at,pt]of t.civilData.alignments){const{absolute:Bt,horizontal:_t,vertical:It}=pt,vt=this.saveCivilCurves(_t,s),Vt=this.saveCivilCurves(It,s),Ct=this.saveCivilCurves(Bt,s),Ft=U.createHorizontalVector(s,vt),Mt=U.createVerticalVector(s,Vt),mt=U.createAbsoluteVector(s,Ct);U.startAlignment(s),U.addHorizontal(s,Ft),U.addVertical(s,Mt),U.addAbsolute(s,mt),U.addInitialPk(s,pt.initialKP);const Ht=U.endAlignment(s);q.push(Ht)}const O=z.createAlignmentsVector(s,q),j=z.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);z.startCivilData(s),z.addAlignments(s,O),z.addCoordinationMatrix(s,j),i=z.endCivilData(s)}for(const q of t.items){const U=q.exportData(),z=[];for(const Mt of q.ids){const mt=q.getInstancesIDs(Mt);if(!mt)throw new Error("Instances not found!");z.push(mt.size)}const O=o.createPositionVector(s,U.position),j=o.createNormalVector(s,U.normal),at=o.createIndexVector(s,U.index),pt=o.createGroupsVector(s,U.groups),Bt=o.createMaterialsVector(s,U.materials),_t=o.createMatricesVector(s,U.matrices),It=o.createColorsVector(s,U.colors),vt=o.createIdsVector(s,U.ids),Vt=o.createItemsSizeVector(s,z),Ct=s.createString(U.id);o.startFragment(s),o.addPosition(s,O),o.addNormal(s,j),o.addIndex(s,at),o.addGroups(s,pt),o.addMaterials(s,Bt),o.addMatrices(s,_t),o.addColors(s,It),o.addIds(s,vt),o.addItemsSize(s,Vt),o.addId(s,Ct),o.addCapacity(s,q.capacity),o.addCapacityOffset(s,q.capacityOffset);const Ft=Zs.endFragment(s);e.push(Ft)}const r=n.createItemsVector(s,e),c=n.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);let f="";for(const q of t.keyFragments.values())f.length&&(f+=this.fragmentIDSeparator),f+=q;const l=s.createString(f),b=[],h=[],u=[],p=[],w=[];let y=0,d=0;for(const[q,[U,z]]of t.data){b.push(y),u.push(d),w.push(q);for(const O of U)h.push(O);for(const O of z)p.push(O);y+=U.length,d+=z.length}const _=[],x=[];for(const[q,U]of t.geometryIDs.opaque)_.push(q,U);for(const[q,U]of t.geometryIDs.transparent)x.push(q,U);const m=s.createString(t.uuid),g=s.createString(t.name),I=s.createString(t.ifcMetadata.name),C=s.createString(t.ifcMetadata.description),A=s.createString(t.ifcMetadata.schema),F=n.createItemsKeysIndicesVector(s,b),v=n.createItemsKeysVector(s,h),P=n.createItemsRelsIndicesVector(s,u),V=n.createItemsRelsVector(s,p),M=n.createIdsVector(s,w),D=n.createOpaqueGeometriesIdsVector(s,_),B=n.createTransparentGeometriesIdsVector(s,x),{min:L,max:H}=t.boundingBox,Z=[L.x,L.y,L.z,H.x,H.y,H.z],Y=n.createBoundingBoxVector(s,Z);n.startFragmentsGroup(s),n.addId(s,m),n.addName(s,g),n.addIfcName(s,I),n.addIfcDescription(s,C),n.addIfcSchema(s,A),n.addMaxExpressId(s,t.ifcMetadata.maxExpressID),n.addItems(s,r),n.addFragmentKeys(s,l),n.addIds(s,M),n.addItemsKeysIndices(s,F),n.addItemsKeys(s,v),n.addItemsRelsIndices(s,P),n.addItemsRels(s,V),n.addCoordinationMatrix(s,c),n.addBoundingBox(s,Y),n.addOpaqueGeometriesIds(s,D),n.addTransparentGeometriesIds(s,B),i!==null&&n.addCivil(s,i);const Ms=Gs.endFragmentsGroup(s);return s.finish(Ms),s.asUint8Array()}setID(t,s){const e=t.id();e&&(s.id=e,s.mesh.uuid=e)}setInstances(t,s){const e=t.matricesArray(),n=t.colorsArray(),o=t.idsArray(),i=t.itemsSizeArray();if(!e||!o||!i)throw new Error("Error: Can't load empty fragment!");const r=[];let c=0;for(let f=0;f<i.length;f++){const l=o[f],b=i[f],h=[],u=[];for(let w=0;w<b;w++){const y=c*16,d=e.subarray(y,y+17),_=new G().fromArray(d);if(h.push(_),n){const x=c*3,[m,g,I]=n.subarray(x,x+4),C=new rt(m,g,I);u.push(C)}c++}const p=u.length?u:void 0;r.push({id:l,transforms:h,colors:p})}s.add(r)}constructMaterials(t){const s=t.materialsArray(),e=[];if(!s)return e;for(let n=0;n<s.length;n+=5){const o=s[n],i=!!s[n+1],r=s[n+2],c=s[n+3],f=s[n+4],l=new rt(r,c,f),b=new Ie({color:l,opacity:o,transparent:i});e.push(b)}return e}constructFragmentGroup(t){const s=new ns,e=t.civil();if(e){const A=e.coordinationMatrixArray(),F=new G;A&&F.fromArray(A),s.civilData={alignments:new Map,coordinationMatrix:F};const v=e.alignmentsLength();for(let P=0;P<v;P++){const V=new ve({color:16777215}),M=new ze,D=e.alignments(P);if(!D)throw new Error("Alignment not found!");const B=D.horizontalLength();M.horizontal=this.constructCivilCurves(D,M,"horizontal",B,V);const L=D.verticalLength();M.vertical=this.constructCivilCurves(D,M,"vertical",L,V);const H=D.horizontalLength();M.absolute=this.constructCivilCurves(D,M,"absolute",H,V),M.initialKP=D.initialPk(),s.civilData.alignments.set(P,M)}}s.uuid=t.id()||s.uuid,s.name=t.name()||"",s.ifcMetadata={name:t.ifcName()||"",description:t.ifcDescription()||"",schema:t.ifcSchema()||"IFC2X3",maxExpressID:t.maxExpressId()||0};const n=new G().elements,o=t.coordinationMatrixArray()||n,i=t.idsArray()||new Uint32Array,r=t.itemsKeysIndicesArray()||new Uint32Array,c=t.itemsKeysArray()||new Uint32Array,f=t.itemsRelsArray()||new Uint32Array,l=t.itemsRelsIndicesArray()||new Uint32Array,h=(t.fragmentKeys()||"").split(this.fragmentIDSeparator);this.setGroupData(s,i,r,c,0),this.setGroupData(s,i,l,f,1);const u=t.opaqueGeometriesIdsArray()||new Uint32Array,p=t.transparentGeometriesIdsArray()||new Uint32Array,w=new Map;for(let A=0;A<u.length-1;A+=2){const F=u[A],v=u[A+1];w.set(F,v)}const y=new Map;for(let A=0;A<p.length-1;A+=2){const F=p[A],v=p[A+1];y.set(F,v)}s.geometryIDs={opaque:w,transparent:y};const d=t.boundingBoxArray()||[0,0,0,0,0,0],[_,x,m,g,I,C]=d;s.boundingBox.min.set(_,x,m),s.boundingBox.max.set(g,I,C);for(let A=0;A<h.length;A++)s.keyFragments.set(A,h[A]);return o.length===16&&s.coordinationMatrix.fromArray(o),s}setGroupData(t,s,e,n,o){for(let i=0;i<e.length;i++){const r=s[i],c=e[i],f=e[i+1]||n.length,l=[];for(let h=c;h<f;h++)l.push(n[h]);t.data.has(r)||t.data.set(r,[[],[]]);const b=t.data.get(r);b&&(b[o]=l)}}constructGeometry(t){const s=t.positionArray()||new Float32Array,e=t.normalArray()||new Float32Array,n=t.indexArray(),o=t.groupsArray();if(!n)throw new Error("Index not found!");const i=new Is;if(i.setIndex(Array.from(n)),i.setAttribute("position",new wt(s,3)),i.setAttribute("normal",new wt(e,3)),o)for(let r=0;r<o.length;r+=3){const c=o[r],f=o[r+1],l=o[r+2];i.addGroup(c,f,l)}return i}constructCivilCurves(t,s,e,n,o){const i=[];for(let r=0;r<n;r++){const c=t[e](r);if(!c)throw new Error("Curve not found!");const f=c.pointsArray();if(f===null)throw new Error("Curve points not found!");let l={};const b=c.data();b&&(l=JSON.parse(b));const h=new Ve,u=new wt(f,3);h.setAttribute("position",u);const p=[];for(let y=0;y<f.length/3-1;y++)p.push(y,y+1);h.setIndex(p);const w=new Ue(r,l,s,h,o);i.push(w.curve)}return i}saveCivilCurves(t,s){const e=ws,n=[];for(const o of t){const r=o.mesh.geometry.attributes.position.array,c=e.createPointsVector(s,r),f=s.createString(JSON.stringify(o.data));e.startCivilCurve(s),e.addPoints(s,c),e.addData(s,f);const l=e.endCivilCurve(s);n.push(l)}return n}}let As=class Dt{constructor(){T(this,"bb",null);T(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilCurve(t,s){return(s||new Dt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilCurve(t,s){return t.setPosition(t.position()+ft),(s||new Dt).__init(t.readInt32(t.position())+t.position(),t)}points(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}data(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,t):null}static startCivilCurve(t){t.startObject(2)}static addPoints(t,s){t.addFieldOffset(0,s,0)}static createPointsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPointsVector(t,s){t.startVector(4,s,4)}static addData(t,s){t.addFieldOffset(1,s,0)}static endCivilCurve(t){return t.endObject()}static createCivilCurve(t,s,e){return Dt.startCivilCurve(t),Dt.addPoints(t,s),Dt.addData(t,e),Dt.endCivilCurve(t)}};class ot{constructor(){T(this,"bb",null);T(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsAlignment(t,s){return(s||new ot).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAlignment(t,s){return t.setPosition(t.position()+ft),(s||new ot).__init(t.readInt32(t.position())+t.position(),t)}vertical(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new As).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}verticalLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontal(t,s){const e=this.bb.__offset(this.bb_pos,6);return e?(s||new As).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}absolute(t,s){const e=this.bb.__offset(this.bb_pos,8);return e?(s||new As).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}absoluteLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}initialPk(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}static startAlignment(t){t.startObject(4)}static addVertical(t,s){t.addFieldOffset(0,s,0)}static createVerticalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startVerticalVector(t,s){t.startVector(4,s,4)}static addHorizontal(t,s){t.addFieldOffset(1,s,0)}static createHorizontalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startHorizontalVector(t,s){t.startVector(4,s,4)}static addAbsolute(t,s){t.addFieldOffset(2,s,0)}static createAbsoluteVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAbsoluteVector(t,s){t.startVector(4,s,4)}static addInitialPk(t,s){t.addFieldFloat32(3,s,0)}static endAlignment(t){return t.endObject()}static createAlignment(t,s,e,n,o){return ot.startAlignment(t),ot.addVertical(t,s),ot.addHorizontal(t,e),ot.addAbsolute(t,n),ot.addInitialPk(t,o),ot.endAlignment(t)}}class bt{constructor(){T(this,"bb",null);T(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilData(t,s){return(s||new bt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilData(t,s){return t.setPosition(t.position()+ft),(s||new bt).__init(t.readInt32(t.position())+t.position(),t)}alignments(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new ot).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startCivilData(t){t.startObject(2)}static addAlignments(t,s){t.addFieldOffset(0,s,0)}static createAlignmentsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAlignmentsVector(t,s){t.startVector(4,s,4)}static addCoordinationMatrix(t,s){t.addFieldOffset(1,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static endCivilData(t){return t.endObject()}static createCivilData(t,s,e){return bt.startCivilData(t),bt.addAlignments(t,s),bt.addCoordinationMatrix(t,e),bt.endCivilData(t)}}class k{constructor(){T(this,"bb",null);T(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragment(t,s){return(s||new k).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragment(t,s){return t.setPosition(t.position()+ft),(s||new k).__init(t.readInt32(t.position())+t.position(),t)}position(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}positionLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}normalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}indexLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}groups(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}groupsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}groupsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}materials(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}materialsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}matrices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}matricesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}matricesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}colors(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}colorsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}colorsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsSize(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsSizeLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsSizeArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,20);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}id(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}capacity(){const t=this.bb.__offset(this.bb_pos,24);return t?this.bb.readUint32(this.bb_pos+t):0}capacityOffset(){const t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readUint32(this.bb_pos+t):0}static startFragment(t){t.startObject(12)}static addPosition(t,s){t.addFieldOffset(0,s,0)}static createPositionVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPositionVector(t,s){t.startVector(4,s,4)}static addNormal(t,s){t.addFieldOffset(1,s,0)}static createNormalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startNormalVector(t,s){t.startVector(4,s,4)}static addIndex(t,s){t.addFieldOffset(2,s,0)}static createIndexVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIndexVector(t,s){t.startVector(4,s,4)}static addGroups(t,s){t.addFieldOffset(3,s,0)}static createGroupsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startGroupsVector(t,s){t.startVector(4,s,4)}static addMaterials(t,s){t.addFieldOffset(4,s,0)}static createMaterialsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMaterialsVector(t,s){t.startVector(4,s,4)}static addMatrices(t,s){t.addFieldOffset(5,s,0)}static createMatricesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMatricesVector(t,s){t.startVector(4,s,4)}static addColors(t,s){t.addFieldOffset(6,s,0)}static createColorsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startColorsVector(t,s){t.startVector(4,s,4)}static addItemsSize(t,s){t.addFieldOffset(7,s,0)}static createItemsSizeVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsSizeVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(8,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addId(t,s){t.addFieldOffset(9,s,0)}static addCapacity(t,s){t.addFieldInt32(10,s,0)}static addCapacityOffset(t,s){t.addFieldInt32(11,s,0)}static endFragment(t){return t.endObject()}static createFragment(t,s,e,n,o,i,r,c,f,l,b,h,u){return k.startFragment(t),k.addPosition(t,s),k.addNormal(t,e),k.addIndex(t,n),k.addGroups(t,o),k.addMaterials(t,i),k.addMatrices(t,r),k.addColors(t,c),k.addItemsSize(t,f),k.addIds(t,l),k.addId(t,b),k.addCapacity(t,h),k.addCapacityOffset(t,u),k.endFragment(t)}}let ks=class Js{constructor(){T(this,"bb",null);T(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragmentsGroup(t,s){return(s||new Js).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragmentsGroup(t,s){return t.setPosition(t.position()+ft),(s||new Js).__init(t.readInt32(t.position())+t.position(),t)}items(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new k).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}itemsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}civil(t){const s=this.bb.__offset(this.bb_pos,6);return s?(t||new bt).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeys(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeysIndices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysIndicesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysIndicesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRels(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRelsIndices(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsIndicesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsIndicesArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}fragmentKeys(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.__string(this.bb_pos+s,t):null}globalIds(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}id(t){const s=this.bb.__offset(this.bb_pos,24);return s?this.bb.__string(this.bb_pos+s,t):null}name(t){const s=this.bb.__offset(this.bb_pos,26);return s?this.bb.__string(this.bb_pos+s,t):null}ifcName(t){const s=this.bb.__offset(this.bb_pos,28);return s?this.bb.__string(this.bb_pos+s,t):null}ifcDescription(t){const s=this.bb.__offset(this.bb_pos,30);return s?this.bb.__string(this.bb_pos+s,t):null}ifcSchema(t){const s=this.bb.__offset(this.bb_pos,32);return s?this.bb.__string(this.bb_pos+s,t):null}maxExpressId(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.readUint32(this.bb_pos+t):0}boundingBox(t){const s=this.bb.__offset(this.bb_pos,36);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}boundingBoxLength(){const t=this.bb.__offset(this.bb_pos,36);return t?this.bb.__vector_len(this.bb_pos+t):0}boundingBoxArray(){const t=this.bb.__offset(this.bb_pos,36);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}opaqueGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,38);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}opaqueGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,38);return t?this.bb.__vector_len(this.bb_pos+t):0}opaqueGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,38);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transparentGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,40);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}transparentGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,40);return t?this.bb.__vector_len(this.bb_pos+t):0}transparentGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,40);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startFragmentsGroup(t){t.startObject(19)}static addItems(t,s){t.addFieldOffset(0,s,0)}static createItemsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startItemsVector(t,s){t.startVector(4,s,4)}static addCivil(t,s){t.addFieldOffset(1,s,0)}static addCoordinationMatrix(t,s){t.addFieldOffset(2,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(3,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addItemsKeys(t,s){t.addFieldOffset(4,s,0)}static createItemsKeysVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysVector(t,s){t.startVector(4,s,4)}static addItemsKeysIndices(t,s){t.addFieldOffset(5,s,0)}static createItemsKeysIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysIndicesVector(t,s){t.startVector(4,s,4)}static addItemsRels(t,s){t.addFieldOffset(6,s,0)}static createItemsRelsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsVector(t,s){t.startVector(4,s,4)}static addItemsRelsIndices(t,s){t.addFieldOffset(7,s,0)}static createItemsRelsIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsIndicesVector(t,s){t.startVector(4,s,4)}static addFragmentKeys(t,s){t.addFieldOffset(8,s,0)}static addGlobalIds(t,s){t.addFieldOffset(9,s,0)}static addId(t,s){t.addFieldOffset(10,s,0)}static addName(t,s){t.addFieldOffset(11,s,0)}static addIfcName(t,s){t.addFieldOffset(12,s,0)}static addIfcDescription(t,s){t.addFieldOffset(13,s,0)}static addIfcSchema(t,s){t.addFieldOffset(14,s,0)}static addMaxExpressId(t,s){t.addFieldInt32(15,s,0)}static addBoundingBox(t,s){t.addFieldOffset(16,s,0)}static createBoundingBoxVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startBoundingBoxVector(t,s){t.startVector(4,s,4)}static addOpaqueGeometriesIds(t,s){t.addFieldOffset(17,s,0)}static createOpaqueGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startOpaqueGeometriesIdsVector(t,s){t.startVector(4,s,4)}static addTransparentGeometriesIds(t,s){t.addFieldOffset(18,s,0)}static createTransparentGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startTransparentGeometriesIdsVector(t,s){t.startVector(4,s,4)}static endFragmentsGroup(t){return t.endObject()}static finishFragmentsGroupBuffer(t,s){t.finish(s)}static finishSizePrefixedFragmentsGroupBuffer(t,s){t.finish(s,void 0,!0)}};class ei{constructor(){T(this,"version",2);T(this,"separator","|")}import(t){const s=new Ce(t),e=ks.getRootAsFragmentsGroup(s),n=this.constructFragmentGroup(e),o=e.itemsLength();for(let i=0;i<o;i++){const r=e.items(i);if(!r)continue;const c=this.constructGeometry(r),f=this.constructMaterials(r),l=r.capacity(),b=new Se(c,f,l);b.capacityOffset=r.capacityOffset(),this.setInstances(r,b),this.setID(r,b),n.items.push(b),n.add(b.mesh)}return n}export(t){const s=new Fe(1024),e=[],n=ks,o=k;let i=null;if(t.civilData){const z=[],O=ot,j=bt;for(const[Bt,_t]of t.civilData.alignments){const{absolute:It,horizontal:vt,vertical:Vt}=_t,Ct=this.saveCivilCurves(vt,s),Ft=this.saveCivilCurves(Vt,s),Mt=this.saveCivilCurves(It,s),mt=O.createHorizontalVector(s,Ct),Ht=O.createVerticalVector(s,Ft),is=O.createAbsoluteVector(s,Mt);O.startAlignment(s),O.addHorizontal(s,mt),O.addVertical(s,Ht),O.addAbsolute(s,is),O.addInitialPk(s,_t.initialKP);const Re=O.endAlignment(s);z.push(Re)}const at=j.createAlignmentsVector(s,z),pt=j.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);j.startCivilData(s),j.addAlignments(s,at),j.addCoordinationMatrix(s,pt),i=j.endCivilData(s)}for(const z of t.items){const O=z.exportData(),j=[];for(const Ht of z.ids){const is=z.getInstancesIDs(Ht);if(!is)throw new Error("Instances not found!");j.push(is.size)}const at=o.createPositionVector(s,O.position),pt=o.createNormalVector(s,O.normal),Bt=o.createIndexVector(s,O.index),_t=o.createGroupsVector(s,O.groups),It=o.createMaterialsVector(s,O.materials),vt=o.createMatricesVector(s,O.matrices),Vt=o.createColorsVector(s,O.colors),Ct=o.createIdsVector(s,O.ids),Ft=o.createItemsSizeVector(s,j),Mt=s.createString(O.id);o.startFragment(s),o.addPosition(s,at),o.addNormal(s,pt),o.addIndex(s,Bt),o.addGroups(s,_t),o.addMaterials(s,It),o.addMatrices(s,vt),o.addColors(s,Vt),o.addIds(s,Ct),o.addItemsSize(s,Ft),o.addId(s,Mt),o.addCapacity(s,z.capacity),o.addCapacityOffset(s,z.capacityOffset);const mt=k.endFragment(s);e.push(mt)}const r=n.createItemsVector(s,e),c=n.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);let f="";for(const z of t.keyFragments.values())f.length&&(f+=this.separator),f+=z;let l="";for(const[z]of t.globalToExpressIDs)l.length&&(l+=this.separator),l+=z;const b=s.createString(f),h=s.createString(l),u=[],p=[],w=[],y=[],d=[];let _=0,x=0;for(const[z,[O,j]]of t.data){u.push(_),w.push(x),d.push(z);for(const at of O)p.push(at);for(const at of j)y.push(at);_+=O.length,x+=j.length}const m=[],g=[];for(const[z,O]of t.geometryIDs.opaque)m.push(z,O);for(const[z,O]of t.geometryIDs.transparent)g.push(z,O);const I=s.createString(t.uuid),C=s.createString(t.name),A=s.createString(t.ifcMetadata.name),F=s.createString(t.ifcMetadata.description),v=s.createString(t.ifcMetadata.schema),P=n.createItemsKeysIndicesVector(s,u),V=n.createItemsKeysVector(s,p),M=n.createItemsRelsIndicesVector(s,w),D=n.createItemsRelsVector(s,y),B=n.createIdsVector(s,d),L=n.createOpaqueGeometriesIdsVector(s,m),H=n.createTransparentGeometriesIdsVector(s,g),{min:Z,max:Y}=t.boundingBox,Ms=[Z.x,Z.y,Z.z,Y.x,Y.y,Y.z],q=n.createBoundingBoxVector(s,Ms);n.startFragmentsGroup(s),n.addId(s,I),n.addName(s,C),n.addIfcName(s,A),n.addIfcDescription(s,F),n.addIfcSchema(s,v),n.addMaxExpressId(s,t.ifcMetadata.maxExpressID),n.addItems(s,r),n.addFragmentKeys(s,b),n.addGlobalIds(s,h),n.addIds(s,B),n.addItemsKeysIndices(s,P),n.addItemsKeys(s,V),n.addItemsRelsIndices(s,M),n.addItemsRels(s,D),n.addCoordinationMatrix(s,c),n.addBoundingBox(s,q),n.addOpaqueGeometriesIds(s,L),n.addTransparentGeometriesIds(s,H),i!==null&&n.addCivil(s,i);const U=ks.endFragmentsGroup(s);return s.finish(U),s.asUint8Array()}setID(t,s){const e=t.id();e&&(s.id=e,s.mesh.uuid=e)}setInstances(t,s){const e=t.matricesArray(),n=t.colorsArray(),o=t.idsArray(),i=t.itemsSizeArray();if(!e||!o||!i)throw new Error("Error: Can't load empty fragment!");const r=[];let c=0;for(let f=0;f<i.length;f++){const l=o[f],b=i[f],h=[],u=[];for(let w=0;w<b;w++){const y=c*16,d=e.subarray(y,y+17),_=new G().fromArray(d);if(h.push(_),n){const x=c*3,[m,g,I]=n.subarray(x,x+4),C=new rt(m,g,I);u.push(C)}c++}const p=u.length?u:void 0;r.push({id:l,transforms:h,colors:p})}s.add(r)}constructMaterials(t){const s=t.materialsArray(),e=[];if(!s)return e;for(let n=0;n<s.length;n+=5){const o=s[n],i=!!s[n+1],r=s[n+2],c=s[n+3],f=s[n+4],l=new rt(r,c,f),b=new Ie({color:l,opacity:o,transparent:i});e.push(b)}return e}constructFragmentGroup(t){const s=new ns,e=t.civil();if(e){const v=e.coordinationMatrixArray(),P=new G;v&&P.fromArray(v),s.civilData={alignments:new Map,coordinationMatrix:P};const V=e.alignmentsLength();for(let M=0;M<V;M++){const D=new ve({color:16777215}),B=new ze,L=e.alignments(M);if(!L)throw new Error("Alignment not found!");const H=L.horizontalLength();B.horizontal=this.constructCivilCurves(L,B,"horizontal",H,D);const Z=L.verticalLength();B.vertical=this.constructCivilCurves(L,B,"vertical",Z,D);const Y=L.horizontalLength();B.absolute=this.constructCivilCurves(L,B,"absolute",Y,D),B.initialKP=L.initialPk(),s.civilData.alignments.set(M,B)}}s.uuid=t.id()||s.uuid,s.name=t.name()||"",s.ifcMetadata={name:t.ifcName()||"",description:t.ifcDescription()||"",schema:t.ifcSchema()||"IFC2X3",maxExpressID:t.maxExpressId()||0};const n=new G().elements,o=t.coordinationMatrixArray()||n,i=t.idsArray()||new Uint32Array,r=t.itemsKeysIndicesArray()||new Uint32Array,c=t.itemsKeysArray()||new Uint32Array,f=t.itemsRelsArray()||new Uint32Array,l=t.itemsRelsIndicesArray()||new Uint32Array,h=(t.fragmentKeys()||"").split(this.separator),p=(t.globalIds()||"").split(this.separator);this.setGroupData(s,i,r,c,0),this.setGroupData(s,i,l,f,1);const w=t.opaqueGeometriesIdsArray()||new Uint32Array,y=t.transparentGeometriesIdsArray()||new Uint32Array,d=new Map;for(let v=0;v<w.length-1;v+=2){const P=w[v],V=w[v+1];d.set(P,V)}const _=new Map;for(let v=0;v<y.length-1;v+=2){const P=y[v],V=y[v+1];_.set(P,V)}s.geometryIDs={opaque:d,transparent:_};const x=t.boundingBoxArray()||[0,0,0,0,0,0],[m,g,I,C,A,F]=x;s.boundingBox.min.set(m,g,I),s.boundingBox.max.set(C,A,F);for(let v=0;v<h.length;v++)s.keyFragments.set(v,h[v]);o.length===16&&s.coordinationMatrix.fromArray(o);for(let v=0;v<i.length;v++)s.globalToExpressIDs.set(p[v],i[v]);return s}setGroupData(t,s,e,n,o){for(let i=0;i<e.length;i++){const r=s[i],c=e[i],f=e[i+1],l=f===void 0?n.length:f,b=[];for(let u=c;u<l;u++)b.push(n[u]);t.data.has(r)||t.data.set(r,[[],[]]);const h=t.data.get(r);h&&(h[o]=b)}}constructGeometry(t){const s=t.positionArray()||new Float32Array,e=t.normalArray()||new Float32Array,n=t.indexArray(),o=t.groupsArray();if(!n)throw new Error("Index not found!");const i=new Is;if(i.setIndex(Array.from(n)),i.setAttribute("position",new wt(s,3)),i.setAttribute("normal",new wt(e,3)),o)for(let r=0;r<o.length;r+=3){const c=o[r],f=o[r+1],l=o[r+2];i.addGroup(c,f,l)}return i}constructCivilCurves(t,s,e,n,o){const i=[];for(let r=0;r<n;r++){const c=t[e](r);if(!c)throw new Error("Curve not found!");const f=c.pointsArray();if(f===null)throw new Error("Curve points not found!");let l={};const b=c.data();b&&(l=JSON.parse(b));const h=new Ve,u=new wt(f,3);h.setAttribute("position",u);const p=[];for(let y=0;y<f.length/3-1;y++)p.push(y,y+1);h.setIndex(p);const w=new Ue(r,l,s,h,o);i.push(w.curve)}return i}saveCivilCurves(t,s){const e=As,n=[];for(const o of t){const r=o.mesh.geometry.attributes.position.array,c=e.createPointsVector(s,r),f=s.createString(JSON.stringify(o.data));e.startCivilCurve(s),e.addPoints(s,c),e.addData(s,f);const l=e.endCivilCurve(s);n.push(l)}return n}}class ni{constructor(){T(this,"parsers",[new ei,new si]);T(this,"version","auto")}import(t){const s=this.parsers.length;if(this.version==="auto"){for(let i=0;i<this.parsers.length;i++){const c=this.parsers[i].import(t);if(Object.keys(c).length!==0){if(i!==0){const f=this.parsers.length-i;this.warnVersion(f,s)}return c}}throw new Error("No valid parser found for this file")}this.checkCurrentVersionValid(this.version);const e=this.parsers.length-this.version,o=this.parsers[e].import(t);if(Object.keys(o).length===0)throw new Error(`The given version ${this.version} doesn't match to the given file. Try using "auto" in the version property to handle versions automatically.`);return o}export(t){if(this.version==="auto")return this.parsers[0].export(t);this.checkCurrentVersionValid(this.version);const s=this.parsers.length-this.version;return this.parsers[s].export(t)}checkCurrentVersionValid(t){if(this.version==="auto")return;if(this.version!==t&&this.warnVersion(this.version,t),!Number.isInteger(this.version))throw new Error("Invalid version. Non-automatic versions must an integer.");if(this.version<1||this.version>t)throw new Error(`Invalid version. Versions range from 1 to ${t}.`)}warnVersion(t,s){console.warn(`This fragment file version is ${t}. The latest version is ${s}. To avoid issues, please consider updating your fragments. You can do so by regenerating your fragments from the original IFC file.`)}}class ii{constructor(t){T(this,"baseDirectory");T(this,"maxDeadTime",6e4);T(this,"mode","buffer");T(this,"_memoryCleanTime",1e4);T(this,"_intervalID",null);T(this,"_isCleaningMemory",!1);T(this,"cleanMemory",async()=>{if(this._isCleaningMemory)return;this._isCleaningMemory=!0;const t=await this.getDir(this.baseDirectory),s=new Set,e=new Date().getTime();for await(const n of t.values()){const o=localStorage.getItem(n.name)||"0",i=parseInt(o,10);e-i>this.maxDeadTime&&(s.add(n.name),localStorage.removeItem(n.name))}for(const n of s)t.removeEntry(n);this._isCleaningMemory=!1});this.baseDirectory=t,this.setupMemoryCleanup()}get memoryCleanTime(){return this._memoryCleanTime}set memoryCleanTime(t){this._memoryCleanTime=t,this.dispose(),this.setupMemoryCleanup()}isCached(t){const s=this.encodeName(t);return localStorage.getItem(s)!==null}async get(t){const s=this.encodeName(t),e=await this.getDir(this.baseDirectory);try{const o=await(await e.getFileHandle(s)).getFile();return this.updateLastAccessTime(s),o}catch{return null}}async add(t,s){const e=this.encodeName(t),i=await(await(await this.getDir(this.baseDirectory)).getFileHandle(e,{create:!0})).createWritable();await i.write(s),await i.close(),this.updateLastAccessTime(e)}async clear(){const t=await this.getDir(this.baseDirectory);for await(const[s]of t.entries())await t.removeEntry(s)}dispose(){this._intervalID!==null&&window.clearInterval(this._intervalID)}setupMemoryCleanup(){this._intervalID=window.setInterval(this.cleanMemory,this.memoryCleanTime)}async getDir(t){return(await navigator.storage.getDirectory()).getDirectoryHandle(t,{create:!0})}encodeName(t){const s=/[\\/:*?"<>|]/g;return t.replace(s,"")}updateLastAccessTime(t){const s=new Date().getTime().toString();localStorage.setItem(t,s)}}const K=class K extends He{constructor(){super(...arguments);T(this,"items",[]);T(this,"boundingBox",new nt);T(this,"coordinationMatrix",new G);T(this,"keyFragments",new Map);T(this,"globalToExpressIDs",new Map);T(this,"data",new Map);T(this,"geometryIDs",{opaque:new Map,transparent:new Map});T(this,"ifcMetadata",{name:"",description:"",schema:"IFC2X3",maxExpressID:0});T(this,"civilData");T(this,"streamSettings",{baseFileName:"",ids:new Map,types:new Map});T(this,"isStreamed",!1);T(this,"_properties")}get hasProperties(){const s=this._properties!==void 0,e=this.streamSettings.ids.size!==0;return s||e}getFragmentMap(s=this.data.keys()){const e={};for(const n of s){const o=this.data.get(n);if(o)for(const i of o[0]){const r=this.keyFragments.get(i);r!==void 0&&(e[r]||(e[r]=new Set),e[r].add(n))}}return e}getItemVertices(s){const e=[],n=this.getFragmentMap([s]);for(const o in n){const i=this.items.find(c=>c.id===o);if(!i)continue;const r=i.getInstancesIDs(s);if(r)for(const c of r){const f=new G;i.mesh.getMatrixAt(c,f);for(const l of i.uniqueVertices){const b=l.clone().applyMatrix4(f);e.push(b)}}}return e}static setPropertiesDB(s){s?K.propertiesDB||(K.propertiesDB=new ii("that-open-company-streaming-properties")):s||K.propertiesDB&&K.propertiesDB.dispose()}dispose(s=!0){for(const e of this.items)e.dispose(s);if(this.coordinationMatrix=new G,this.keyFragments.clear(),this.data.clear(),this._properties={},this.removeFromParent(),this.items=[],this.civilData){const{alignments:e}=this.civilData;for(const[n,o]of e)this.disposeAlignment(o.vertical),this.disposeAlignment(o.horizontal),this.disposeAlignment(o.absolute)}this.civilData=void 0}setLocalProperties(s){this._properties=s}getLocalProperties(){return this._properties}getAllPropertiesIDs(){return this._properties?Object.keys(this._properties).map(s=>parseInt(s,10)):Array.from(this.streamSettings.ids.keys())}getAllPropertiesTypes(){if(this._properties){const s=new Set;for(const e in this._properties){const n=this._properties[e];n.type!==void 0&&s.add(n.type)}return Array.from(s)}return Array.from(this.streamSettings.types.keys())}async getProperties(s){if(this._properties)return this._properties[s]||null;const e=this.getPropsURL(s),n=await this.getPropertiesData(e);return n?n[s]:null}async setProperties(s,e){if(this._properties){e!==null?this._properties[s]=e:delete this._properties[s];return}throw new Error("Writing streamed properties not supported yet!")}async getAllPropertiesOfType(s){if(this._properties){const i={};let r=!1;for(const c in this._properties){const f=this._properties[c];f.type===s&&(i[f.expressID]=f,r=!0)}return r?i:null}const{types:e}=this.streamSettings,n=e.get(s);if(n===void 0)return null;const o={};for(const i of n){const r=this.constructFileName(i),c=await this.getPropertiesData(r);for(const f in c)o[parseInt(f,10)]=c[f]}return o}clone(s){throw new Error("Use FragmentsGroup.cloneGroup instead!")}cloneGroup(s){const e=new K;e.coordinationMatrix=this.coordinationMatrix,e.position.copy(this.position),e.rotation.copy(this.rotation),e.scale.copy(this.scale),e.updateMatrix(),e.ifcMetadata={...this.ifcMetadata},s||(s=this.getFragmentMap(this.data.keys()));const n=new Set,o=new Map;for(const i of this.items){if(!s[i.id])continue;const r=s[i.id],c=i.clone(r);o.set(i.id,c.id),e.items.push(c),e.add(c.mesh);for(const f of r)n.add(f)}for(const i of n){const r=this.data.get(i);r&&e.data.set(i,r)}for(const[i,r]of this.keyFragments)if(o.has(r)){const c=o.get(r);if(c===void 0)throw new Error("Malformed fragment ID map during clone!");e.keyFragments.set(i,c)}for(const[i,r]of this.globalToExpressIDs)n.has(r)&&e.globalToExpressIDs.set(i,r);return this.civilData&&(e.civilData={coordinationMatrix:this.coordinationMatrix,alignments:new Map}),e}getPropsURL(s){const{ids:e}=this.streamSettings,n=e.get(s);if(n===void 0)throw new Error("ID not found");return this.constructFileName(n)}async getPropertiesData(s){var n;(n=this.streamSettings.baseUrl)!=null&&n.length&&(console.warn("streamSettings.baseUrl is deprecated. Use FragmentsGroup.url instead."),K.url=this.streamSettings.baseUrl);let e;{let o=null;if(K.propertiesDB&&(o=await K.propertiesDB.get(s)),o)e=await o.text();else if(e=await(await K.fetch(s)).text(),K.propertiesDB){const c=new TextEncoder().encode(e);await K.propertiesDB.add(s,c)}}return JSON.parse(e)}constructFileName(s){const{baseFileName:e}=this.streamSettings;return`${e}-${s}`}disposeAlignment(s){for(const e of s)if(e.mesh.geometry.dispose(),Array.isArray(e.mesh.material))for(const n of e.mesh.material)n.dispose();else e.mesh.material.dispose();s.length=0}};T(K,"fetch",async s=>fetch(`${K.url}${s}`)),T(K,"constructFileName",null),T(K,"url",""),T(K,"useCache",!0),T(K,"propertiesDB",null);let ns=K;class ze{constructor(){T(this,"vertical",[]);T(this,"horizontal",[]);T(this,"absolute",[]);T(this,"initialKP",0)}getLength(t){let s=0;for(const e of this[t])s+=e.getLength();return s}getPointAt(t,s){const e=this.getCurveAt(t,s);return e.curve.getPointAt(e.percentage)}getPercentageAt(t,s,e=.01){const n=this[s];let o=0;for(const i of n){const r=i.getPercentageAt(t,e),c=i.getLength();if(r!==null){const f=o+r*c,l=this.getLength(s);return f/l}o+=c}return null}getCurveAt(t,s){t<0?t=0:t>1&&(t=1);const e=this[s],o=this.getLength(s)*t;let i=0;for(const r of e){const c=r.getLength();if(i+c>=o){const l=(o-i)/c;return{curve:r,percentage:l}}i+=c}throw new Error("Could not compute point!")}}class oi{constructor(t,s,e,n){T(this,"index");T(this,"mesh");T(this,"data");T(this,"alignment");this.index=t,this.mesh=s,this.data=e,this.alignment=n}get _index(){return this.mesh.geometry.index}get _pos(){return this.mesh.geometry.attributes.position.array}getLength(){let t=0;for(let s=0;s<this._index.array.length-1;s+=2){const{startPoint:e,endPoint:n}=this.getSegment(s);t+=e.distanceTo(n)}return t}getPointAt(t){const{startPoint:s,endPoint:e,distanceToStart:n}=this.getSegmentAt(t),o=e.clone();return o.sub(s),o.normalize(),o.multiplyScalar(n),o.add(s),o}getSegmentAt(t){t<0?t=0:t>1&&(t=1);const e=this.getLength()*t;let n=0;for(let o=0;o<this._index.array.length-1;o+=2){const{startPoint:i,endPoint:r}=this.getSegment(o),c=i.distanceTo(r);if(n+c>=e)return{distanceToStart:e-n,index:o,startPoint:i,endPoint:r};n+=c}throw new Error("Could not compute point")}getPercentageAt(t,s=.01){let e=0;for(let n=0;n<this._index.array.length-1;n+=2){const{startPoint:o,endPoint:i}=this.getSegment(n),r=o.distanceTo(i),c=t.distanceTo(o),f=t.distanceTo(i);if(c+f-r<=s){const h=e+c,u=this.getLength();return h/u}e+=r}return null}getSegment(t){const s=this._index.array[t]*3,e=this._index.array[t+1]*3,n=new S(this._pos[s],this._pos[s+1],this._pos[s+2]),o=new S(this._pos[e],this._pos[e+1],this._pos[e+2]);return{startPoint:n,endPoint:o}}}class Ue extends Xe{constructor(s,e,n,o,i){super(o,i);T(this,"curve");this.curve=new oi(s,this,e,n)}}const Ee=new ni,St=new ns;St.globalToExpressIDs.set("a",11);St.globalToExpressIDs.set("b",12);St.globalToExpressIDs.set("c",13);St.data.set(11,[[],[]]);St.data.set(12,[[],[]]);St.data.set(13,[[],[]]);Ee.export(St);const ri=await fetch("../../../../resources/small_v2.frag"),ci=await ri.arrayBuffer(),ai=new Uint8Array(ci),fi=Ee.import(ai);console.log(fi);
