var he=Object.defineProperty;var ue=(m,t,e)=>t in m?he(m,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):m[t]=e;var o=(m,t,e)=>(ue(m,typeof t!="symbol"?t+"":t,e),e);import{fo as Xt,V as _,fJ as ot,c as Q,g5 as Z,cD as Et,cw as it,g6 as $,cy as Yt,g7 as ht,g8 as Gt,g9 as Qt,f$ as Ut,ga as At,gb as rt,gc as fe,gd as bt,ge as Zt,gf as wt,gg as Kt,gh as _t,fH as X,gi as ft,gj as pe,gk as Nt,gl as J,cp as at,gm as me,fB as ut,fy as Y,gn as W,go as ge,fX as ye,gp as Jt,gq as we,gr as N,fI as Ct,fN as te,gs as xt,gt as It,fE as ee,fx as se,gu as _e,fz as Dt,fO as M,gv as Ie,fK as ve,cr as Me,gw as be,gx as L}from"./virtual-memory-controller-uf_sHEwD.js";class H{constructor(){o(this,"enabled",!0);o(this,"trigger",t=>{if(!this.enabled)return;const e=this.handlers.slice(0);for(const s of e)s(t)});o(this,"handlers",[])}add(t){this.handlers.push(t)}remove(t){this.handlers=this.handlers.filter(e=>e!==t)}reset(){this.handlers.length=0}}class Bt extends Map{constructor(e){super(e);o(this,"onBeforeSet",new H);o(this,"onItemSet",new H);o(this,"onItemUpdated",new H);o(this,"onBeforeDelete",new H);o(this,"onItemDeleted",new H);o(this,"onCleared",new H);o(this,"guard",()=>!0);o(this,"deleteGuard",()=>!0);o(this,"updateGuard",()=>!0)}set eventsEnabled(e){this.onItemSet.enabled=e,this.onItemUpdated.enabled=e,this.onItemDeleted.enabled=e,this.onBeforeDelete.enabled=e,this.onCleared.enabled=e}clear(){for(const[e,s]of this)this.onBeforeDelete.trigger({key:e,value:s});super.clear(),this.onCleared.trigger()}set(e,s){const n=this.has(e);if(!(this.guard??(()=>!0))(e,s))return this;n||this.onBeforeSet.trigger({key:e,value:s});const a=super.set(e,s);return n?(this.onItemUpdated||(this.onItemUpdated=new H),this.onItemUpdated.trigger({key:e,value:s})):(this.onItemSet||(this.onItemSet=new H),this.onItemSet.trigger({key:e,value:s})),a}delete(e){const s=this.get(e);if(!s||!this.deleteGuard(e,s))return!1;this.onBeforeDelete.trigger({key:e,value:s});const n=super.delete(e);return n&&this.onItemDeleted.trigger(e),n}getKey(e){for(const[s,n]of this)if(n===e)return s}add(e){const s=Xt.generateUUID().toLowerCase();return this.set(s,e),s}update(e){const s=this.getKey(e);s&&this.updateGuard(s,e)&&this.set(s,e)}deleteIf(e){for(const[s,n]of this)e(n,s)&&this.delete(s)}replaceKey(e,s,n=!1){const i=this.get(e);return!i||this.get(s)&&!n?!1:(this.eventsEnabled=!1,this.delete(e),this.eventsEnabled=!0,this.set(s,i),!0)}dispose(){this.clear(),this.onItemSet.reset(),this.onItemDeleted.reset(),this.onItemUpdated.reset(),this.onCleared.reset(),this.onBeforeDelete.reset()}}class xe{constructor(t,e,s,n){o(this,"x");o(this,"y");o(this,"z");o(this,"hash");o(this,"id");this.x=R.round(t[e*3],n),this.y=R.round(t[e*3+1],n),this.z=R.round(t[e*3+2],n),this.hash=`${this.x}/${this.y}/${this.z}`,this.id=s}}class Ee{constructor(t){o(this,"list",new Map);o(this,"tempV1",new _);o(this,"tempV2",new _);o(this,"tempV3",new _);o(this,"precission");this.precission=t}create(t,e){const s=new xe(t,e,this.list.size,this.precission);return this.list.has(s.hash)||this.list.set(s.hash,s),this.list.get(s.hash)}get(){return Array.from(this.list.values()).map(t=>[t.x,t.y,t.z])}isValidTriangle(t,e,s,n){this.tempV1.set(t[e*3],t[e*3+1],t[e*3+2]),this.tempV2.set(t[s*3],t[s*3+1],t[s*3+2]),this.tempV3.set(t[n*3],t[n*3+1],t[n*3+2]);const i=1/this.precission*10,r=this.tempV1.distanceTo(this.tempV2)>i,a=this.tempV1.distanceTo(this.tempV3)>i,c=this.tempV2.distanceTo(this.tempV3)>i;return r&&a&&c}}class Se{constructor(t,e){o(this,"edges",new Map);o(this,"openEdges",new Set);o(this,"id");o(this,"plane");this.id=t,this.plane=e}add(t){if(this.edges.size===0){for(const e of t)this.openEdges.add(e.hash),this.edges.set(e.hash,e);return}for(const e of t)this.openEdges.has(e.hash)?this.openEdges.delete(e.hash):this.openEdges.add(e.hash),this.edges.set(e.hash,e)}match(t,e){if(e.id!==this.plane.id)return!1;for(const s of t)if(this.openEdges.has(s.hash))return!0;return!1}getOpenEdges(){const t=[];for(const e of this.openEdges)t.push(this.edges.get(e));return t}merge(t){for(const[e,s]of t.edges)this.edges.set(e,s);for(const e of t.openEdges)this.openEdges.has(e)?this.openEdges.delete(e):this.openEdges.add(e)}}class Te{constructor(){o(this,"list",new Map);o(this,"nextFaceID",0)}add(t,e){const s=this.match(t,e);if(s.length===0){const n=this.nextFaceID++,i=new Se(n,e);i.add(t),this.list.set(i.id,i);return}if(s.length===1){this.list.get(s[0]).add(t);return}if(s.length>1){const n=this.list.get(s[0]);n.add(t);for(let i=1;i<s.length;i++){const r=s[i],a=this.list.get(r);n.merge(a),this.list.delete(r)}}}match(t,e){let s=[];for(const n of this.list.values())n.match(t,e)&&s.push(n.id);return s}}class lt{constructor(t,e){o(this,"p1");o(this,"p2");o(this,"hash");this.p1=t,this.p2=e;const s=[this.p1,this.p2];s.sort((n,i)=>n.x-i.x||n.y-i.y||n.z-i.z),this.hash=`${s[0].hash}_${s[1].hash}`}}class Re{constructor(t){o(this,"closed",!1);o(this,"openStartPoint",null);o(this,"openEndPoint",null);o(this,"plane");o(this,"orderedPoints",[]);this.plane=t}getEdges(t=!1){const e=[];if(t)for(let s=this.orderedPoints.length-1;s>0;s--)e.push(new lt(this.orderedPoints[s],this.orderedPoints[s-1]));else for(let s=0;s<this.orderedPoints.length-1;s++)e.push(new lt(this.orderedPoints[s],this.orderedPoints[s+1]));return e}getIndices(){return this.orderedPoints.map(t=>t.id)}add(t){if(this.orderedPoints.length===0){this.openStartPoint=t.p1.hash,this.openEndPoint=t.p2.hash,this.orderedPoints.push(t.p1,t.p2);return}const e=this.match(t);if(e===0)throw new Error("Fragments: Edge doesn't match with any open point");if(e>2)throw new Error("Fragments: Edge matches with more than 2 open points");if(e===2){this.closed=!0,this.openEndPoint=null,this.openStartPoint=null;return}this.openStartPoint===t.p1.hash?(this.orderedPoints.unshift(t.p2),this.openStartPoint=t.p2.hash):this.openEndPoint===t.p1.hash?(this.orderedPoints.push(t.p2),this.openEndPoint=t.p2.hash):this.openStartPoint===t.p2.hash?(this.orderedPoints.unshift(t.p1),this.openStartPoint=t.p1.hash):this.openEndPoint===t.p2.hash&&(this.orderedPoints.push(t.p1),this.openEndPoint=t.p1.hash)}match(t){if(this.closed)return 0;let e=0;return this.openStartPoint===t.p1.hash&&e++,this.openStartPoint===t.p2.hash&&e++,this.openEndPoint===t.p1.hash&&e++,this.openEndPoint===t.p2.hash&&e++,e}merge(t){if(t.closed||this.closed)throw new Error("Fragments: Cannot merge closed profiles");if(t.openStartPoint===this.openEndPoint&&t.openEndPoint===this.openStartPoint)throw new Error("Fragments: Cannot merge profiles that close each other");if(t.openEndPoint===this.openEndPoint&&t.openStartPoint===this.openStartPoint)throw new Error("Fragments: Cannot merge profiles that close each other");let e=!1;(t.openEndPoint===this.openStartPoint||t.openEndPoint===this.openEndPoint)&&(e=!0);const s=t.getEdges(e);for(const n of s)this.add(n)}getArea(){const t=this.orderedPoints.map(h=>[h.x,h.y,h.z]);let e=0,s=1;const n=Math.abs(this.plane.normal.x),i=Math.abs(this.plane.normal.y),r=Math.abs(this.plane.normal.z);n>=i&&n>=r?(e=1,s=2):i>=n&&i>=r?(e=0,s=2):(e=0,s=1);const a=[];for(const h of t)a.push(new ot(h[e],h[s]));let c=0;for(let h=0,u=a.length;h<u;h++){const l=a[h].x,f=a[h===a.length-1?0:h+1].y,p=a[h===a.length-1?0:h+1].x,d=a[h].y;c+=l*f*.5,c-=p*d*.5}return Math.abs(c)}}class Ae{constructor(t){o(this,"list",new Map);o(this,"plane");o(this,"nextProfileID",0);this.plane=t}add(t){const e=this.match(t);if(e.length===0){const s=this.nextProfileID++,n=new Re(this.plane);n.add(t),this.list.set(s,n);return}if(e.length===1){this.list.get(e[0]).add(t);return}if(e.length>1){const s=this.list.get(e[0]);s.add(t);const n=this.list.get(e[1]);s.merge(n),this.list.delete(e[1])}}getProfiles(){let t=null,e=0;for(const[i,r]of this.list){const a=r.getArea();a>e&&(e=a,t=i)}if(t===null)return null;const s=this.list.get(t).getIndices(),n=[];for(const[i,r]of this.list)i!==t&&n.push(r.getIndices());return{profile:s,holes:n}}match(t){const e=[];for(const[s,n]of this.list)n.match(t)>0&&e.push(s);return e}}class Ce{constructor(t,e,s){o(this,"normal");o(this,"constant");o(this,"id");o(this,"faces",[]);const n=R.round(t.normal.x,s),i=R.round(t.normal.y,s),r=R.round(t.normal.z,s),a=R.round(t.constant,e);this.normal=new _(n,i,r),this.constant=a;const c="||";this.id=`${n}${c}${i}${c}${r}${c}${a}`}}const ct=class ct{static round(t,e){return Math.round(t*e)/e}static getAABB(t){let e=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,n=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,r=Number.NEGATIVE_INFINITY,a=Number.NEGATIVE_INFINITY;for(let c=0;c<t.length;c+=3){const h=t[c],u=t[c+1],l=t[c+2];h<e&&(e=h),u<s&&(s=u),l<n&&(n=l),h>i&&(i=h),u>r&&(r=u),l>a&&(a=l)}return{min:{x:e,y:s,z:n},max:{x:i,y:r,z:a}}}static transformFromMatrix(t,e={position:[0,0,0],xDirection:[1,0,0],yDirection:[0,1,0]}){const s=t.elements[12],n=t.elements[13],i=t.elements[14],r=t.elements[0],a=t.elements[1],c=t.elements[2],h=t.elements[4],u=t.elements[5],l=t.elements[6];return e.position[0]=s,e.position[1]=n,e.position[2]=i,e.xDirection[0]=r,e.xDirection[1]=a,e.xDirection[2]=c,e.yDirection[0]=h,e.yDirection[1]=u,e.yDirection[2]=l,e}static matrixFromTransform(t){const e=new Q,[s,n,i]=t.position,[r,a,c]=t.xDirection,[h,u,l]=t.yDirection,f=new _(r,a,c),p=new _(h,u,l),{x:d,y:g,z:y}=f.cross(p);return e.fromArray([r,a,c,0,h,u,l,0,d,g,y,0,s,n,i,1]),e}static bboxFromCircleExtrusion(t){const e=new Z,s=[];for(const u of t.axes)for(const l of u.wires)for(let f=0;f<l.length-2;f+=3){const p=l[f],d=l[f+1],g=l[f+2];s.push(new _(p,d,g))}e.setFromPoints(s);const n=e.min.x,i=e.min.y,r=e.min.z,a=e.max.x,c=e.max.y,h=e.max.z;return[n,i,r,a,c,h]}static representationFromGeometry(t,e={bbox:[0,0,0,0,0,0],representationClass:it.SHELL,geometry:{points:[],type:Et.NONE,profiles:new Map,holes:new Map,bigHoles:new Map,bigProfiles:new Map,profilesFaceIds:[]}},s={threshold:3e3,precision:1e6,normalPrecision:1e7,planePrecision:1e3,faceThreshold:.6,forceTransparentSpaces:!0}){const i=t.getAttribute("position").array,a=t.getAttribute("normal").array,h=t.index.array,u=ct.getShellData({position:i,normals:a,index:h,raw:!1,settings:s}),{min:l,max:f}=u.bbox;if(e.bbox=[l.x,l.y,l.z,f.x,f.y,f.z],e.representationClass===it.CIRCLE_EXTRUSION)throw new Error("Circle extrusions can't be represented as shells");const p=e.geometry,d=u.points,g=d.length>ct.ushortMaxValue;return p.type=g?Et.BIG:Et.NONE,p.points=d,p.profilesFaceIds=u.profilesFaceIds,g?(p.profiles=new Map,p.holes=new Map,p.bigHoles=u.holes,p.bigProfiles=u.profiles):(p.profiles=u.profiles,p.holes=u.holes,p.bigHoles=new Map,p.bigProfiles=new Map),e}static getRawShellData(t,e,s,n,i){var l;const r=new Map,a=new Map,c=(f,p,d)=>{const g=`${f},${p},${d}`;if(r.has(g))return r.get(g)[0];const y=r.size;return r.set(g,[y,f,p,d]),y};for(let f=0;f<t.length-2;f+=3){const p=t[f],d=t[f+1],g=t[f+2],y=e[p*3],E=e[p*3+1],w=e[p*3+2],I=e[d*3],v=e[d*3+1],q=e[d*3+2],x=e[g*3],O=e[g*3+1],S=e[g*3+2],B=c(y,E,w),A=c(I,v,q),U=c(x,O,S);a.set(a.size,[B,A,U])}const h=[];for(const[,[,f,p,d]]of r)h.push([f,p,d]);const u={bbox:s,type:it.SHELL,profiles:a,holes:new Map,points:h,profilesFaceIds:[]};if(i&&((l=n.categoryFaceThresholds)!=null&&l.has(i)))this.computeShellFaceIds(u,n,i);else for(let f=0;f<a.size;f++)u.profilesFaceIds.push(0);return u}static getShellData(t){const{position:e,normals:s,index:n,raw:i,settings:r,category:a}=t,{threshold:c,precision:h,normalPrecision:u,planePrecision:l}=r,p=e.length/3>c,d=this.getAABB(e);if(d.min.x===0&&d.min.y===0&&d.min.z===0&&d.max.x===0&&d.max.y===0&&d.max.z===0)throw new Error("Fragments: Bbox is not valid");if(i||p)return this.getRawShellData(n,e,d,r,a);const g=new $,y=new _,E=new _,w=new Map;for(let T=0;T<n.length-2;T+=3){const b=n[T];y.set(s[b*3],s[b*3+1],s[b*3+2]),E.set(e[b*3],e[b*3+1],e[b*3+2]),g.setFromNormalAndCoplanarPoint(y,E);const z=new Ce(g,l,u);w.has(z.id)||w.set(z.id,z),w.get(z.id).faces.push(T)}const I=new Ee(h),v=new Te;for(const[,T]of w)for(const b of T.faces){const z=n[b],G=n[b+1],nt=n[b+2];if(!I.isValidTriangle(e,z,G,nt))continue;const pt=I.create(e,z),Ft=I.create(e,G),Ot=I.create(e,nt),oe=new lt(pt,Ft),le=new lt(Ft,Ot),ce=new lt(Ot,pt),de=[oe,le,ce];v.add(de,T)}const q=new Map,x=new Map;let O=0;for(const[,T]of v.list){const b=new Ae(T.plane),z=T.getOpenEdges();if(z.length===0)return this.getRawShellData(n,e,d,r,a);for(const nt of z)b.add(nt);const G=b.getProfiles();q.set(O,(G==null?void 0:G.profile)||[]),x.set(O,(G==null?void 0:G.holes)||[]),O++}let S=0;const B=new Map,A=new Map;for(const[T,b]of q)b.length&&(B.set(T,S),A.set(S,b),S++);const U=new Map;for(const[T,b]of x)if(b.length){const z=B.get(T);U.set(z,b)}const st={bbox:d,type:it.SHELL,profiles:A,holes:U,points:I.get(),profilesFaceIds:[]};return this.computeShellFaceIds(st,r,a),st}static computeShellFaceIds(t,e,s){var E;let n=e.faceThreshold;s&&((E=e.categoryFaceThresholds)!=null&&E.has(s))&&(n=e.categoryFaceThresholds.get(s));const i=new Map;let r=0;const a=new Map,c=new Map,h=new Map,u=new _,l=new _,f=new _,p=new _,d=new Yt,g=t.profiles.size;for(let w=0;w<g;w++){const I=t.profiles.get(w),v=I.length;for(let S=0;S<v;S++){const B=I[S],U=S===v-1?I[0]:I[S+1],st=Math.min(B,U),T=Math.max(B,U),b=st+this.makeDecimal(T);c.has(w)?c.get(w).push(b):c.set(w,[b]),a.has(b)?a.get(b).push(w):a.set(b,[w])}let q=0,x=1,O=2;for(;O<v;){const S=I[q],B=I[x],A=I[O];if(u.set(t.points[S][0],t.points[S][1],t.points[S][2]),l.set(t.points[B][0],t.points[B][1],t.points[B][2]),f.set(t.points[A][0],t.points[A][1],t.points[A][2]),d.set(u,l,f),d.getNormal(p),p.x!==0||p.y!==0||p.z!==0)break;q++,x++,O++}h.set(w,[p.x,p.y,p.z])}for(const[w,I]of c){let v=i.get(w);v===void 0&&(v=r++,i.set(w,v));const[q,x,O]=h.get(w);for(const S of I){const B=a.get(S);for(const A of B){if(A===w)continue;const[U,st,T]=h.get(A),z=Math.abs(q*U+x*st+O*T)<n;if(i.has(A)){if(!z){const G=i.get(A);for(const[nt,pt]of i)pt===G&&i.set(nt,v)}}else{const G=z?r++:v;i.set(A,G)}}}}for(let w=0;w<t.profiles.size;w++)if(!i.has(w))throw new Error(`Face id not found for profile ${w}`);const y=Array.from(i.keys()).sort((w,I)=>w-I);for(const w of y){const I=i.get(w);t.profilesFaceIds.push(I)}}static makeDecimal(t){let e=1;for(;e<=t;)e*=10;return t/e}};o(ct,"ushortMaxValue",65e3);let R=ct;class ne{static transform(t,e,s=new ht){for(let n=0;n<s.planes.length;n++){const i=s.planes[n],r=t.planes[n];i.copy(r),i.applyMatrix4(e)}return s}static isIncluded(t,e){return Gt.collides(t,e,!0)}static collides(t,e){return Gt.collides(t,e,!1)}}class De{constructor(){o(this,"int");o(this,"float");o(this,"buffer");o(this,"s1",4);o(this,"s2",8);const{intBuffer:t,floatBuffer:e,buffer:s}=this.newBuffers();this.int=t,this.float=e,this.buffer=s}newBuffers(){const t=new Int32Array(1),e=t.buffer,s=new Float32Array(e),n=new Uint8Array(e);return{intBuffer:t,floatBuffer:s,buffer:n}}}class Pt{static check(t){const e=Number.isInteger(t),s=t<this._max,n=t>this._min;return e&&s&&n}}o(Pt,"_max",2147483647),o(Pt,"_min",-2147483648);const Mt=class Mt{constructor(){o(this,"_core",new De);o(this,"_handlers");o(this,"_result",-1);o(this,"handleObject",t=>{const e=Object.keys(t);for(const s of e)t.hasOwnProperty(s)&&this.compute(t[s])});o(this,"handleString",t=>{const e=t.length;for(let s=0;s<e;++s){const n=t.codePointAt(s);this._core.int[0]=n,this.update()}});o(this,"handleBoolean",t=>{t?this._core.int[0]=1:this._core.int[0]=0,this.update()});o(this,"handleNumber",t=>{const s=Pt.check(t)?this._core.int:this._core.float;s[0]=t,this.update()});this._handlers=this.newHandlers()}get value(){return~this._result}fromMaterialData(t){const{modelId:e,objectClass:s,currentLod:n,templateId:i,...r}=t;this.reset(),this.compute(e),this.compute(s),this.compute(r),this.compute(n),this.compute(i!==void 0)}generate(t){this.reset();for(const e of t)this.compute(e);return this.value}compute(t){return this.getHandler(t)(t),this}reset(){return this._result=-1,this}getHandler(t){const e=typeof t,s=this._handlers[e];if(!s)throw new Error("Fragments: Unsupported input type");return s}newHandlers(){return{number:this.handleNumber,boolean:this.handleBoolean,string:this.handleString,object:this.handleObject}}update(){for(let t=0;t<this._core.s1;++t){this._result^=this._core.buffer[t];for(let e=0;e<this._core.s2;++e)this._result&1?this._result=this._result>>1^Mt._polynomial:this._result>>=1}}};o(Mt,"_polynomial",2197175160);let Lt=Mt;const K=class K{constructor(t,e){o(this,"_first");this._first=this.newData(t,e)}static getComplementary(t,e){let s=0;const n=t.position.length;s=this.makeBufferComplementary(n,t,s,e),s!==1/0&&e(s,1/0)}static get(t,e,s,n){const{filtered:i,position:r,size:a}=this.getData(t,s);return this.setAllBufferData(i,e,r,a,n),{position:r,size:a}}fullOf(t){const e=this._first.following,s=this._first.data;return e===null&&s===t}update(t,e){const s=this.getBufferData(t);if(!(s.data===e)){const{a:i,c:r,b:a}=this.newBuffers(t,s,e);this.setupInputData(s,i,r),this.setupUpdateBuffers(i,a,r)}}size(t){let e=0,s=this._first;for(;s!==null;)this.doesFilterPass(t,s)&&e++,s=s.following;return e}static setAllBufferData(t,e,s,n,i){for(let r=0;r<t.length;++r){const a=t[r];this.transform(a,e),this.setBuffers(s,n,r),i&&i(r,a.data)}}static makeBufferComplementary(t,e,s,n){for(let i=0;i<t;++i){const r=this.getBuffers(e,i),{position:a,size:c}=r;a>s&&n(s,a-s),s=a+c}return s}static setBuffers(t,e,s){t[s]=this._tempData.position,this._tempData.size===1/0?e[s]=this._inf:e[s]=this._tempData.size}add(t,e,s){if(!K._stash.length)return this.newData(e,s,t);const i=K._stash.pop();if(!i)throw new Error("Fragments: No stash found");return i.position=t,i.size=e,i.data=s,i}remove(t){t&&(t.following=null,t.past=null,K._stash.push(t))}static getData(t,e){const s=t.filter(e),n=s.length,i=new Uint32Array(n),r=new Uint32Array(n);return{filtered:s,position:i,size:r}}filter(t){const e=[];let s=this._first;for(;s!==null;)this.doesFilterPass(t,s)&&e.push(s),s=s.following;return e}static transform(t,e){const s=this.getTempData(),n=t.position+t.size,i=n===e.length;if(s.position=e[t.position],i)s.size=1/0;else{const r=e[n];s.size=r-s.position}return s}static getBuffers(t,e){const s=t.position[e],n=t.size[e]===this._inf;let i;return n?i=1/0:i=t.size[e],{position:s,size:i}}static getTempData(){return this._tempData?this._tempData:{position:0,size:0}}doesFilterPass(t,e){return!t||t(e.data)}setupUpdateBuffers(t,e,s){this.chainBuffers(t,e,s),this.setupFirstBuffer(t,e),this.setupLastBuffer(s,e),this.setupMiddleBufferStart(e),this.setupMiddleBufferEnd(e)}setupMiddleBufferEnd(t){var e;if(((e=t.following)==null?void 0:e.data)===t.data){if(!t.following)return;const s=t.following.size+t.size,n=t.following.following;t.size=s,this.remove(t.following),t.following=n,t.following&&(t.following.past=t)}}setupFirstBuffer(t,e){t.size||(t.past?t.past.following=e:this._first=e,e.past=t.past,this.remove(t))}setupMiddleBufferStart(t){var e;if(((e=t.past)==null?void 0:e.data)===t.data){if(!t.past)return;t.size=t.past.size+t.size,t.position=t.past.position;const s=t.past.past;this.remove(t.past),t.past=s,t.past?t.past.following=t:this._first=t}}chainBuffers(t,e,s){t.following=e,e.past=t,e.following=s,s.past=e}setupLastBuffer(t,e){t.size||(t.following&&(t.following.past=e),e.following=t.following,this.remove(t))}newBuffers(t,e,s){const n=t-e.position,i=this.add(e.position,n,e.data),r=this.add(t,1,s),a=e.size-i.size-1,c=this.add(t+1,a,e.data);return{a:i,c,b:r}}setupInputData(t,e,s){t.past?(t.past.following=e,e.past=t.past):this._first=e,t.following&&(t.following.past=s,s.following=t.following),this.remove(t)}newData(t,e,s=0){return{position:s,size:t,past:null,following:null,data:e}}getBufferData(t){let e=this._first;for(;;){const s=e===null,n=e.position<=t,i=t<e.position+e.size;if(s||n&&i)return e;e=e.following}}};o(K,"_stash",[]),o(K,"_tempData",{position:0,size:0}),o(K,"_inf",4294967295);let qt=K;class ie{static estimateCapacity(){const t=this.capacityFactor,e=window.screen.width,s=window.screen.height,n=window.devicePixelRatio;return Math.trunc(e*s*n*n*t)}}o(ie,"capacityFactor",200);const Vt=new Z,mt=new _;class re extends Qt{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";const t=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],e=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],s=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(s),this.setAttribute("position",new Ut(t,3)),this.setAttribute("uv",new Ut(e,2))}applyMatrix4(t){const e=this.attributes.instanceStart,s=this.attributes.instanceEnd;return e!==void 0&&(e.applyMatrix4(t),s.applyMatrix4(t),e.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const s=new At(e,6,1);return this.setAttribute("instanceStart",new rt(s,3,0)),this.setAttribute("instanceEnd",new rt(s,3,3)),this.instanceCount=this.attributes.instanceStart.count,this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const s=new At(e,6,1);return this.setAttribute("instanceColorStart",new rt(s,3,0)),this.setAttribute("instanceColorEnd",new rt(s,3,3)),this}fromWireframeGeometry(t){return this.setPositions(t.attributes.position.array),this}fromEdgesGeometry(t){return this.setPositions(t.attributes.position.array),this}fromMesh(t){return this.fromWireframeGeometry(new fe(t.geometry)),this}fromLineSegments(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Z);const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;t!==void 0&&e!==void 0&&(this.boundingBox.setFromBufferAttribute(t),Vt.setFromBufferAttribute(e),this.boundingBox.union(Vt))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new bt),this.boundingBox===null&&this.computeBoundingBox();const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(t!==void 0&&e!==void 0){const s=this.boundingSphere.center;this.boundingBox.getCenter(s);let n=0;for(let i=0,r=t.count;i<r;i++)mt.fromBufferAttribute(t,i),n=Math.max(n,s.distanceToSquared(mt)),mt.fromBufferAttribute(e,i),n=Math.max(n,s.distanceToSquared(mt));this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}}_t.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new ot(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}};wt.line={uniforms:Kt.merge([_t.common,_t.fog,_t.line]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};class tt extends Zt{constructor(t){super({type:"LineMaterial",uniforms:Kt.clone(wt.line.uniforms),vertexShader:wt.line.vertexShader,fragmentShader:wt.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,this.setValues(t)}get color(){return this.uniforms.diffuse.value}set color(t){this.uniforms.diffuse.value=t}get worldUnits(){return"WORLD_UNITS"in this.defines}set worldUnits(t){t===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}get linewidth(){return this.uniforms.linewidth.value}set linewidth(t){this.uniforms.linewidth&&(this.uniforms.linewidth.value=t)}get dashed(){return"USE_DASH"in this.defines}set dashed(t){t===!0!==this.dashed&&(this.needsUpdate=!0),t===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}get dashScale(){return this.uniforms.dashScale.value}set dashScale(t){this.uniforms.dashScale.value=t}get dashSize(){return this.uniforms.dashSize.value}set dashSize(t){this.uniforms.dashSize.value=t}get dashOffset(){return this.uniforms.dashOffset.value}set dashOffset(t){this.uniforms.dashOffset.value=t}get gapSize(){return this.uniforms.gapSize.value}set gapSize(t){this.uniforms.gapSize.value=t}get opacity(){return this.uniforms.opacity.value}set opacity(t){this.uniforms&&(this.uniforms.opacity.value=t)}get resolution(){return this.uniforms.resolution.value}set resolution(t){this.uniforms.resolution.value.copy(t)}get alphaToCoverage(){return"USE_ALPHA_TO_COVERAGE"in this.defines}set alphaToCoverage(t){this.defines&&(t===!0!==this.alphaToCoverage&&(this.needsUpdate=!0),t===!0?this.defines.USE_ALPHA_TO_COVERAGE="":delete this.defines.USE_ALPHA_TO_COVERAGE)}}const St=new ft,jt=new _,Ht=new _,C=new ft,D=new ft,V=new ft,Tt=new _,Rt=new Q,P=new pe,kt=new _,gt=new Z,yt=new bt,j=new ft;let k,et;function Wt(m,t,e){return j.set(0,0,-t,1).applyMatrix4(m.projectionMatrix),j.multiplyScalar(1/j.w),j.x=et/e.width,j.y=et/e.height,j.applyMatrix4(m.projectionMatrixInverse),j.multiplyScalar(1/j.w),Math.abs(Math.max(j.x,j.y))}function Pe(m,t){const e=m.matrixWorld,s=m.geometry,n=s.attributes.instanceStart,i=s.attributes.instanceEnd,r=Math.min(s.instanceCount,n.count);for(let a=0,c=r;a<c;a++){P.start.fromBufferAttribute(n,a),P.end.fromBufferAttribute(i,a),P.applyMatrix4(e);const h=new _,u=new _;k.distanceSqToSegment(P.start,P.end,u,h),u.distanceTo(h)<et*.5&&t.push({point:u,pointOnLine:h,distance:k.origin.distanceTo(u),object:m,face:null,faceIndex:a,uv:null,uv1:null})}}function Le(m,t,e){const s=t.projectionMatrix,i=m.material.resolution,r=m.matrixWorld,a=m.geometry,c=a.attributes.instanceStart,h=a.attributes.instanceEnd,u=Math.min(a.instanceCount,c.count),l=-t.near;k.at(1,V),V.w=1,V.applyMatrix4(t.matrixWorldInverse),V.applyMatrix4(s),V.multiplyScalar(1/V.w),V.x*=i.x/2,V.y*=i.y/2,V.z=0,Tt.copy(V),Rt.multiplyMatrices(t.matrixWorldInverse,r);for(let f=0,p=u;f<p;f++){if(C.fromBufferAttribute(c,f),D.fromBufferAttribute(h,f),C.w=1,D.w=1,C.applyMatrix4(Rt),D.applyMatrix4(Rt),C.z>l&&D.z>l)continue;if(C.z>l){const I=C.z-D.z,v=(C.z-l)/I;C.lerp(D,v)}else if(D.z>l){const I=D.z-C.z,v=(D.z-l)/I;D.lerp(C,v)}C.applyMatrix4(s),D.applyMatrix4(s),C.multiplyScalar(1/C.w),D.multiplyScalar(1/D.w),C.x*=i.x/2,C.y*=i.y/2,D.x*=i.x/2,D.y*=i.y/2,P.start.copy(C),P.start.z=0,P.end.copy(D),P.end.z=0;const g=P.closestPointToPointParameter(Tt,!0);P.at(g,kt);const y=Xt.lerp(C.z,D.z,g),E=y>=-1&&y<=1,w=Tt.distanceTo(kt)<et*.5;if(E&&w){P.start.fromBufferAttribute(c,f),P.end.fromBufferAttribute(h,f),P.start.applyMatrix4(r),P.end.applyMatrix4(r);const I=new _,v=new _;k.distanceSqToSegment(P.start,P.end,v,I),e.push({point:v,pointOnLine:I,distance:k.origin.distanceTo(v),object:m,face:null,faceIndex:f,uv:null,uv1:null})}}}class qe extends X{constructor(t=new re,e=new tt({color:Math.random()*16777215})){super(t,e),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const t=this.geometry,e=t.attributes.instanceStart,s=t.attributes.instanceEnd,n=new Float32Array(2*e.count);for(let r=0,a=0,c=e.count;r<c;r++,a+=2)jt.fromBufferAttribute(e,r),Ht.fromBufferAttribute(s,r),n[a]=a===0?0:n[a-1],n[a+1]=n[a]+jt.distanceTo(Ht);const i=new At(n,2,1);return t.setAttribute("instanceDistanceStart",new rt(i,1,0)),t.setAttribute("instanceDistanceEnd",new rt(i,1,1)),this}raycast(t,e){const s=this.material.worldUnits,n=t.camera;n===null&&!s&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const i=t.params.Line2!==void 0&&t.params.Line2.threshold||0;k=t.ray;const r=this.matrixWorld,a=this.geometry,c=this.material;et=c.linewidth+i,a.boundingSphere===null&&a.computeBoundingSphere(),yt.copy(a.boundingSphere).applyMatrix4(r);let h;if(s)h=et*.5;else{const l=Math.max(n.near,yt.distanceToPoint(k.origin));h=Wt(n,l,c.resolution)}if(yt.radius+=h,k.intersectsSphere(yt)===!1)return;a.boundingBox===null&&a.computeBoundingBox(),gt.copy(a.boundingBox).applyMatrix4(r);let u;if(s)u=et*.5;else{const l=Math.max(n.near,gt.distanceToPoint(k.origin));u=Wt(n,l,c.resolution)}gt.expandByScalar(u),k.intersectsBox(gt)!==!1&&(s?Pe(this,e):Le(this,n,e))}onBeforeRender(t){const e=this.material.uniforms;e&&e.resolution&&(t.getViewport(St),this.material.uniforms.resolution.value.set(St.z,St.w))}}class ae extends re{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(t){const e=t.length-3,s=new Float32Array(2*e);for(let n=0;n<e;n+=3)s[2*n]=t[n],s[2*n+1]=t[n+1],s[2*n+2]=t[n+2],s[2*n+3]=t[n+3],s[2*n+4]=t[n+4],s[2*n+5]=t[n+5];return super.setPositions(s),this}setColors(t){const e=t.length-3,s=new Float32Array(2*e);for(let n=0;n<e;n+=3)s[2*n]=t[n],s[2*n+1]=t[n+1],s[2*n+2]=t[n+2],s[2*n+3]=t[n+3],s[2*n+4]=t[n+4],s[2*n+5]=t[n+5];return super.setColors(s),this}setFromPoints(t){const e=t.length-1,s=new Float32Array(6*e);for(let n=0;n<e;n++)s[6*n]=t[n].x,s[6*n+1]=t[n].y,s[6*n+2]=t[n].z||0,s[6*n+3]=t[n+1].x,s[6*n+4]=t[n+1].y,s[6*n+5]=t[n+1].z||0;return super.setPositions(s),this}fromLine(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}}class Be extends qe{constructor(t=new ae,e=new tt({color:Math.random()*16777215})){super(t,e),this.isLine2=!0,this.type="Line2"}}class ze{constructor(t){o(this,"model");o(this,"_endpointsMaterials",{interior:new Nt({color:15658734,size:8,sizeAttenuation:!1,depthTest:!1}),exterior:new Nt({color:16777215,size:16,sizeAttenuation:!1,depthTest:!1})});o(this,"_absoluteAlignments",new J);o(this,"_horizontalAlignments",new J);o(this,"_verticalAlignments",new J);o(this,"_alignmentMaterials",new Map([[at.NONE,new tt({color:16777215,linewidth:5,depthTest:!1})],[at.LINES,new tt({color:16711935,linewidth:5,depthTest:!1})],[at.CLOTHOID,new tt({color:16711680,linewidth:5,depthTest:!1})],[at.ELLIPSE_ARC,new tt({color:65535,linewidth:5,depthTest:!1})],[at.PARABOLA,new tt({color:255,linewidth:5,depthTest:!1})]]));this.model=t}async getAlignments(){return this._absoluteAlignments.children.length||await this.constructAlignments(),this._absoluteAlignments}async getHorizontalAlignments(){return this._horizontalAlignments.children.length||await this.constructAlignments(),this._horizontalAlignments}async getVerticalAlignments(){return this._verticalAlignments.children.length||await this.constructAlignments(),this._verticalAlignments}async getAlignmentStyles(){return{...this._alignmentMaterials,...this._endpointsMaterials}}async constructAlignments(){const t=await this.model.threads.invoke(this.model.modelId,"getAlignments");for(const e of t)this.constructLine(e.absolute,this._absoluteAlignments),this.constructLine(e.horizontal,this._horizontalAlignments),this.constructLine(e.vertical,this._verticalAlignments)}constructLine(t,e){if(!t.length)return;const s=[],n=[],i=new J;e.add(i);const r=t[0].points,a=t[t.length-1].points;n.push(a[0],a[1],a[2]),n.push(r[r.length-3],r[r.length-2],r[r.length-1]);for(const u of t){const l=u.points;s.push(l[0],l[1],l[2]),s.push(l[l.length-3],l[l.length-2],l[l.length-1]);const f=new ae;f.setPositions(l);const p=this._alignmentMaterials.get(u.type),d=new Be(f,p);i.add(d),d.renderOrder=1,d.userData.points=l}const{interior:c,exterior:h}=this._endpointsMaterials;this.constructPoints(s,c,i),this.constructPoints(n,h,i)}constructPoints(t,e,s){const n=new me,i=new ut,r=new Float32Array(t),a=new Y(r,3);i.setAttribute("position",a),n.geometry=i,n.material=e,s.add(n),n.renderOrder=2}dispose(){this._absoluteAlignments.removeFromParent();for(const t of this._absoluteAlignments.children){const e=t;e.geometry.dispose(),e.geometry=void 0,e.material=void 0}for(const t of Object.values(this._alignmentMaterials))t.dispose();this._alignmentMaterials={}}}class Fe{async setup(t,e,s,n,i){const r=this.getCreateModelMessage(t,s,n,i),a=this.formatModelData(s),c=await t.threads.fetch(r,a);this.updateBox(e,c)}formatModelData(t){if(t instanceof ArrayBuffer)return[t]}updateBox(t,e){t.min.copy(e.boundingBox.min),t.max.copy(e.boundingBox.max)}getCreateModelMessage(t,e,s,n){return{class:W.CREATE_MODEL,modelId:t.modelId,modelData:e,raw:s,config:n}}}class Oe{async getBoxes(t,e){const s=this.getIndividualBoxesIds(e),n=this.getBoxRequest(t,s),i=await t.threads.fetch(n);return this.getAllBoxes(i,t)}async getMergedBox(t,e){const s=this.getBoxRequest(t,[e]),{boxes:n}=await t.threads.fetch(s),[i]=n;return this.getAbsoluteBox(i,t)}getAbsoluteBox(t,e){const s=new Z;return s.copy(t),s.applyMatrix4(e.object.matrixWorld),s}getIndividualBoxesIds(t){if(!t)return;const e=[];for(const s of t)e.push([s]);return e}getAllBoxes(t,e){const s=t.boxes,n=[];for(const i of s){const r=new Z;r.copy(i),r.applyMatrix4(e.object.matrixWorld),n.push(r)}return n}getBoxRequest(t,e){return{class:W.FETCH_BOXES,modelId:t.modelId,localIds:e}}}class Ge{constructor(){o(this,"_coordinationMatrices",new Map)}async getCoordinationMatrix(t){let e=this._coordinationMatrices.get(t.modelId);if(e)return e;e=new Q,this._coordinationMatrices.set(t.modelId,e);const[s,n,i,r,a,c,h,u,l]=await this.getCoordinates(t),f=new _(r,a,c),p=new _(h,u,l),d=new _().crossVectors(f,p);return e.set(r,h,d.x,s,a,u,d.y,n,c,l,d.z,i,0,0,0,1),e}async getCoordinates(t){const e=t.modelId;return t.threads.invoke(e,"getCoordinates")}async getPositions(t,e){const s=[e],n=await t.threads.invoke(t.modelId,"getPositions",s);return this.getAbsolutePositions(n,t)}getAbsolutePositions(t,e){const s=[];for(const n of t){const{x:i,y:r,z:a}=n,c=new _(i,r,a);c.applyMatrix4(e.object.matrixWorld),s.push(c)}return s}}class Ue extends Map{constructor(e,s){super(s);o(this,"tracker",null);o(this,"localId");o(this,"guard",()=>!0);this.localId=e}get object(){const e={};for(const[s,n]of this.entries())e[s]=n.value;return e}set(e,s){if(!(this.guard??(()=>!0))(e,s))return this;const r=s.type!==void 0?s:{value:s.value,type:this.getType(e)};if(!this.tracker)return super.set(e,r);if(this.localId===null)return console.warn("Item attributes are missing a valid localId. Changes can't be tracked."),super.set(e,r);let a=this.tracker.get(this.localId);return a||(a={type:"modified",added:{},deleted:[],modified:{}},this.tracker.set(this.localId,a)),a.type==="added"?a.data[e]=r:a.type==="modified"&&(this.has(e)?a.modified[e]=r:a.deleted.includes(e)?(a.deleted=a.deleted.filter(c=>c!==e),a.modified[e]=r):a.added[e]=r),super.set(e,r)}setValue(e,s){return this.set(e,{value:s,type:this.getType(e)})}setType(e,s){const n=this.getValue(e);return n?this.set(e,{value:n,type:s}):this}delete(e){if(!this.tracker)return super.delete(e);const s=this.get("localId");if(s===void 0||typeof s!="number")return console.warn("Item attributes are missing a valid localId. Changes can't be tracked."),e==="localId"?!1:super.delete(e);if(e==="localId"||!this.has(e))return!1;let n=this.tracker.get(s);return n||(n={type:"modified",added:{},deleted:[],modified:{}},this.tracker.set(s,n)),n.type==="added"?delete n.data[e]:n.type==="modified"&&(e in n.added?delete n.added[e]:(e in n.modified&&delete n.modified[e],n.deleted.push(e))),super.delete(e)}getValue(e){const s=this.get(e);return s?s.value:null}getType(e){var s;return(s=this.get(e))==null?void 0:s.type}}class Ne extends Map{constructor(e,s){super(s);o(this,"tracker",null);o(this,"localId");o(this,"guard",()=>!0);o(this,"onItemsRequested",null);this.localId=e}get itemChanges(){if(!this.tracker)return null;if(!this.localId)return console.warn("Item relations can't be tracked."),null;let e=this.tracker.get(this.localId);return e||(e={type:"modified",added:{},deleted:new Set,removed:{},modified:{}},this.tracker.set(this.localId,e)),e}set(e,s){const n=this.has(e);if(!(this.guard??(()=>!0))(e,s))return this;const a=this.itemChanges;return a?(n?a.modified[e]=s:a.added[e]=s,super.set(e,s)):super.set(e,s)}add(e,s){var a;const n=this.has(e);let i=this.get(e);if(!i)return i=new Set([s]),this.set(e,i),!0;if(!i||i.has(s))return!1;const r=this.itemChanges;if(!r)return i.add(s),!0;if(n)if((a=r.removed[e])!=null&&a.has(s))r.removed[e].delete(s),r.removed[e].size===0&&delete r.removed[e];else{let c=r.modified[e];c||(c=new Set,r.modified[e]=c),c.add(s)}else{let c=r.added[e];c||(c=new Set,r.added[e]=c),c.add(s)}return i.add(s),!0}remove(e,s){var r;const n=this.get(e);if(!n||!n.has(s))return!1;const i=this.itemChanges;if(!i)return n.delete(s);if((r=i.modified[e])!=null&&r.has(s))i.modified[e].delete(s),i.modified[e].size===0&&delete i.modified[e];else{let a=i.removed[e];a||(a=new Set,i.removed[e]=a),a.add(s)}return n.delete(s)}delete(e){if(!this.has(e))return!1;const s=this.itemChanges;return s?(s.deleted.add(e),super.delete(e)):super.delete(e)}async getItems(e){if(!this.onItemsRequested)return null;const s=this.get(e);return s?await this.onItemsRequested([...s]):null}}class Ve{constructor(t,e){o(this,"model");o(this,"localId");o(this,"_indices",null);o(this,"_transform",null);o(this,"_normals",null);o(this,"_positions",null);o(this,"_vertices",null);o(this,"_triangles",null);o(this,"_position",null);o(this,"_box",null);this.model=t,this.localId=e}async get(){const[t]=await this.model.threads.invoke(this.model.modelId,"getItemsGeometry",[[this.localId]]);for(const e of t){e.transform=new Q().fromArray(e.transform.elements);const{indices:s,normals:n,positions:i,transform:r}=e;this._indices||(this._indices=[]),this._normals||(this._normals=[]),this._positions||(this._positions=[]),this._transform||(this._transform=[]),this._indices.push(s),this._normals.push(n),this._positions.push(i),this._transform.push(r)}return t}async getIndices(){return this._indices!==null?this._indices:(await this.get(),this._indices)}async getTransform(){return this._transform!==null?this._transform:(await this.get(),this._transform)}async getNormals(){return this._normals!==null?this._normals:(await this.get(),this._normals)}async getPositions(){return this._positions!==null?this._positions:(await this.get(),this._positions)}async getVertices(){if(this._vertices)return this._vertices;const t=await this.getPositions(),e=await this.getTransform();if(!t||!e)return this._vertices;this._vertices=[];for(let s=0;s<t.length;s++){const n=t[s],i=e[s];if(!n||!i)continue;const r=[];this._vertices.push(r);const a=Object.keys(n).length/3,c=[];for(let h=0;h<a;h++){const u=n[h*3],l=n[h*3+1],f=n[h*3+2];if(typeof u!="number"||typeof l!="number"||typeof f!="number")continue;const p=`${u},${l},${f}`;if(c.includes(p))continue;c.push(p);const d=new _(u,l,f);d.applyMatrix4(i),r.push(d)}}return this._vertices}async getTriangles(){if(this._triangles)return this._triangles;const t=await this.getIndices(),e=await this.getPositions(),s=await this.getTransform();if(!t||!e||!s)return this._triangles;this._triangles=[];for(let n=0;n<t.length;n++){const i=t[n],r=e[n],a=s[n];if(!i||!r||!a)continue;const c=[];this._triangles.push(c);for(let h=0;h<i.length;h+=3){const u=i[h],l=i[h+1],f=i[h+2],p=new _(r[u*3],r[u*3+1],r[u*3+2]),d=new _(r[l*3],r[l*3+1],r[l*3+2]),g=new _(r[f*3],r[f*3+1],r[f*3+2]);p.applyMatrix4(a),d.applyMatrix4(a),g.applyMatrix4(a),c.push(new Yt(p,d,g))}}return this._triangles}async getPosition(){if(!this._position){if(this.localId===null)return null;this._position=await this.model.getPositions([this.localId])}return this._position}async getBox(){if(!this._box){if(this.localId===null)return null;this._box=await this.model.getBoxes([this.localId])}return this._box}async setVisibility(t){await this.model.setVisible([this.localId],t)}async getVisibility(){const[t]=await this.model.getVisible([this.localId]);return t}}class je{constructor(t,e){o(this,"model");o(this,"_localId",null);o(this,"_attributes",null);o(this,"_relations",null);o(this,"_guid",null);o(this,"_category",null);o(this,"_geometry",null);this.model=t,typeof e=="number"&&(this._localId=e),typeof e=="string"&&(this._guid=e)}async getLocalId(){if(!this._localId)if(this._guid)[this._localId]=await this.model.threads.invoke(this.model.modelId,"getLocalIdsByGuids",[[this._guid]]);else throw new Error("Fragments: Item localId couldn't be get.");return this._localId}async getAttributes(){if(this._attributes)return this._attributes;const t=await this.getLocalId();if(t===null)return null;const e=await this.model.threads.invoke(this.model.modelId,"getItemAttributes",[t]);if(this._attributes=new Ue(t),!e){const n=this.model.attrsChanges.get(t);if(!(n&&n.type==="added"))return null;this._attributes.localId=t;for(const[i,r]of Object.entries(n.data))this._attributes.set(i,r);return this._attributes}const s=this.model.attrsChanges.get(t);if(s&&s.type==="modified")for(const[n,i]of Object.entries(s.added))this._attributes.set(n,i);for(const n in e){const{value:i,type:r}=e[n];(s==null?void 0:s.type)==="modified"&&s.deleted.includes(n)||((s==null?void 0:s.type)==="modified"&&n in s.modified?this._attributes.set(n,s.modified[n]):this._attributes.set(n,{value:i,type:r}))}return this._attributes.tracker=this.model.attrsChanges,this._attributes}async getRelations(){if(this._relations)return this._relations;const t=await this.getLocalId();if(t===null)return null;const e=await this.model.threads.invoke(this.model.modelId,"getItemRelations",[t]);if(!e)return null;this._relations=new Ne(t),this._relations.onItemsRequested=async n=>{const i=[];for(const r of n){const a=this.model.getItem(r);a&&i.push(a)}return i};const s=this.model.relsChanges.get(t);if(s&&s.type==="modified")for(const[n,i]of Object.entries(s.added))this._relations.set(n,i);for(const[n,i]of Object.entries(e))if(!((s==null?void 0:s.type)==="modified"&&s.deleted.has(n)))if((s==null?void 0:s.type)==="modified"&&n in s.modified){const r=new Set([...s.modified[n],...i]);this._relations.set(n,new Set(r))}else this._relations.set(n,new Set(i));return this._relations.tracker=this.model.relsChanges,this._relations}async getGuid(){if(!this._guid){const t=await this.getLocalId();if(t===null)return null;[this._guid]=await this.model.threads.invoke(this.model.modelId,"getGuidsByLocalIds",[[t]])}return this._guid}async getCategory(){if(!this._category){const t=await this.getLocalId();if(t===null)return null;this._category=await this.model.threads.invoke(this.model.modelId,"getItemCategory",[t])}return this._category}async getGeometry(){if(this._geometry)return this._geometry;const t=await this.getLocalId();return t===null?null:new Ve(this.model,t)}async getData(t=[]){var a;const e=await this.getLocalId();if(e==null)return{};t.push(e);const s=(a=await this.getAttributes())==null?void 0:a.object,n=await this.getRelations(),i={};if(n)for(const c of n.keys()){const h=[];i[c]=h;const u=await n.getItems(c);if(u)for(const l of u){const f=await l.getLocalId();if(!f||t.find(d=>d===f)!==void 0)continue;t.push(f);const p=await l.getData(t);p&&h.push(p)}}return{...s,...i}}}class He{getItem(t,e){return new je(t,e)}async getItemsData(t,e,s){return t.threads.invoke(t.modelId,"getItemsData",[e,s])}async getItemsChildren(t,e){return t.threads.invoke(t.modelId,"getItemsChildren",[e])}}class ke{constructor(){o(this,"getClippingPlanesEvent",()=>[]);o(this,"currentCamera",null);o(this,"_tempMatrix",new Q);o(this,"_tempVec",new _);o(this,"_tempFrustum",new ht);o(this,"_updateCameraPositionEvent",()=>{});o(this,"_updateCameraFrustumEvent",()=>{});o(this,"_updateFOVEvent",()=>{});o(this,"_updateOrthoSizeEvent",()=>{})}async refreshView(t,e){const s=this.setup(e,t),n=ne.transform(this._tempFrustum,this._tempMatrix),i=this.newViewRequest(n,s,t);await t.threads.fetch(i)}useCamera(t){const e=new Q;this.setCameraPosition(t),this.setCameraFrustum(t,e),this.setFov(t),this.setOrtho(),this.currentCamera=t}async setLodMode(t,e){return t.threads.invoke(t.modelId,"setLodMode",[e])}getOrthoSize(){let t=this._updateOrthoSizeEvent();if(t){const e=this._tempMatrix.getMaxScaleOnAxis();t*=e}return t}setup(t,e){return t.requests.clean(e.modelId),this._tempMatrix.copy(e.object.matrixWorld).invert(),this._updateCameraPositionEvent(this._tempVec),this._updateCameraFrustumEvent(this._tempFrustum),this._updateFOVEvent()}newViewRequest(t,e,s){const n=this.newView(t,e,s),i={};return i.class=W.REFRESH_VIEW,i.modelId=s.modelId,i.cameraFrustum=t,i.view=n,i}newView(t,e,s){const n={};return n.cameraFrustum=t,n.cameraPosition=this._tempVec.applyMatrix4(this._tempMatrix),n.fov=e,n.orthogonalDimension=this.getOrthoSize(),n.viewSize=Math.max(window.innerWidth,window.innerHeight),n.graphicThreshold=ie.estimateCapacity(),n.graphicQuality=s.graphicsQuality*-1.5+2,n.clippingPlanes=this.getPlanes(),n.modelPlacement=s.object.matrixWorld,n}setOrtho(){this._updateOrthoSizeEvent=()=>{}}setFov(t){this._updateFOVEvent=()=>{if(t instanceof ge)return t.fov}}getPlanes(){const t=[],e=this.getClippingPlanesEvent();for(const s of e){const n=s.clone();n.applyMatrix4(this._tempMatrix),t.push(n)}return t}setCameraPosition(t){this._updateCameraPositionEvent=e=>{e.copy(t.position)}}setCameraFrustum(t,e){this._updateCameraFrustumEvent=s=>{t.updateProjectionMatrix(),t.updateWorldMatrix(!0,!0);const{projectionMatrix:n,matrixWorldInverse:i}=t;e.multiplyMatrices(n,i),s.setFromProjectionMatrix(e)}}}class We{constructor(){o(this,"_caster",new ye);o(this,"_ray",new Jt);o(this,"_frustum",new ht);o(this,"_inverseTransform",new Q);o(this,"_t",new $);o(this,"_r",new $);o(this,"_b",new $);o(this,"_l",new $);o(this,"_n",new $);o(this,"_f",new $);o(this,"_tl",new _);o(this,"_tr",new _);o(this,"_bl",new _);o(this,"_br",new _);o(this,"_tln",new _);o(this,"_brn",new _);o(this,"_tlp",new ot);o(this,"_brp",new ot);o(this,"distance",10)}async raycast(t,e){const{frustum:s,ray:n}=this.getRayAndFrustum(e),i=this.getRequest(t,s,n);if(!i)return null;const r=await t.threads.fetch(i);if(r.results&&r.results.length){const[a]=r.results;return this.getResult({hit:a,frustum:s,ray:n,model:t})}return null}async raycastAll(t,e){const{frustum:s,ray:n}=this.getRayAndFrustum(e),i=this.getRequest(t,s,n);if(!i)return null;i.returnAll=!0;const r=[],a=await t.threads.fetch(i);if(a.results&&a.results.length){for(const c of a.results)r.push(this.getResult({hit:c,frustum:s,ray:n,model:t}));return r}return null}async rectangleRaycast(t,e,s){const n=this.getFrustum(s),i=this.getRequest(t,n);if(!i)return null;i.fullyIncluded=s.fullyIncluded;const r=await t.threads.fetch(i);return r.localIds&&r.localIds.length?this.newRectangleCastResponse(r,e):null}async raycastWithSnapping(t,e){const{frustum:s,ray:n}=this.getRayAndFrustum(e),i=this.getRequest(t,s,n);if(!i)return null;i.snappingClass=e.snappingClasses;const r=await t.threads.fetch(i);return r.results?this.newRaycastSnapResult(r,s,n,t):null}screenRectToFrustum(t,e,s,n){return this.screenToCast(t,s,this._tlp),this.screenToCast(e,s,this._brp),this.setVectors(n),this.setPlanes(n),this.newFrustum()}screenToCasterPoint(t,e,s){const n=this.screenToCast(t,e);return this._caster.setFromCamera(n,s),this._caster.ray.clone()}setPlanes(t){this.setBasePoints(),t.getWorldDirection(this._n.normal),this.setEnds(t)}setVectors(t){this.setVector(this._tl,this._tlp,this._tlp,1,t),this.setVector(this._tr,this._brp,this._tlp,1,t),this.setVector(this._bl,this._tlp,this._brp,1,t),this.setVector(this._br,this._brp,this._brp,1,t),this.setVector(this._tln,this._tlp,this._tlp,0,t),this.setVector(this._brn,this._brp,this._brp,0,t)}newFrustum(){return new ht(this._t,this._b,this._l,this._r,this._f,this._n)}setEnds(t){t instanceof we?(this._n.constant=t.near,this._f.constant=t.far):(this._n.constant=t.position.length(),this._f.constant=1/0),this._f.normal=this._n.normal}screenToCast(t,e,s=new ot){const n=e.getBoundingClientRect(),i=n.width/e.clientWidth,r=n.height/e.clientHeight,a=(t.x-n.left)/i,c=(t.y-n.top)/r;return s.x=a/e.clientWidth*2-1,s.y=-(c/e.clientHeight)*2+1,s}setVector(t,e,s,n,i){t.set(e.x,s.y,n),t.unproject(i)}setPlane(t,e,s,n){t.setFromCoplanarPoints(e,s,n)}setBasePoints(){this.setPlane(this._t,this._tln,this._tl,this._tr),this.setPlane(this._r,this._brn,this._tr,this._br),this.setPlane(this._b,this._brn,this._br,this._bl),this.setPlane(this._l,this._tln,this._bl,this._tl)}setupRay(t,e){t&&(this._ray.copy(t),this._ray.applyMatrix4(this._inverseTransform),e.ray=this._ray)}setupMatrix(t){this._inverseTransform.copy(t.matrixWorld),this._inverseTransform.invert()}getRequest(t,e,s){const{object:n,box:i,modelId:r}=t;return e.intersectsBox(i)?this.newCastRequest(n,r,s,e):null}getRayAndFrustum(t){this.updateCamera(t.camera);const{bottomLeft:e,topRight:s}=this.getCorners(t.mouse),n=this.screenToCasterPoint(t.mouse,t.dom,t.camera),i=this.screenRectToFrustum(e,s,t.dom,t.camera);return{ray:n,frustum:i}}getFrustum(t){return this.updateCamera(t.camera),this.screenRectToFrustum(t.topLeft,t.bottomRight,t.dom,t.camera)}getCorners(t){const e=t.clone().subScalar(this.distance),s=t.clone().addScalar(this.distance);return{bottomLeft:e,topRight:s}}getResult(t){const{hit:e,frustum:s,ray:n,model:i}=t,r={};return this.setPoint(i,e,r),this.setNormal(i,e,r),this.setDistance(i,e,r),this.setRayDistance(i,e,r),this.setBasicHitData(i,e,r,n,s),this.setSnapEdge(i,e,r,"snappedEdgeP1"),this.setSnapEdge(i,e,r,"snappedEdgeP2"),r.facePoints=e.facePoints,r.faceIndices=e.faceIndices,r}updateCamera(t){t.updateProjectionMatrix(),t.updateWorldMatrix(!0,!0)}newCastRequest(t,e,s,n){this.setupMatrix(t);const i={};return i.class=W.RAYCAST,i.modelId=e,this.setupRay(s,i),ne.transform(n,this._inverseTransform,this._frustum),i.frustum=this._frustum,i}setSnapEdge(t,e,s,n){if(e[n]){const i=new _;i.copy(e[n]),i.applyMatrix4(t.object.matrixWorld),s[n]=i}else s[n]=void 0}setNormal(t,e,s){if(e.normal){const n=new _;n.copy(e.normal),n.transformDirection(t.object.matrixWorld),n.normalize(),s.normal=n;return}s.normal=void 0}setDistance(t,e,s){const n=Math.sqrt(e.cameraSquaredDistance),i=t.object.matrixWorld.getMaxScaleOnAxis();s.distance=n*i}setPoint(t,e,s){const n=new _;n.copy(e.point),n.applyMatrix4(t.object.matrixWorld),s.point=n}newRaycastSnapResult(t,e,s,n){const i=[];for(const r of t.results){const a=this.getResult({hit:r,frustum:e,ray:s,model:n});i.push(a)}return i}newRectangleCastResponse(t,e){return{localIds:t.localIds,fragments:e.list.get(t.modelId)}}setRayDistance(t,e,s){if(e.raySquaredDistance!==void 0){const n=t.object.matrixWorld.getMaxScaleOnAxis(),i=Math.sqrt(e.raySquaredDistance);s.rayDistance=i*n;return}s.rayDistance=void 0}setBasicHitData(t,e,s,n,i){s.itemId=e.itemId,s.localId=e.localId,s.object=t.object,s.fragments=t,s.ray=n,s.frustum=i,s.representationClass=e.representationClass,s.snappingClass=e.snappingClass}}class $e{async resetVisible(t){await t.threads.invoke(t.modelId,"resetVisible")}async getItemsByVisibility(t,e){return t.threads.invoke(t.modelId,"getItemsByVisibility",[e])}async getVisible(t,e){return t.threads.invoke(t.modelId,"getVisible",[e])}}class $t extends X{constructor(e,s){super(e,s);o(this,"geometry");o(this,"material");this.geometry=e,this.material=s,N.setupLodMeshResize(this)}}class Xe extends Qt{constructor(){super();o(this,"isLODGeometry",!0);N.setupLodAttributes(this)}isFiltered(){return!!this.getItemFilter()}computeBoundingBox(){this.boundingBox||(this.boundingBox=new Z),N.computeLodBox(this)}applyMatrix4(e){return this.applyTransformToBuffers(e),this.updateBounds(),this}computeBoundingSphere(){this.boundingSphere||(this.boundingSphere=new bt),N.computeLodSphere(this)}getItemFilter(){return N.getInstancedAttribute(this,"itemFilter")}getItemLast(){return N.getInterAttribute(this,"itemLast")}getItemFirst(){return N.getInterAttribute(this,"itemFirst")}applyTransformToBuffers(e){this.getItemFirst().applyMatrix4(e),this.getItemLast().applyMatrix4(e)}updateBounds(){this.boundingBox&&this.computeBoundingBox(),this.boundingSphere&&this.computeBoundingSphere()}}class Ye extends Zt{constructor(e){super(N.newLodMaterialParams(e));o(this,"isLodMaterial",!0);o(this,"isLineMaterial",!0);this.clipping=!0,this.lights=!1,this.needsUpdate=!0}get lodSize(){return this.uniforms.lodSize.value}set lodColor(e){this.uniforms.lodColor.value=e}set lodSize(e){this.uniforms.lodSize.value.copy(e)}get lodColor(){return this.uniforms.lodColor.value}}class zt{constructor(){o(this,"list",new Bt);o(this,"_modelMaterialMapping",new Map);o(this,"_definitions",new Map);o(this,"_idGenerator",new Lt);o(this,"white",4294967295)}static resetColors(t){for(const e of t){if(!(e&&e.color))continue;const{color:s}=e;if(s.isColor)continue;const{r:n,g:i,b:r}=s;e.color=new Ct().setRGB(n,i,r,te)}}dispose(t){this._definitions.delete(t);const e=this._modelMaterialMapping.get(t);if(e){for(const s of e){const n=this.list.get(s);n&&(n.dispose(),this.list.delete(s))}this._modelMaterialMapping.delete(t)}}get(t,e){const{modelId:s,objectClass:n,currentLod:i,templateId:r}=e;if(!(s&&n!==void 0&&i!==void 0))throw new Error("Fragments: material definition information is missing to create the material.");this._idGenerator.fromMaterialData({modelId:s,objectClass:n,currentLod:i,templateId:r,...t});const{value:a}=this._idGenerator;return this.getUniqueMaterial(a,t,e)}addDefinitions(t,e){const s=this._definitions.get(t);s?s.push(...e):this._definitions.set(t,e)}createHighlights(t,e){const{tileData:{highlightData:s,highlightIds:n},modelId:i,material:r}=e,{geometry:a}=t,c=t.material.slice(0,2),h=new Map,u=this._definitions.get(i);if(!u)return c;for(let l=0;l<s.position.length;l++){const f=n[l];this.processHighlight(h,f,u,r,e,c);const p=s.position[l],d=s.size[l],y=d===this.white?1/0:d;a.addGroup(p,y,h.get(n[l]))}return c}getFromRequest(t){const{material:e,modelId:s}=t,n=this._definitions.get(s),i=n==null?void 0:n[e];if(!i)throw new Error(`Fragments: Missing mesh material for index ${e}`);return this.get(i,t)}newLODMaterial(t,e){const{data:s}=t,n=new Ct(s.color);e.currentLod===xt.WIRES&&n.multiplyScalar(.85);const i={color:n,...this.getParameters(s)},r=new Ye(i);return r.userData={customId:s.customId},r}getParameters(t){const{opacity:e,transparent:s}=t,n=e<1;return{opacity:e,transparent:s||n,clipIntersection:!1}}new(t,e){const{objectClass:s,templateId:n}=e;let i;if(s===It.SHELL)i=new ee({color:t.color,transparent:t.opacity<1,opacity:t.opacity,userData:{customId:t.customId,localId:t.localId},depthTest:t.depthTest??!0,depthWrite:t.depthWrite??!0,side:t.renderedFaces===1?se:_e});else if(s===It.LINE)i=this.newLODMaterial({data:t,instancing:n!==void 0},e);else throw new Error("Fragments: Unsupported object class");return i}addMaterialToModel(t,e){let s=this._modelMaterialMapping.get(t);s||(s=new Set,this._modelMaterialMapping.set(t,s)),s.add(e)}processHighlight(t,e,s,n,i,r){if(!t.has(e)){const a=s[n],c=s[e],{preserveOriginalMaterial:h,...u}=c,l={...a};h?(u.color!==void 0&&(l.color=u.color),u.opacity!==void 0&&(l.opacity=u.opacity),u.transparent!==void 0&&(l.transparent=u.transparent),u.renderedFaces!==void 0&&(l.renderedFaces=u.renderedFaces),u.depthTest!==void 0&&(l.depthTest=u.depthTest)):Object.assign(l,u);const f=this.get(l,i);r.push(f),t.set(e,r.length-1)}}getUniqueMaterial(t,e,s){const n=s.modelId,i=this.list.get(t);if(i)return i;const r=this.new(e,s);return this.list.set(t,r),this.addMaterialToModel(n,t),this.list.get(t)}}class Qe{async getHighlight(t,e){const s=await t.threads.invoke(t.modelId,"getHighlight",[e]);return zt.resetColors(s),s}async highlight(t,e,s){await t.threads.invoke(t.modelId,"highlight",[e,s])}async setColor(t,e,s){await t.threads.invoke(t.modelId,"setColor",[e,s])}async resetColor(t,e){await t.threads.invoke(t.modelId,"resetColor",[e])}async setOpacity(t,e,s){await t.threads.invoke(t.modelId,"setOpacity",[e,s])}async resetOpacity(t,e){await t.threads.invoke(t.modelId,"resetOpacity",[e])}async getHighlightItemIds(t){return t.threads.invoke(t.modelId,"getHighlightItemIds")}async resetHighlight(t,e){await t.threads.invoke(t.modelId,"resetHighlight",[e])}}class Ze{async getSection(t,e,s){const n=[e,s];return await t.threads.invoke(t.modelId,"getSection",n)}}class Ke{async dispose(t,e,s,n){e.list.delete(t.modelId),await this.requestModelDelete(t),t.threads.delete(t.modelId),t.object.removeFromParent(),this.deleteAllTiles(t),e.materials.dispose(t.modelId),s.dispose(),n.dispose()}async getBuffer(t,e){return t.threads.invoke(t.modelId,"getBuffer",[e])}async getCategories(t){return t.threads.invoke(t.modelId,"getCategories")}async getMaxLocalId(t){return t.threads.invoke(t.modelId,"getMaxLocalId")}async getLocalIdsByGuids(t,e){return t.threads.invoke(t.modelId,"getLocalIdsByGuids",[e])}async getSpatialStructure(t){return t.threads.invoke(t.modelId,"getSpatialStructure")}async getItemsWithGeometry(t){return(await t.threads.invoke(t.modelId,"getItemsWithGeometry",[])).map(n=>t.getItem(n))}async getItemsWithGeometryCategories(t){return t.threads.invoke(t.modelId,"getItemsWithGeometryCategories",[])}async getItemsIdsWithGeometry(t){return t.threads.invoke(t.modelId,"getItemsWithGeometry",[])}async getItemsOfCategories(t,e){const s=[e];return await t.threads.invoke(t.modelId,"getItemsOfCategories",s)}async getItemsByQuery(t,e,s){const n=[e,s];return await t.threads.invoke(t.modelId,"getItemsByQuery",n)}async getMetadata(t){return t.threads.invoke(t.modelId,"getMetadata",[])}async getGuidsByLocalIds(t,e){return t.threads.invoke(t.modelId,"getGuidsByLocalIds",[e])}async requestModelDelete(t){await t.threads.fetch({class:W.DELETE_MODEL,modelId:t.modelId})}deleteAllTiles(t){for(const[e]of t.tiles)t.tiles.delete(e)}}class Je{async getSequenced(t,e,s,n){const i=[e,s,n];return await t.threads.invoke(t.modelId,"getSequenced",i)}}class ts{constructor(t,e){o(this,"_deltaModels",{});o(this,"_fragments");o(this,"_connection");this._fragments=t,this._connection=e}async edit(t,e,s={removeRedo:!0}){const n=this._fragments.models.list.get(t);if(!n)throw new Error(`Model ${t} not found`);const i=this._deltaModels[t]||[];this._deltaModels[t]=null,s.removeRedo&&n._setRequests({undoneRequests:[]});const{deltaModelBuffer:r,ids:a}=await n._edit(e);for(let u=0;u<e.length;u++)e[u].localId===void 0&&(e[u].localId=a[u]);const c=await this.load(r,n);this._deltaModels[t]=[c],n.deltaModelId=c.modelId;const h=[];for(const u of i)h.push(u.dispose());return await Promise.all(h),a}async save(t){const e=this._fragments.models.list.get(t);if(!e)return console.log(`Model ${t} not found`),null;const s=e.object.parent,n=await e._getRequests(),i=e.camera||void 0,r=await e._save();await e.dispose();const a=await this._fragments.load(r,{modelId:t,raw:!0,camera:i});return await a._setRequests({undoneRequests:n.undoneRequests}),s&&s.add(a.object),n}async reset(t){const e=this._fragments.models.list.get(t);if(!e){console.log(`Model ${t} not found`);return}await e._reset(),await this.disposeDeltaModels(t)}async getRequests(t){const e=this._fragments.models.list.get(t);if(!e)throw new Error(`Model ${t} not found`);return e._getRequests()}async selectRequest(t,e){const s=this._fragments.models.list.get(t);if(!s)throw new Error(`Model ${t} not found`);return s._selectRequest(e)}async _update(t){const e=this._deltaModels[t];if(e){const s=[];for(const n of e)s.push(n._refreshView());await Promise.all(s)}}async disposeDeltaModels(t){const e=this._deltaModels[t];if(e){for(const s of e)await s.dispose();this._deltaModels[t]=[]}}async load(t,e){const s=Dt.DELTA_MODEL_ID,n=`${e.modelId}${s}${performance.now()}`,i=new vt(n,this._fragments.models,this._connection,this._fragments.editor);i._setDeltaModel(e.modelId),i.frozen=!0,i.graphicsQuality=this._fragments.settings.graphicsQuality;try{this._fragments.models.list.set(i.modelId,i),await i._setup(t,!0),e.object.add(i.object)}catch(a){throw this._fragments.models.list.delete(i.modelId),a}const r=e.camera;return r&&i.useCamera(r),i.frozen=!1,i}}class es{constructor(t){o(this,"_nextTempIds",{});o(this,"_requests",{});o(this,"_fragments");this._fragments=t}getRequests(t){const e=this.getModelRequests(t);this._requests[t]=this.newRequests();const{create:s,update:n,remove:i,relations:{create:r,update:a,remove:c}}=e,h=Object.values(s),u=Object.values(n),l=Object.values(i),f=Object.values(r),p=Object.values(a),d=Object.values(c),g=[...l,...h,...u,...f,...p,...d];return g.length>0?g:null}createMaterial(t,e){const s=this.getNextTempId(t),n={r:e.color.r*255,g:e.color.g*255,b:e.color.b*255,a:e.opacity*255,renderedFaces:e.side===se?1:0,stroke:0};return this.addRequest(t,s,"create",{type:M.CREATE_MATERIAL,tempId:s,data:n}),s}createLocalTransform(t,e){const s=this.getNextTempId(t),n=R.transformFromMatrix(e);return this.addRequest(t,s,"create",{type:M.CREATE_LOCAL_TRANSFORM,tempId:s,data:n}),s}createShell(t,e){const s=this.getNextTempId(t),n=R.representationFromGeometry(e);return this.addRequest(t,s,"create",{type:M.CREATE_REPRESENTATION,tempId:s,data:n}),s}createCircleExtrusion(t,e){const s=R.bboxFromCircleExtrusion(e),n=this.getNextTempId(t);return this.addRequest(t,n,"create",{type:M.CREATE_REPRESENTATION,tempId:n,data:{representationClass:it.CIRCLE_EXTRUSION,bbox:s,geometry:e}}),n}createGlobalTransform(t,e,s){const n=this.getNextTempId(t),i=R.transformFromMatrix(e);return this.addRequest(t,n,"create",{type:M.CREATE_GLOBAL_TRANSFORM,tempId:n,data:{itemId:s,...i}}),n}createSample(t,e){const{localTransform:s,representation:n,material:i,globalTransform:r}=e,a=this.getNextTempId(t);return this.addRequest(t,a,"create",{type:M.CREATE_SAMPLE,tempId:a,data:{localTransform:s,representation:n,material:i,item:r}}),a}createItem(t,e){const s=this.getNextTempId(t);return this.addRequest(t,s,"create",{type:M.CREATE_ITEM,tempId:s,data:e}),s}setItem(t,e){const s=e._localId;if(!s)throw new Error("No local id provided for the item to set");const n=s.value,i=Dt.itemDataToRawItemData(e);this.addRequest(t,s.value,"update",{type:M.UPDATE_ITEM,localId:n,data:i})}async relate(t,e,s,n){const i=this._fragments.models.list.get(t);if(!i)throw new Error(`Model ${t} not found`);const a=(await i.getRelations([e])).get(e);if(!a){this.addRelationRequest(t,e,"create",{type:M.CREATE_RELATION,localId:e,data:{data:{[s]:n}}});return}if(!a.data[s])a.data[s]=n;else{const c=new Set(a.data[s]);for(const h of n)c.add(h);a.data[s]=Array.from(c)}this.addRelationRequest(t,e,"update",{type:M.UPDATE_RELATION,localId:e,data:a})}async unrelate(t,e,s,n){const i=this._fragments.models.list.get(t);if(!i)throw new Error(`Model ${t} not found`);const a=(await i.getRelations([e])).get(e);if(!a||!a.data[s])return;const c=new Set(a.data[s]);for(const h of n)c.delete(h);a.data[s]=Array.from(c),this.addRelationRequest(t,e,"update",{type:M.UPDATE_RELATION,localId:e,data:a})}async get(t,e){const s=this._fragments.models.list.get(t);if(!s)throw new Error(`Model ${t} not found`);return s._getElements(e)}async create(t,e){for(const a of e){const{attributes:c,samples:h,globalTransform:u}=a,l=this.getNextTempId(t),f=Dt.itemDataToRawItemData(c);this.addRequest(t,l,"create",{type:M.CREATE_ITEM,tempId:l,data:f});const p=this.createGlobalTransform(t,u,l);for(const d of h){const{localTransform:g,representation:y,material:E}=d;let w;typeof g!="number"&&typeof g!="string"?w=this.createLocalTransform(t,g):w=g;let I;typeof y!="number"&&typeof y!="string"?I=this.createShell(t,y):I=y;let v;typeof E!="number"&&typeof E!="string"?v=this.createMaterial(t,E):v=E,this.createSample(t,{localTransform:w,representation:I,material:v,globalTransform:p})}}const s=this.getRequests(t);if(!s)return console.log("Something went wrong, no requests sent"),null;const n=[];for(let a=0;a<s.length;a++)s[a].type===M.CREATE_ITEM&&n.push(a);const i=await this._fragments.editor.edit(t,s),r=n.map(a=>i[a]);return this.get(t,r)}delete(t,e){for(const s of e){s.delete();const n=s.getRequests();if(n)for(const i of n){const r=i.localId;r&&this.addRequest(t,r,"remove",i)}}}async applyChanges(t,e=[]){const s=[];for(const i of e){const r=i.getRequests();r&&s.push(...r)}const n=this.getRequests(t);return n&&s.push(...n),s.length>0?this._fragments.editor.edit(t,s):[]}async deleteData(t,e){const s=this._fragments.models.list.get(t);if(!s)throw new Error(`Model ${t} not found`);const n=e.filterInUse??!0,{itemIds:i,materialIds:r,localTransformIds:a,representationIds:c,sampleIds:h}=e,u=new Set,l=new Set,f=new Set,p=new Set;if(n){const d=await s.getSamples();for(const g of d.values())u.add(g.material),l.add(g.localTransform),f.add(g.item),p.add(g.representation)}if(r)for(const d of r){if(n&&u.has(d)){console.log(`Material ${d} is used, skipping`);continue}if(this.isBeingCreated(t,d)){delete this._requests[t].create[d];continue}this.addRequest(t,d,"remove",{type:M.DELETE_MATERIAL,localId:d})}if(a)for(const d of a){if(n&&l.has(d)){console.log(`Local transform ${d} is used, skipping`);continue}if(this.isBeingCreated(t,d)){delete this._requests[t].create[d];continue}this.addRequest(t,d,"remove",{type:M.DELETE_LOCAL_TRANSFORM,localId:d})}if(c)for(const d of c){if(n&&p.has(d)){console.log(`Representation ${d} is used, skipping`);continue}if(this.isBeingCreated(t,d)){delete this._requests[t].create[d];continue}this.addRequest(t,d,"remove",{type:M.DELETE_REPRESENTATION,localId:d})}if(h)for(const d of h){if(this.isBeingCreated(t,d)){delete this._requests[t].create[d];continue}this.addRequest(t,d,"remove",{type:M.DELETE_SAMPLE,localId:d})}if(i)for(const d of i){if(this.isBeingCreated(t,d)){delete this._requests[t].create[d];continue}this.addRequest(t,d,"remove",{type:M.DELETE_ITEM,localId:d})}}getNextTempId(t){return this._nextTempIds[t]||(this._nextTempIds[t]=0),(this._nextTempIds[t]++).toString()}addRelationRequest(t,e,s,n){const a=this.getModelRequests(t).relations[s],c=e;a[c]=n}addRequest(t,e,s,n){const r=this.getModelRequests(t)[s],a=e;r[a]=n}getModelRequests(t){return this._requests[t]||(this._requests[t]=this.newRequests()),this._requests[t]}isBeingCreated(t,e){return this._requests[t]?this._requests[t].create[e]!==void 0:!1}newRequests(){return{update:{},create:{},remove:{},relations:{create:{},update:{},remove:{}}}}}class ss{constructor(t,e){o(this,"onEdit",new H);o(this,"_editHelper");o(this,"_elementsHelper");this._editHelper=new ts(t,e),this._elementsHelper=new es(t)}async edit(t,e,s={removeRedo:!0}){const n=await this._editHelper.edit(t,e,s);return this.onEdit.trigger(),n}async save(t){return this._editHelper.save(t)}async reset(t){await this._editHelper.reset(t)}async getModelRequests(t){return this._editHelper.getRequests(t)}async selectRequest(t,e){return this._editHelper.selectRequest(t,e)}clearElementsRequests(t){return this._elementsHelper.getRequests(t)}createMaterial(t,e){return this._elementsHelper.createMaterial(t,e)}createLocalTransform(t,e){return this._elementsHelper.createLocalTransform(t,e)}createShell(t,e){return this._elementsHelper.createShell(t,e)}createCircleExtrusion(t,e){return this._elementsHelper.createCircleExtrusion(t,e)}createGlobalTransform(t,e,s){return this._elementsHelper.createGlobalTransform(t,e,s)}createSample(t,e){return this._elementsHelper.createSample(t,e)}createItem(t,e){return this._elementsHelper.createItem(t,e)}setItem(t,e){return this._elementsHelper.setItem(t,e)}async relate(t,e,s,n){return this._elementsHelper.relate(t,e,s,n)}async unrelate(t,e,s,n){return this._elementsHelper.unrelate(t,e,s,n)}async getElements(t,e){return this._elementsHelper.get(t,e)}async createElements(t,e){return this._elementsHelper.create(t,e)}deleteElements(t,e){return this._elementsHelper.delete(t,e)}async applyChanges(t,e=[]){return this._elementsHelper.applyChanges(t,e)}async deleteData(t,e){return this._elementsHelper.deleteData(t,e)}async _update(t){await this._editHelper._update(t)}}class ns{constructor(t,e,s){o(this,"localId");o(this,"model");o(this,"core");o(this,"config",{data:{attributesDefault:!0,relations:{IsDefinedBy:{attributes:!0,relations:!0},DefinesOcurrence:{attributes:!1,relations:!1}}}});o(this,"updateRequests",{});o(this,"createRequests",{});o(this,"removeRequests",{});o(this,"_elementChanged",!1);this.localId=t,this.core=e,this.model=s}get elementChanged(){return this._elementChanged}getRequests(){const t=Object.values(this.createRequests);this.createRequests={};const e=Object.values(this.updateRequests);this.updateRequests={};const s=Object.values(this.removeRequests);this.removeRequests={};const n=[...s,...t,...e];return n.length>0?n:null}delete(){this.createRequests[this.localId]?delete this.createRequests[this.localId]:this.removeRequests[this.localId]={type:M.DELETE_ITEM,localId:this.localId};for(const t in this.core.samples){const e=this.core.samples[t],s=parseInt(t,10);this.createRequests[e.localTransform]?delete this.createRequests[e.localTransform]:this.removeRequests[e.localTransform]={type:M.DELETE_LOCAL_TRANSFORM,localId:e.localTransform},this.createRequests[e.representation]?delete this.createRequests[e.representation]:this.removeRequests[e.representation]={type:M.DELETE_REPRESENTATION,localId:e.representation},this.createRequests[e.material]?delete this.createRequests[e.material]:this.removeRequests[e.material]={type:M.DELETE_MATERIAL,localId:e.material},this.createRequests[e.item]?delete this.createRequests[e.item]:this.removeRequests[e.item]={type:M.DELETE_GLOBAL_TRANSFORM,localId:e.item},this.createRequests[s]?delete this.createRequests[s]:this.removeRequests[s]={type:M.DELETE_SAMPLE,localId:s}}}async getData(){return(await this.model.getItemsData([this.localId],this.config.data))[0]}getGlobalTransformId(){return parseInt(Object.keys(this.core.globalTransforms)[0],10)}disposeMeshes(t,e){const s=(e==null?void 0:e.disposeGeometry)??!0,n=(e==null?void 0:e.disposeMaterial)??!0;t.removeFromParent(),t.traverse(i=>{i instanceof X&&(s&&i.geometry.dispose(),n&&i.material.dispose())})}async getMeshes(){const t=new J,e=Object.values(this.core.globalTransforms)[0],s=R.matrixFromTransform(e);t.applyMatrix4(s);const n=new Map,i=new Map,r=Object.keys(this.core.representations).map(Number),a=await this.model.getGeometries(r),c=new Map;for(const h of a){const u=h.representationId;c.set(u,h)}for(const h in this.core.samples){const u=parseInt(h,10),l=this.core.samples[u],f=c.get(l.representation);if(!f)throw new Error(`No geometry found for representation ${l.representation}`);const{indices:p,positions:d,normals:g}=f;if(!p||!d||!g)continue;if(!n.has(l.material)){const{r:x,g:O,b:S,a:B}=this.core.materials[l.material],A=new Ct().setRGB(x/255,O/255,S/255,te),U=new ee({color:A,transparent:!0,opacity:B/255});U.userData.localId=l.material,n.set(l.material,U)}const y=n.get(l.material),E=this.core.localTransforms[l.localTransform],w=R.matrixFromTransform(E);if(!i.has(l.representation)){const x=new ut;x.setIndex(Array.from(p)),x.setAttribute("position",new Y(d,3)),x.setAttribute("normal",new Y(g,3)),x.userData.localId=l.representation,i.set(l.representation,x)}const I=i.get(l.representation),v=new J;v.userData.localId=l.localTransform,t.add(v),v.applyMatrix4(w);const q=new X(I,y);q.userData.sampleId=u,v.add(q)}return t}async setMeshes(t){const e=await this.getMeshes();let s=!0;t.updateMatrix();const n=1e3;for(let l=0;l<t.matrix.elements.length;l++){const f=Math.trunc(t.matrix.elements[l]*n)/n,p=Math.trunc(e.matrix.elements[l]*n)/n;if(f!==p){s=!1;break}}if(!s){const l=parseInt(Object.keys(this.core.globalTransforms)[0],10),f=this.core.globalTransforms[l];R.transformFromMatrix(t.matrix,f),this._elementChanged=!0,this.updateRequests[l]={type:M.UPDATE_GLOBAL_TRANSFORM,localId:l,data:f}}const i=new Map,r=new Map;e.traverse(l=>{l instanceof X&&i.set(l.material.userData.localId,l.material)}),t.traverse(l=>{l instanceof X&&r.set(l.material.userData.localId,l.material)});for(const[l,f]of i){const p=r.get(l);if(!p)continue;const d=f.color.r,g=f.color.g,y=f.color.b,E=f.opacity,w=p.color.r,I=p.color.g,v=p.color.b,q=p.opacity,x=this.core.materials[l];x.r=w*255,x.g=I*255,x.b=v*255,x.a=q*255,(d!==w||g!==I||y!==v||E!==q)&&(this._elementChanged=!0,this.updateRequests[l]={type:M.UPDATE_MATERIAL,localId:l,data:x})}i.clear(),r.clear();const a=new Map,c=new Map;for(const l of t.children)l.updateMatrix(),c.set(l.userData.localId,l.matrix);for(const l of e.children)a.set(l.userData.localId,l.matrix);for(const[l,f]of a){const p=c.get(l);if(p&&!f.equals(p)){const d=this.core.localTransforms[l];R.transformFromMatrix(p,d),this._elementChanged=!0,this.updateRequests[l]={type:M.UPDATE_LOCAL_TRANSFORM,localId:l,data:d}}}a.clear(),c.clear();const h=new Map,u=new Map;t.traverse(l=>{if(l instanceof X){const f=l.geometry;u.set(f.userData.localId,f)}}),e.traverse(l=>{if(l instanceof X){const f=l.geometry;h.set(f.userData.localId,f)}});for(const[l,f]of h){const p=this.core.representations[l];if(p.representationClass===it.CIRCLE_EXTRUSION)continue;const d=u.get(l);if(!d)continue;let g=!0;const y=f.getAttribute("position"),E=d.getAttribute("position");if(y&&E)if(y.count===E.count){for(let w=0;w<y.array.length;w++)if(y.array[w]!==E.array[w]){g=!1;break}}else g=!1;g||(R.representationFromGeometry(d,p),this._elementChanged=!0,this.updateRequests[l]={type:M.UPDATE_REPRESENTATION,localId:l,data:p})}}createSamples(t){for(const e of t){const s=Math.trunc(performance.now());this.core.samples[s]=e,this.createRequests[s]={type:M.CREATE_SAMPLE,data:e}}}deleteSamples(t){this._elementChanged=!0;for(const e of t)Object.keys(this.core.samples).length!==1&&(delete this.core.samples[e],delete this.updateRequests[e],this.createRequests[e]?delete this.createRequests[e]:this.removeRequests[e]={type:M.DELETE_SAMPLE,localId:e})}async updateSamples(){const t=new Set(Object.keys(this.core.materials).map(Number)),e=new Set(Object.keys(this.core.localTransforms).map(Number)),s=new Set(Object.keys(this.core.globalTransforms).map(Number)),n=new Set(Object.keys(this.core.representations).map(Number)),i=new Set,r=new Set,a=new Set,c=new Set,h=new Set;for(const d in this.core.samples){const g=parseInt(d,10),y=this.core.samples[g];t.delete(y.material),s.delete(y.item),e.delete(y.localTransform),n.delete(y.representation),this.core.materials[y.material]||(h.add(g),i.add(y.material)),this.core.globalTransforms[y.item]||(h.add(g),r.add(y.item)),this.core.localTransforms[y.localTransform]||(h.add(g),a.add(y.localTransform)),this.core.representations[y.representation]||(h.add(g),c.add(y.representation))}for(const d of t)delete this.core.materials[d];for(const d of s)delete this.core.globalTransforms[d];for(const d of e)delete this.core.localTransforms[d];for(const d of n)delete this.core.representations[d];let u=new Map;i.size&&(u=await this.model.getMaterials(i));let l=new Map;r.size&&(l=await this.model.getGlobalTransforms(r));let f=new Map;a.size&&(f=await this.model.getLocalTransforms(a));let p=new Map;c.size&&(p=await this.model.getRepresentations(c));for(const[d,g]of u)this.core.materials[d]=g;for(const[d,g]of l)this.core.globalTransforms[d]=g;for(const[d,g]of f)this.core.localTransforms[d]=g;for(const[d,g]of p)this.core.representations[d]=g;for(const d of h){if(this.createRequests[d]){const g=this.createRequests[d];g.data=this.core.samples[d];continue}this._elementChanged=!0,this.updateRequests[d]={type:M.UPDATE_SAMPLE,localId:d,data:this.core.samples[d]}}}}class is{async edit(t,e){return t.threads.invoke(t.modelId,"edit",[e])}async reset(t){return t.threads.invoke(t.modelId,"reset",[])}async save(t){return t.threads.invoke(t.modelId,"save",[])}async getItemsGeometry(t,e,s){const n=await t.threads.invoke(t.modelId,"getItemsGeometry",[e,s]),i=t.deltaModelId;if(!i)return n;const r=await t.threads.invoke(i,"getItemsGeometry",[e]),a=new Map;for(const c of n){const h=c[0].localId;a.set(h,c)}for(const c of r){const h=c[0].localId;a.set(h,c)}return Array.from(a.values())}async getGeometries(t,e){const s=await t.threads.invoke(t.modelId,"getGeometries",[e]),n=t.deltaModelId;if(!n)return s;const i=await t.threads.invoke(n,"getGeometries",[e]),r=new Map;for(const a of s){const c=a.representationId;r.set(c,a)}for(const a of i){const c=a.representationId;r.set(c,a)}return Array.from(r.values())}async getMaterialsIds(t){return t.threads.invoke(t.modelId,"getMaterialsIds",[])}async getMaterials(t,e){return t.threads.invoke(t.modelId,"getMaterials",[e])}async getSamplesIds(t){return t.threads.invoke(t.modelId,"getSamplesIds",[])}async getSamples(t,e){return t.threads.invoke(t.modelId,"getSamples",[e])}async getRepresentationsIds(t){return t.threads.invoke(t.modelId,"getRepresentationsIds",[])}async getRepresentations(t,e){return t.threads.invoke(t.modelId,"getRepresentations",[e])}async getLocalTransformsIds(t){return t.threads.invoke(t.modelId,"getLocalTransformsIds",[])}async getLocalTransforms(t,e){return t.threads.invoke(t.modelId,"getLocalTransforms",[e])}async getGlobalTransformsIds(t){return t.threads.invoke(t.modelId,"getGlobalTransformsIds",[])}async getGlobalTransforms(t,e){return t.threads.invoke(t.modelId,"getGlobalTransforms",[e])}async getItemsIds(t){return t.threads.invoke(t.modelId,"getItemsIds",[])}async getItems(t,e){return t.threads.invoke(t.modelId,"getItems",[e])}async getRelations(t,e){return t.threads.invoke(t.modelId,"getRelations",[e])}async getGlobalTranformsIdsOfItems(t,e){return await t.threads.invoke(t.modelId,"getGlobalTranformsIdsOfItems",[e])}async getEditedElements(t){return t.deltaModelId?t.threads.invoke(t.deltaModelId,"getItemsWithGeometry",[]):[]}async getElements(t,e){const s=await t.threads.invoke(t.modelId,"getElementsData",[e]);if(t.deltaModelId){const i=await t.threads.invoke(t.deltaModelId,"getElementsData",[e]);for(const r in i)s[r]=i[r]}const n=[];for(const i in s){const r=new ns(Number(i),s[i],t);n.push(r)}return n}async getRequests(t){return t.threads.invoke(t.modelId,"getRequests",[])}async setRequests(t,e){return t.threads.invoke(t.modelId,"setRequests",[e])}async selectRequest(t,e){return t.threads.invoke(t.modelId,"selectRequest",[e])}}class rs{constructor(t){o(this,"model");o(this,"_grids",new J);o(this,"_gridMaterial",new Ie({color:16777215,linewidth:5,depthTest:!1,dashSize:1,gapSize:.3}));this.model=t}async getGrids(){return this._grids.children.length||await this.constructGrids(),this._grids}async constructGrids(){const t=await this.model.threads.invoke(this.model.modelId,"getGrids"),e=new Q;for(const s of t){const n=new J;this._grids.add(n),n.userData.id=s.id,e.fromArray(s.transform),n.applyMatrix4(e),this.getGridAxis(s,n,"uAxes"),this.getGridAxis(s,n,"vAxes"),this.getGridAxis(s,n,"wAxes"),this._grids.add(n)}}getGridAxis(t,e,s){for(const{curve:n,tag:i}of t[s]){const[r,a,c,h]=n,u=new ut;u.setAttribute("position",new Y(new Float32Array([r,a,0,c,h,0]),3));const l=new ve(u,this._gridMaterial);l.userData.tag=i,l.computeLineDistances(),l.renderOrder=1,e.add(l)}}dispose(){this._grids.removeFromParent();for(const t of this._grids.children){const e=t;e.geometry.dispose(),e.geometry=void 0,e.material=void 0}this._gridMaterial.dispose(),this._gridMaterial=void 0}}const dt=class dt{constructor(t,e,s,n){o(this,"attrsChanges",new Map);o(this,"relsChanges",new Map);o(this,"threads");o(this,"tiles",new Bt);o(this,"object",new Me);o(this,"graphicsQuality",0);o(this,"deltaModelId",null);o(this,"_boxManager",new Oe);o(this,"_itemsManager",new He);o(this,"_coordinatesManager",new Ge);o(this,"_setupManager",new Fe);o(this,"_viewManager",new ke);o(this,"_raycastManager",new We);o(this,"_visibilityManager",new $e);o(this,"_highlightManager",new Qe);o(this,"_sectionManager",new Ze);o(this,"_dataManager",new Ke);o(this,"_sequenceManager",new Je);o(this,"_bbox",new Z);o(this,"_alignmentsManager");o(this,"_gridsManager");o(this,"_meshManager");o(this,"_editManager",new is);o(this,"_editor");o(this,"_isProcessing",!1);o(this,"_isLoaded",!1);o(this,"_frozen",!1);o(this,"_isSetup",!1);o(this,"_parentModelId",null);this.object.name=t,this.object.up.set(0,0,1),this._meshManager=e,this.threads=s,this._editor=n,this._alignmentsManager=new ze(this),this._gridsManager=new rs(this),this.tiles.onItemSet.add(({value:i})=>this.object.add(i)),this.tiles.onBeforeDelete.add(({value:i})=>{this.object.remove(i),i.geometry.dispose(),be.forEach(i.material,r=>r.dispose())})}get modelId(){return this.object.name}get box(){return this._bbox.clone().applyMatrix4(this.object.matrixWorld)}get isBusy(){const t=this._meshManager.requests.arePending;return!this._isLoaded||this._isProcessing||t}get frozen(){return!!this._frozen}set frozen(t){t!==this._frozen&&(this._frozen=t,!t&&this._refreshView())}get getClippingPlanesEvent(){return this._viewManager.getClippingPlanesEvent}set getClippingPlanesEvent(t){this._viewManager.getClippingPlanesEvent=t}get camera(){return this._viewManager.currentCamera}get isDeltaModel(){return this.object.userData[dt._deltaModelId]}get parentModelId(){return this._parentModelId}async dispose(){this._isLoaded=!1,await this._dataManager.dispose(this,this._meshManager,this._alignmentsManager,this._gridsManager)}async getSpatialStructure(){return this._dataManager.getSpatialStructure(this)}async getLocalIdsByGuids(t){return this._dataManager.getLocalIdsByGuids(this,t)}async getCategories(){return this._dataManager.getCategories(this)}async getItemsWithGeometryCategories(){return this._dataManager.getItemsWithGeometryCategories(this)}async getItemsWithGeometry(){return this._dataManager.getItemsWithGeometry(this)}async getItemsIdsWithGeometry(){return this._dataManager.getItemsIdsWithGeometry(this)}async getMetadata(){return this._dataManager.getMetadata(this)}async getGuidsByLocalIds(t){return this._dataManager.getGuidsByLocalIds(this,t)}async getBuffer(t=!1){return this._dataManager.getBuffer(this,t)}async getItemsOfCategories(t){return this._dataManager.getItemsOfCategories(this,t)}async getGuids(){return await this.threads.invoke(this.modelId,"getGuids",[])}async getLocalIds(){return await this.threads.invoke(this.modelId,"getLocalIds",[])}async getItemsByQuery(t,e){return this._dataManager.getItemsByQuery(this,t,e)}async getItemsMaterialDefinition(t){return await this.threads.invoke(this.modelId,"getItemsMaterialDefinition",[t])}async getItemsGeometry(t,e=xt.GEOMETRY){return this._editManager.getItemsGeometry(this,t,e)}async getGeometries(t){return this._editManager.getGeometries(this,t)}async getItemsVolume(t){return await this.threads.invoke(this.modelId,"getItemsVolume",[t])}async getAttributeNames(){return await this.threads.invoke(this.modelId,"getAttributeNames",[])}async getAttributeValues(){return await this.threads.invoke(this.modelId,"getAttributeValues",[])}async getAttributesUniqueValues(t){return await this.threads.invoke(this.modelId,"getAttributesUniqueValues",[t])}async getAttributeTypes(){return await this.threads.invoke(this.modelId,"getAttributeTypes",[])}async getRelationNames(){return await this.threads.invoke(this.modelId,"getRelationNames",[])}async getMaxLocalId(){return this._dataManager.getMaxLocalId(this)}getItem(t){return this._itemsManager.getItem(this,t)}async getItemsChildren(t){return this._itemsManager.getItemsChildren(this,t)}async getItemsData(t,e){return this._itemsManager.getItemsData(this,t,e)}async getPositions(t){return this._coordinatesManager.getPositions(this,t)}async getCoordinates(){return this._coordinatesManager.getCoordinates(this)}async getCoordinationMatrix(){return this._coordinatesManager.getCoordinationMatrix(this)}async getMergedBox(t){return this._boxManager.getMergedBox(this,t)}async getBoxes(t){return this._boxManager.getBoxes(this,t)}async getAlignments(){return this._alignmentsManager.getAlignments()}async getHorizontalAlignments(){return this._alignmentsManager.getHorizontalAlignments()}async getVerticalAlignments(){return this._alignmentsManager.getVerticalAlignments()}getAlignmentStyles(){return this._alignmentsManager.getAlignmentStyles()}async getGrids(){return this._gridsManager.getGrids()}useCamera(t){this._viewManager.useCamera(t)}async setLodMode(t){return this._viewManager.setLodMode(this,t)}async rectangleRaycast(t){return this._raycastManager.rectangleRaycast(this,this._meshManager,t)}async raycast(t){return this._raycastManager.raycast(this,t)}async raycastAll(t){return this._raycastManager.raycastAll(this,t)}async raycastWithSnapping(t){return this._raycastManager.raycastWithSnapping(this,t)}async setVisible(t,e){const s=[t,e];await this.threads.invoke(this.modelId,"setVisible",s)}async toggleVisible(t){const e=[t];await this.threads.invoke(this.modelId,"toggleVisible",e)}async getItemsByVisibility(t){return this._visibilityManager.getItemsByVisibility(this,t)}async getVisible(t){return this._visibilityManager.getVisible(this,t)}async resetVisible(){return this._visibilityManager.resetVisible(this)}async highlight(t,e){return this._highlightManager.highlight(this,t,e)}async setColor(t,e){return this._highlightManager.setColor(this,t,e)}async resetColor(t){return this._highlightManager.resetColor(this,t)}async setOpacity(t,e){return this._highlightManager.setOpacity(this,t,e)}async resetOpacity(t){return this._highlightManager.resetOpacity(this,t)}async getHighlight(t){return this._highlightManager.getHighlight(this,t)}async resetHighlight(t){return this._highlightManager.resetHighlight(this,t)}async getHighlightItemIds(){return this._highlightManager.getHighlightItemIds(this)}async getSection(t,e){return this._sectionManager.getSection(this,t,e)}async getMaterialsIds(){return this._editManager.getMaterialsIds(this)}async getMaterials(t){return this._editManager.getMaterials(this,t)}async getRepresentationsIds(){return this._editManager.getRepresentationsIds(this)}async getRepresentations(t){return this._editManager.getRepresentations(this,t)}async getLocalTransformsIds(){return this._editManager.getLocalTransformsIds(this)}async getLocalTransforms(t){return this._editManager.getLocalTransforms(this,t)}async getGlobalTransformsIds(){return this._editManager.getGlobalTransformsIds(this)}async getGlobalTransforms(t){return this._editManager.getGlobalTransforms(this,t)}async getSamplesIds(){return this._editManager.getSamplesIds(this)}async getSamples(t){return this._editManager.getSamples(this,t)}async getItemsIds(){return this._editManager.getItemsIds(this)}async getItems(t){return this._editManager.getItems(this,t)}async getRelations(t){return this._editManager.getRelations(this,t)}async getGlobalTranformsIdsOfItems(t){return this._editManager.getGlobalTranformsIdsOfItems(this,t)}async getEditedElements(){return this._editManager.getEditedElements(this)}async getSequenced(t,e,s){return this._sequenceManager.getSequenced(this,t,e,s)}async handleRequest(t){await this._meshManager.requests.handleRequest(this._meshManager,t)}async _getElements(t){return this._editManager.getElements(this,t)}_finishProcessing(){this._isProcessing=!1}_setDeltaModel(t){this.object.userData[dt._deltaModelId]=!0,this._parentModelId=t}async _refreshView(){if(this.frozen)return;this._isProcessing=!0;const t=this._viewManager.refreshView(this,this._meshManager),e=this._editor._update(this.modelId);await Promise.all([t,e])}async _setup(t,e,s){this._isSetup||(await this._setupManager.setup(this,this._bbox,t,e,s),this._isLoaded=!0,this._isProcessing=!0,this._isSetup=!0)}async _edit(t){return this._editManager.edit(this,t)}async _reset(){return this._editManager.reset(this)}async _save(){return this._editManager.save(this)}async _getRequests(){return this._editManager.getRequests(this)}async _setRequests(t){return this._editManager.setRequests(this,t)}async _selectRequest(t){return this._editManager.selectRequest(this,t)}};o(dt,"_deltaModelId","isDeltaModel");let vt=dt;class as{constructor(){o(this,"list",[]);o(this,"onFinish",()=>{})}get arePending(){return this.list.length>0}async handleRequest(t,e){if(e.class===W.RECOMPUTE_MESHES)this.add(e.list),e.list=void 0;else if(e.class===W.CREATE_MATERIAL){const{materialDefinitions:s,modelId:n}=e;zt.resetColors(s),t.materials.addDefinitions(n,s),e.materialDefinitions=void 0}else e.class===W.THROW_ERROR&&console.error(e)}add(t){for(const e of t)this.insert(e)||this.list.push(e),e.tileRequestClass===L.FINISH&&this.onFinish()}clean(t){const e=this.list.filter(s=>s.modelId!==t||s.tileRequestClass!==L.FINISH);this.list=e}insert(t){const{modelId:e,tileId:s,tileRequestClass:n,tileData:i}=t;if(s===void 0)return!1;if(n===L.DELETE){const r=this.list.filter(a=>!((a.tileRequestClass===L.CREATE||a.tileRequestClass===L.DELETE)&&a.modelId===e&&a.tileId===s));this.list=r}if(n===L.CREATE){const r=this.list.filter(a=>!(a.tileRequestClass===L.CREATE&&a.modelId===e&&a.tileId===s));this.list=r}if(n===L.UPDATE){const r=this.list.find(a=>a.modelId===e&&a.tileId===s);if(r)return(r.tileRequestClass===L.CREATE||r.tileRequestClass===L.UPDATE)&&(r.tileData=i),!0}return!1}}class os{constructor(t){o(this,"_materials");o(this,"white",4294967295);this._materials=t}createMesh(t,e){const s=this._materials.getFromRequest(e);if(!("isLodMaterial"in s&&s.isLodMaterial))throw new Error("Fragments: material is not an instance of LodMaterial.");const{positions:n}=e;if(!n)throw new Error("Fragments: no positions provided to create the LOD mesh.");const i=new Xe,r=this.deleteAttributeEvent(t);return N.setLodBuffer(i,n,r),new $t(i,[s])}updateVisibility(t,e){const{geometry:s}=t,{visibilityData:n,highlightData:i}=e;N.setLodVisibility(s,n),i?(N.setLodFilter(s,i),qt.getComplementary(i,(r,a)=>{s.addGroup(r,a,0)})):s.addGroup(0,1/0,0)}processMesh(t,e){const{geometry:s}=t,{tileData:{visibilityData:n},currentLod:i}=e;if(i===xt.WIRES&&t instanceof $t)this.updateVisibility(t,e.tileData);else if(n&&n.position.length>0)for(let r=0;r<n.position.length;++r){const a=n.size[r]===this.white,c=n.position[r],h=a?1/0:n.size[r];s.addGroup(c,h,0)}}deleteAttributeEvent(t){function e(){delete this.array}return e}}class ls{constructor(t){o(this,"list",new Bt);o(this,"materials",new zt);o(this,"lod",new os(this.materials));o(this,"requests",new as);o(this,"updateThreshold",4);o(this,"_updateFinished",!0);o(this,"_onUpdate");this._onUpdate=t,this.requests.onFinish=()=>this._updateFinished=!0}async forceUpdateFinish(t=200,e=500){let s=!1;for(;!s;)await new Promise(n=>{this._updateFinished=!1;const i=setInterval(()=>{this.update(),this._updateFinished&&(clearInterval(i),n())},t)}),await new Promise(n=>{setTimeout(n,e)}),s=this._updateFinished}update(){const t=performance.now();for(;this.requests.arePending;){const e=this.requests.list.shift();if(e&&(this.processTileRequest(e),this._onUpdate(),performance.now()-t>this.updateThreshold))return}}setTileData(t,e){const{tileId:s,itemId:n,matrix:i,aabb:r}=e;this.setMeshData(t,s,n,i),this.setupBoundings(t,r),this.updateStatus(t,e)}processTileRequest(t){const{tileRequestClass:e,tileId:s,modelId:n}=t,i=this.list.get(n);if(i)if(e===L.CREATE){if(t.objectClass===void 0)return;const r=this.create(t);this.setTileData(r,t),i.tiles.set(r.userData.tileId,r)}else if(e===L.DELETE)i.tiles.delete(s);else if(e===L.UPDATE){const r=i.tiles.get(s);r&&this.updateStatus(r,t)}else e===L.FINISH&&i._finishProcessing()}createMesh(t){const{indices:e,positions:s,normals:n,itemIds:i,faceIds:r}=t,a=new ut;this.setIndex(a,e),this.setPositions(s,a),this.setNormals(n,a),this.setItemIds(i,a),this.setFaceIds(r,a);const c=this.materials.getFromRequest(t);return new X(a,[c])}setupBoundings(t,e){const{geometry:s}=t,n=new Z().copy(e),i=new bt;n.getBoundingSphere(i),s.boundingBox=n,s.boundingSphere=i}create(t){if(t.objectClass===It.SHELL)return this.createMesh(t);if(t.objectClass===It.LINE){const e=new ut;return this.lod.createMesh(e,t)}throw new Error(`Fragments: object class ${t.objectClass} is not supported.`)}updateStatus(t,e){const{tileData:{highlightData:s},currentLod:n}=e,{geometry:i}=t;if(i.clearGroups(),this.lod.processMesh(t,e),!(s&&n!==xt.WIRES))return;const r=this.materials.createHighlights(t,e);t.material=r}cleanAttributeMemory(t,e){t.attributes[e].onUpload(this.deleteAttribute(t))}setPositions(t,e){if(!t)throw new Error("Fragments: no positions provided to create the mesh.");e.setAttribute("position",new Y(t,3)),this.cleanAttributeMemory(e,"position")}setFaceIds(t,e){t&&(e.setAttribute("color",new Y(t,3)),this.cleanAttributeMemory(e,"color"))}setIndex(t,e){if(!e)throw new Error("Fragments: no indices provided to create the mesh.");t.setIndex(new Y(e,1)),t.index.onUpload(this.deleteAttribute(t))}setNormals(t,e){t&&e.setAttribute("normal",new Y(t,3,!0)),this.cleanAttributeMemory(e,"normal")}setItemIds(t,e){t&&(e.setAttribute("id",new Y(t,1,!1)),this.cleanAttributeMemory(e,"id"))}deleteAttribute(t){function e(){delete this.array}return e}setMeshData(t,e,s,n){t.userData={tileId:e,itemId:s},t.matrixAutoUpdate=!1,t.applyMatrix4(n),t.matrix.copy(n)}}class cs{constructor(){o(this,"_list",new Map);o(this,"_communicationKey",0)}setupInput(t){t.requestId=this._communicationKey++}set(t,e,s){const n=this.newHandler(e,s);this._list.set(t,n)}run(t){const e=this._list.get(t.requestId);this._list.delete(t.requestId),e(t)}newHandler(t,e){return s=>{if(s.errorInfo){t(s.errorInfo);return}e(s)}}}class F{static newThread(t){return new Worker(t,{type:"module"})}static newUpdater(t,e){return setInterval(t,e)}static getMeshComputeRequest(t,e){return{class:W.RECOMPUTE_MESHES,modelId:t,list:e}}static planeSet(t){const e=[];for(const s of t){const n=this.array(s.normal),i=s.constant,r=new $(n,i);e.push(r)}return e}static data(t){var g,y;if((t==null?void 0:t.elements)!==void 0)return F.transform(t);if((t==null?void 0:t.origin)!==void 0&&(t==null?void 0:t.direction)!==void 0)return F.beam(t);if((t==null?void 0:t.planes)!==void 0)return F.frustum(t);const i=(t==null?void 0:t.normal)!==void 0,r=(t==null?void 0:t.constant)!==void 0;if(i&&r)return F.plane(t);const c=((g=t[0])==null?void 0:g.normal)!==void 0,h=((y=t[0])==null?void 0:y.constant)!==void 0;if(c&&h)return F.planeSet(t);const l=(t==null?void 0:t.x)!==void 0,f=(t==null?void 0:t.y)!==void 0,p=(t==null?void 0:t.z)!==void 0;return l&&f&&p?F.array(t):t}static getExecuteRequest(t,e,s){const n=Array.from(s);return{class:W.EXECUTE,modelId:t,function:e,parameters:n}}static plane(t){const e=this.array(t.normal),s=t.constant;return new $(e,s)}static getRequestContent(t){const e=[];for(const s of t.list)F.setupCreateRequest(s,e),F.setupUpdateRequest(s,e);return e}static array(t){const e=new _;return e.set(t.x,t.y,t.z),e}static cleanRequests(t){const e=[],s=F;for(const n of t)s.isFinishRequest(n)||e.push(n);return e}static frustum(t){const e=this.planeSet(t.planes),[s,n,i,r,a,c]=e;return new ht(s,n,i,r,a,c)}static beam(t){const e=this.array(t.origin),s=this.array(t.direction);return new Jt(e,s)}static transform(t){const e=new Q;return e.copy(t),e}static deleteUpdater(t){clearInterval(t)}static areCoresAvailable(t){const e=F.getCpuCapacity(),s=Math.max(e,2);return t<s}static isFinishRequest(t){return t.tileRequestClass===L.FINISH}static setupUpdateRequest(t,e){t.tileRequestClass===L.UPDATE&&this.addAllTileData(t,e)}static getCpuCapacity(){var e;return(e=globalThis.navigator)!=null&&e.hardwareConcurrency?navigator.hardwareConcurrency-3:0}static addAllTileData(t,e){this.addRequestTileData(t,e,"visibilityData");const s=["highlightIds"];this.addRequestTileData(t,e,"highlightData",s)}static addRequestContent(t,e,s){if(!e[t])return;const n=e[t].buffer;s.push(n)}static addRequestTileData(t,e,s,n=[]){const i=t.tileData[s];if(i){e.push(i.position.buffer),e.push(i.size.buffer);for(const r of n)e.push(t.tileData[r].buffer)}}static setupCreateRequest(t,e){if(t.tileRequestClass!==L.CREATE)return;const s=this.getCreateRequestIds();for(const n of s)this.addRequestContent(n,t,e);this.addAllTileData(t,e)}static getCreateRequestIds(){return["positions","indices","normals","itemIds"]}}class ds{constructor(t){o(this,"_handlers",new cs);o(this,"_handleInput");o(this,"_port");o(this,"onInput",t=>{if(t.data.toMainThread){this._handlers.run(t.data);return}this.manageInput(t.data)});this._handleInput=t}fetchMeshCompute(t,e){const s=F,n=s.getMeshComputeRequest(t,e),i=s.getRequestContent(n);this.fetch(n,i)}fetch(t,e){return this._handlers.setupInput(t),new Promise((s,n)=>{this._handlers.set(t.requestId,n,s),this.executeConnection(t,e)})}init(t){this._port=t,this.initConnection(t)}initConnection(t){t.onmessage=this.onInput}async fetchConnection(t){if(!this._port)throw new Error("Fragments: Connection not initialized");return this._port}async executeConnection(t,e){(await this.fetchConnection(t)).postMessage(t,e)}async manageOutput(t){const e=await this.fetchConnection(t);t.toMainThread=!0,e.postMessage(t)}async manageConnection(t){try{await this._handleInput(t)}catch(e){t.errorInfo=e.toString(),console.error(e)}}async manageInput(t){await this.manageConnection(t),await this.manageOutput(t)}}class hs{constructor(t){o(this,"_modelThread",new Map);o(this,"_threadsModelAmount",new Map);o(this,"_threadPort",new Map);o(this,"_threadPath");o(this,"_placeholder");this._placeholder={},this._threadPath=t}get path(){return this._threadPath}usePlaceholder(t){this._modelThread.set(t,this._placeholder)}getAmount(t){return this._threadsModelAmount.get(t)}getThread(t){return this._modelThread.get(t)}getAndCheckThread(t){const e=this._modelThread.get(t);if(e===this._placeholder)throw new Error("Fragments: Error fetching thread!");return e}set(t,e){this._modelThread.set(t,e)}deleteModel(t){const e=this.getThreadSafe(t),n=this.getAmountSafe(e)-1;this.setAmount(e,n),this._modelThread.delete(t)}getThreadSafe(t){const e=this.getThread(t);if(!e)throw new Error(`Fragments: Thread for model ${t} not found`);return e}deleteThread(t){this._threadsModelAmount.delete(t),this._threadPort.delete(t),t.terminate()}getThreadAmount(){return this._threadsModelAmount.size}balanceThreadLoad(t){const{lessBusyThread:e,modelAmount:s}=this.getLessBusyThread();return this._threadsModelAmount.set(e,s+1),this._modelThread.set(t.modelId,e),this._threadPort.get(e)}getAmountSafe(t){const e=this.getAmount(t);if(!e)throw new Error(`Fragments: Amount for thread ${t} not found`);return e}setPort(t,e){this._threadPort.set(t,e)}setAmount(t,e){this._threadsModelAmount.set(t,e)}getPort(t){return this._threadPort.get(t)}getLessBusyThread(){let t=Number.MAX_VALUE,e=this._threadsModelAmount.keys().next().value;for(const[s,n]of this._threadsModelAmount)n<t&&(t=n,e=s);return{lessBusyThread:e,modelAmount:t}}}class us extends ds{constructor(e,s){super(e);o(this,"_data");this._data=new hs(s)}delete(e){const s=this._data.getThreadSafe(e),n=this._data.getAmountSafe(s)-1;this._data.deleteModel(e),n===0&&this._data.deleteThread(s)}async invoke(e,s,n=[]){const r=F.getExecuteRequest(e,s,n);return(await this.fetch(r)).result}async fetchConnection(e){const s=this._data.getAndCheckThread(e.modelId);return s?this._data.getPort(s):this.setupNewThread(e)}setupNewThread(e){const s=F;this._data.usePlaceholder(e.modelId);const n=this._data.getThreadAmount();return s.areCoresAvailable(n)?this.newThread(e,this._data.path):this._data.balanceThreadLoad(e)}setupThread(e){const s=new MessageChannel,n=s.port1,i=s.port2;this.initConnection(n),this._data.setPort(e,n),e.postMessage(i,[i])}newThread(e,s){const n=F.newThread(s);return this.setupThread(n),this._data.setAmount(n,1),this._data.set(e.modelId,n),this._data.getPort(n)}}class ms{constructor(t){o(this,"onModelLoaded",new H);o(this,"models");o(this,"settings",{autoCoordinate:!0,maxUpdateRate:100,graphicsQuality:0,forceUpdateRate:200,forceUpdateBuffer:200});o(this,"baseCoordinates",null);o(this,"editor");o(this,"_connection");o(this,"_isDisposed",!1);o(this,"_autoRedrawInterval",null);o(this,"_lastUpdate",0);const e=this.newRequestEvent(),s=this.newUpdateEvent();this._connection=new us(e,t),this.editor=new ss(this,this._connection),this.models=new ls(s),this.models.list.onItemDeleted.add(()=>{this.models.list.size===0&&(this.baseCoordinates=null)})}async load(t,e){const s=new vt(e.modelId,this.models,this._connection,this.editor);e.userData&&(s.object.userData=e.userData),s.frozen=!0,s.graphicsQuality=this.settings.graphicsQuality;try{if(this.models.list.set(s.modelId,s),await s._setup(t,e.raw,e.virtualModelConfig),this.settings.autoCoordinate){const i=await s.getCoordinates();if(this.baseCoordinates===null)this.baseCoordinates=i;else{const[r,a,c]=i,[h,u,l]=this.baseCoordinates,f=new _(h-r,u-a,l-c);s.object.position.add(f)}}}catch(i){throw this.models.list.delete(s.modelId),i}const{camera:n}=e;return n&&s.useCamera(n),s.frozen=!1,this.onModelLoaded.trigger(s),s}async dispose(){this._isDisposed=!0;const t=Array.from(this.models.list.values()),e=[];for(const s of t)e.push(s.dispose());await Promise.all(e),this.onModelLoaded.reset()}async disposeModel(t){const e=this.models.list.get(t);e&&await e.dispose()}async update(t=!1){if(this._isDisposed)return;const e=performance.now();if(e-this._lastUpdate<this.settings.maxUpdateRate)return;this._lastUpdate=e;const s=[];for(const n of this.models.list.values())s.push(n._refreshView());await Promise.all(s),t?await this.models.forceUpdateFinish(this.settings.forceUpdateRate,this.settings.forceUpdateBuffer):this.models.update()}async manageRequest(t){const e=this.models.list.get(t.modelId);e&&await e.handleRequest(t)}newUpdateEvent(){return()=>{this._autoRedrawInterval&&clearTimeout(this._autoRedrawInterval);const t=this.settings.maxUpdateRate+1;this._autoRedrawInterval=setTimeout(()=>{this.update()},t)}}newRequestEvent(){return t=>{this.manageRequest(t)}}}export{H as E,ms as F,R as G};
