var N=Object.defineProperty;var Z=(a,t,e)=>t in a?N(a,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[t]=e;var p=(a,t,e)=>(Z(a,typeof t!="symbol"?t+"":t,e),e);import{j as C,V as _,dK as H,cC as v}from"./virtual-memory-controller-ZSRKHGNY.js";class E{constructor(t){p(this,"core");this.core=t.CreateExtrusion()}get(t,e){const o=e.profilePoints??[0,0,0,1,0,0,1,1,0,0,1,0],r=e.profileHoles??[],n=e.direction??[0,0,1],c=e.cuttingPlaneNormal??[0,0,0],s=e.cuttingPlanePosition??[0,0,0],l=e.length??1,f=e.cap??!0,i=new t.wasmModule.DoubleVector;for(const w of o)i.push_back(w);for(const w of r){const b=new t.wasmModule.DoubleVector;for(const x of w)b.push_back(x);this.core.SetHoles(b)}const u=new t.wasmModule.DoubleVector;for(const w of n)u.push_back(w);const m=new t.wasmModule.DoubleVector;for(const w of c)m.push_back(w);const h=new t.wasmModule.DoubleVector;for(const w of s)h.push_back(w);this.core.SetValues(i,u,l,m,h,f);const g=this.core.GetBuffers();return this.core.ClearHoles(),g}}var L=(a=>(a[a.H=0]="H",a[a.C=1]="C",a[a.Z=2]="Z",a[a.T=3]="T",a[a.L=4]="L",a))(L||{});class B{constructor(t){p(this,"core");this.core=t.CreateProfile()}get(t,e){const o=e.type??0,r=e.width??.2,n=e.depth??.2,c=e.thickness??.002,s=e.flangeThickness??.002,l=e.hasFillet??!1,f=e.filletRadius??.001,i=e.radius??.01,u=e.slope??.001,m=e.circleSegments??20,h=new t.wasmModule.DoubleVector,g=e.placement??new C().identity();for(const b of g.elements)h.push_back(b);const w=this.core;return w.SetValues(o,r,n,c,s,l,f,i,u,m,h),w.GetBuffers()}}p(B,"map",new Map([["H",0],["C",1],["Z",2],["T",3],["L",4]]));class W{constructor(t){p(this,"core");this.core=t.CreateBooleanOperator()}get(t,e){const o=e.target.geometry,r=[],n=o.attributes.position.array,c=o.index.array,s=new _;for(let i=0;i<c.length-2;i+=3){const u=c[i],m=c[i+1],h=c[i+2];s.set(n[u*3],n[u*3+1],n[u*3+2]),s.applyMatrix4(e.target.matrixWorld),r.push(s.x),r.push(s.y),r.push(s.z),s.set(n[m*3],n[m*3+1],n[m*3+2]),s.applyMatrix4(e.target.matrixWorld),r.push(s.x),r.push(s.y),r.push(s.z),s.set(n[h*3],n[h*3+1],n[h*3+2]),s.applyMatrix4(e.target.matrixWorld),r.push(s.x),r.push(s.y),r.push(s.z)}const l=[];for(const i of e.operands){const u=[],m=i.geometry.index.array,h=i.geometry.attributes.position.array;for(let g=0;g<m.length-2;g+=3){const w=c[g],b=c[g+1],x=c[g+2];s.set(h[w*3],h[w*3+1],h[w*3+2]),s.applyMatrix4(i.matrixWorld),u.push(s.x),u.push(s.y),u.push(s.z),s.set(h[b*3],h[b*3+1],h[b*3+2]),s.applyMatrix4(i.matrixWorld),u.push(s.x),u.push(s.y),u.push(s.z),s.set(h[x*3],h[x*3+1],h[x*3+2]),s.applyMatrix4(i.matrixWorld),u.push(s.x),u.push(s.y),u.push(s.z)}l.push(u)}this.core.clear();const f=new t.wasmModule.DoubleVector;for(const i of r)f.push_back(i);this.core.SetValues(f,e.type);for(const i of l){const u=new t.wasmModule.DoubleVector;for(const m of i)u.push_back(m);this.core.SetSecond(u)}return this.core.GetBuffers()}}class X{constructor(t){p(this,"core");this.core=t.CreateArc()}get(t,e){const o=e.placement??new H,r=new t.wasmModule.DoubleVector;o.elements.forEach(m=>{r.push_back(m)});const n=e.radiusX??1,c=e.radiusY??1,s=e.numSegments??12,l=e.start??0,f=e.end??Math.PI,i=e.swap??!1,u=e.endingNormalToCenter??!1;return this.core.SetValues(n,c,s,r,l,f,i,u),this.core.GetBuffers()}}class O{constructor(t){p(this,"core");this.core=t.CreateAABB()}get(t){const e=t.min??new _(0,0,0),o=t.max??new _(1,1,1),{x:r,y:n,z:c}=e,{x:s,y:l,z:f}=o;return this.core.SetValues(r,n,c,s,l,f),this.core.GetBuffers()}}class F{constructor(t){p(this,"core");this.core=t.CreateCircularSweep()}get(t,e){const o=new t.wasmModule.DoubleVector,r=e.profilePoints??[];for(const h of r)o.push_back(h);const n=new t.wasmModule.DoubleVector,c=e.directrix??[];for(const h of c)n.push_back(h);const s=new t.wasmModule.DoubleVector,l=e.initNormal??[0,0,0];for(const h of l)s.push_back(h);const f=e.scale??1,i=e.closed??!1,u=e.radius??10,m=e.rotate??!1;return this.core.SetValues(f,i,o,u,n,s,m),this.core.GetBuffers()}}class I{constructor(t){p(this,"core");this.core=t.CreateCylindricalRevolution()}get(t,e){const o=new t.wasmModule.DoubleVector,r=e.transformation??new C().identity().elements;for(const u of r)o.push_back(u);const n=e.startAngle??0,c=e.endAngle??180,s=e.minZ??-10,l=e.maxZ??10,f=e.segmentCount??12,i=e.radius??4;return this.core.SetValues(o,n,c,s,l,f,i),this.core.GetBuffers()}}class Y{constructor(t){p(this,"core");this.core=t.CreateParabola()}get(t){const e=t.segmentCount??12,[o,r,n]=t.start??[0,0,0],c=t.horizontalLength??10,s=t.startHeight??2,l=t.startGradient??5,f=t.endGradient??0;return this.core.SetValues(e,o,r,n,c,s,l,f),this.core.GetBuffers()}}class j{constructor(t){p(this,"core");this.core=t.CreateRevolution()}get(t,e){const o=new t.wasmModule.DoubleVector,r=e.profile??[];for(const i of r)o.push_back(i);const n=new t.wasmModule.DoubleVector,c=e.transform??new C().identity().elements;for(const i of c)n.push_back(i);const s=e.start??0,l=e.end??180,f=e.segmentCount??12;return this.core.SetValues(o,n,s,l,f),this.core.GetBuffers()}}class K{constructor(t){p(this,"core");this.core=t.CreateSweep()}get(t,e){const o=e.profilePoints??[],r=e.curvePoints??[],n=e.startNormal??[0,0,0],c=e.scale??1,s=e.close??!1,l=e.rotate90??!1,f=e.optimize??!1,i=new t.wasmModule.DoubleVector;for(const g of o)i.push_back(g);const u=new t.wasmModule.DoubleVector;for(const g of r)u.push_back(g);const m=new t.wasmModule.DoubleVector;for(const g of n)m.push_back(g);return this.core.SetValues(c,s,i,u,m,l,f),this.core.GetBuffers()}}class q{constructor(t){p(this,"core");this.core=t.CreateExtrusion()}get(t,e){const o=e.start??[0,0,0],r=e.end??[1,0,0],n=e.elevation??0,c=e.offset??0,s=e.thickness??.1,l=e.direction??[0,1,0],f=e.cuttingPlaneNormal??[0,0,0],i=e.cuttingPlanePosition??[0,0,0],u=e.height??3,[m,,h]=o,[g,,w]=r,b=new _(g,n,w),x=new _(m,n,h),G=new _(g-m,n,w-h),A=new _(0,1,0),M=new _().crossVectors(G,A).normalize(),D=M.clone().multiplyScalar(c);b.add(D),x.add(D);const P=M.clone().multiplyScalar(s/2),V=[x.clone().add(P),b.clone().add(P),b.clone().sub(P),x.clone().sub(P)];V.push(V[0]);const y=new t.wasmModule.DoubleVector;for(const d of V)y.push_back(d.x),y.push_back(d.y),y.push_back(d.z);const S=new t.wasmModule.DoubleVector;for(const d of l)S.push_back(d);const k=new t.wasmModule.DoubleVector;for(const d of f)k.push_back(d);const z=new t.wasmModule.DoubleVector;for(const d of i)z.push_back(d);this.core.SetValues(y,S,u,k,z,!0);const R=this.core.GetBuffers();return this.core.ClearHoles(),R}}class J{constructor(t){p(this,"core");this.core=t.CreateClothoid()}get(t){const e=t.startPoint??[0,0,0],o=t.startDirection??.5,r=t.segments??12,n=t.startRadius??5,c=t.endRadius??0,s=t.segmentLength??5,[l,f,i]=e;return this.core.SetValues(r,l,f,i,o,n,c,s),this.core.GetBuffers()}}class ${constructor(t){p(this,"api");p(this,"_arc");p(this,"_parabola");p(this,"_extrusion");p(this,"_profile");p(this,"_booleanOperation");p(this,"_bbox");p(this,"_circularSweep");p(this,"_clothoid");p(this,"_cylindricalRevolve");p(this,"_revolve");p(this,"_sweep");p(this,"_wall");this.api=t,this._extrusion=new E(t),this._profile=new B(t),this._booleanOperation=new W(t),this._arc=new X(t),this._bbox=new O(t),this._clothoid=new J(t),this._circularSweep=new F(t),this._cylindricalRevolve=new I(t),this._revolve=new j(t),this._parabola=new Y(t),this._sweep=new K(t),this._wall=new q(t)}getExtrusion(t,e){const o=this._extrusion.get(this.api,e);this.applyMesh(t,o)}getSweep(t,e){const o=this._sweep.get(this.api,e);this.applyMesh(t,o)}getWall(t,e){const o=this._wall.get(this.api,e);this.applyMesh(t,o)}getProfile(t,e){const o=this._profile.get(this.api,e);this.applyCurve(t,o)}getBooleanOperation(t,e){const o=this._booleanOperation.get(this.api,e);this.applyMesh(t,o)}getBbox(t,e){const o=this._bbox.get(e);this.applyMesh(t,o)}getCircularSweep(t,e){const o=this._circularSweep.get(this.api,e);this.applyMesh(t,o)}getRevolve(t,e){const o=this._revolve.get(this.api,e);this.applyMesh(t,o)}getCylindricalRevolve(t,e){const o=this._cylindricalRevolve.get(this.api,e);this.applyMesh(t,o)}getArc(t,e){const o=this._arc.get(this.api,e);this.applyCurve(t,o)}getParabola(t,e){const o=this._parabola.get(e);this.applyCurve(t,o)}getClothoid(t,e){const o=this._clothoid.get(e);this.applyCurve(t,o)}getProfilePoints(t){const e=this._profile.get(this.api,t),o=e.fvertexData.size(),r=[];for(let n=0;n<o;n++){const c=e.fvertexData.get(n);r.push(c)}return r}transformPoints(t,e){const o=[],r=new _;for(let n=0;n<t.length;n+=3)r.set(t[n],t[n+1],t[n+2]),r.applyMatrix4(e),o.push(r.x,r.y,r.z);return o}applyMesh(t,e){const o=e.fvertexData.size(),r=new Float32Array(o);for(let l=0;l<o;l++)r[l]=e.fvertexData.get(l);t.setAttribute("position",new v(r,3));const n=e.indexData.size(),c=[];for(let l=0;l<n;l++)c[l]=e.indexData.get(l);t.setIndex(c);const s=new Float32Array(o).fill(0);t.setAttribute("normal",new v(s,3)),t.computeVertexNormals()}applyCurve(t,e){const o=e.fvertexData.size(),r=new Float32Array(o);for(let c=0;c<o;c++)r[c]=e.fvertexData.get(c);t.setAttribute("position",new v(r,3));const n=[];for(let c=0;c<o/3-1;c++)n.push(c,c+1);t.setIndex(n)}}export{$ as G,L as P};
