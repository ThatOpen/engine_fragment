var ti=Object.defineProperty;var ei=(o,t,e)=>t in o?ti(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e;var c=(o,t,e)=>(ei(o,typeof t!="symbol"?t+"":t,e),e),$e=(o,t,e)=>{if(!t.has(o))throw TypeError("Cannot "+e)};var h=(o,t,e)=>($e(o,t,"read from private field"),e?e.call(o):t.get(o)),y=(o,t,e)=>{if(t.has(o))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(o):t.set(o,e)},w=(o,t,e,s)=>($e(o,t,"write to private field"),s?s.call(o,e):t.set(o,e),e);var Ee=(o,t,e,s)=>({set _(i){w(o,t,i,e)},get _(){return h(o,t,s)}}),m=(o,t,e)=>($e(o,t,"access private method"),e);import{b as jt,V as p,cu as ge,cn as Ne,cd as Vs,M as pt,cC as Ws,ck as es,co as je,cp as Wt,cD as si,ce as Mt,cj as Ze,cB as Ns,ch as Re,cg as ms,f as fe,cf as de,cs as _s,ci as Pe,c1 as ii,cy as Is,cz as Ce,cA as ni,cr as ss,ct as Jt,T as ri,cw as oi,cx as ai,cm as bs,P as Bt,cq as ci,cl as hi,cv as li,g as ui,Q as fi}from"./pako.esm-TbDA1OGb.js";class Et{constructor(){c(this,"enabled",!0);c(this,"trigger",t=>{if(!this.enabled)return;const e=this.handlers.slice(0);for(const s of e)s(t)});c(this,"handlers",[])}add(t){this.handlers.push(t)}remove(t){this.handlers=this.handlers.filter(e=>e!==t)}reset(){this.handlers.length=0}}class ws extends Map{constructor(e){super(e);c(this,"onItemSet",new Et);c(this,"onItemUpdated",new Et);c(this,"onItemDeleted",new Et);c(this,"onBeforeDelete",new Et);c(this,"onCleared",new Et);c(this,"guard",()=>!0)}set eventsEnabled(e){this.onItemSet.enabled=e,this.onItemUpdated.enabled=e,this.onItemDeleted.enabled=e,this.onBeforeDelete.enabled=e,this.onCleared.enabled=e}clear(){for(const[e,s]of this)this.onBeforeDelete.trigger({key:e,value:s});super.clear(),this.onCleared.trigger()}set(e,s){const i=this.has(e);if(!(this.guard??(()=>!0))(e,s))return this;const a=super.set(e,s);return i?(this.onItemUpdated||(this.onItemUpdated=new Et),this.onItemUpdated.trigger({key:e,value:s})):(this.onItemSet||(this.onItemSet=new Et),this.onItemSet.trigger({key:e,value:s})),a}delete(e){const s=this.get(e);if(!s)return!1;this.onBeforeDelete.trigger({key:e,value:s});const i=super.delete(e);return i&&this.onItemDeleted.trigger(e),i}getKey(e){for(const[s,i]of this)if(i===e)return s}update(e){const s=this.getKey(e);s&&this.set(s,e)}deleteIf(e){for(const[s,i]of this)e(i,s)&&this.delete(s)}replaceKey(e,s,i=!1){const n=this.get(e);return!n||this.get(s)&&!i?!1:(this.eventsEnabled=!1,this.delete(e),this.eventsEnabled=!0,this.set(s,n),!0)}dispose(){this.clear(),this.onItemSet.reset(),this.onItemDeleted.reset(),this.onItemUpdated.reset(),this.onCleared.reset(),this.onBeforeDelete.reset()}}class Y{constructor(){c(this,"bb",null);c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}x(){return this.bb.readFloat32(this.bb_pos)}mutate_x(t){return this.bb.writeFloat32(this.bb_pos+0,t),!0}y(){return this.bb.readFloat32(this.bb_pos+4)}mutate_y(t){return this.bb.writeFloat32(this.bb_pos+4,t),!0}z(){return this.bb.readFloat32(this.bb_pos+8)}mutate_z(t){return this.bb.writeFloat32(this.bb_pos+8,t),!0}static sizeOf(){return 12}static createFloatVector(t,e,s,i){return t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class ys{constructor(){c(this,"bb",null);c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}aperture(){return this.bb.readFloat32(this.bb_pos)}mutate_aperture(t){return this.bb.writeFloat32(this.bb_pos+0,t),!0}position(t){return(t||new Y).__init(this.bb_pos+4,this.bb)}radius(){return this.bb.readFloat32(this.bb_pos+16)}mutate_radius(t){return this.bb.writeFloat32(this.bb_pos+16,t),!0}xDirection(t){return(t||new Y).__init(this.bb_pos+20,this.bb)}yDirection(t){return(t||new Y).__init(this.bb_pos+32,this.bb)}static sizeOf(){return 44}static createCircleCurve(t,e,s,i,n,r,a,l,u,d,f,b){return t.prep(4,44),t.prep(4,12),t.writeFloat32(b),t.writeFloat32(f),t.writeFloat32(d),t.prep(4,12),t.writeFloat32(u),t.writeFloat32(l),t.writeFloat32(a),t.writeFloat32(r),t.prep(4,12),t.writeFloat32(n),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class js{constructor(){c(this,"bb",null);c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}p1(t){return(t||new Y).__init(this.bb_pos,this.bb)}p2(t){return(t||new Y).__init(this.bb_pos+12,this.bb)}static sizeOf(){return 24}static createWire(t,e,s,i,n,r,a){return t.prep(4,24),t.prep(4,12),t.writeFloat32(a),t.writeFloat32(r),t.writeFloat32(n),t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class Pt{constructor(){c(this,"bb",null);c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsWireSet(t,e){return(e||new Pt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsWireSet(t,e){return t.setPosition(t.position()+jt),(e||new Pt).__init(t.readInt32(t.position())+t.position(),t)}ps(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new Y).__init(this.bb.__vector(this.bb_pos+s)+t*12,this.bb):null}psLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startWireSet(t){t.startObject(1)}static addPs(t,e){t.addFieldOffset(0,e,0)}static startPsVector(t,e){t.startVector(12,e,4)}static endWireSet(t){return t.endObject()}static createWireSet(t,e){return Pt.startWireSet(t),Pt.addPs(t,e),Pt.endWireSet(t)}}class nt{constructor(){c(this,"bb",null);c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAxis(t,e){return(e||new nt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAxis(t,e){return t.setPosition(t.position()+jt),(e||new nt).__init(t.readInt32(t.position())+t.position(),t)}wires(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new js).__init(this.bb.__vector(this.bb_pos+s)+t*24,this.bb):null}wiresLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}order(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+t*4):0}orderLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}orderArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}parts(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt8(this.bb.__vector(this.bb_pos+e)+t):0}partsLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}partsArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Int8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}wireSets(t,e){const s=this.bb.__offset(this.bb_pos,10);return s?(e||new Pt).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+t*4),this.bb):null}wireSetsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}circleCurves(t,e){const s=this.bb.__offset(this.bb_pos,12);return s?(e||new ys).__init(this.bb.__vector(this.bb_pos+s)+t*44,this.bb):null}circleCurvesLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}static startAxis(t){t.startObject(5)}static addWires(t,e){t.addFieldOffset(0,e,0)}static startWiresVector(t,e){t.startVector(24,e,4)}static addOrder(t,e){t.addFieldOffset(1,e,0)}static createOrderVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startOrderVector(t,e){t.startVector(4,e,4)}static addParts(t,e){t.addFieldOffset(2,e,0)}static createPartsVector(t,e){t.startVector(1,e.length,1);for(let s=e.length-1;s>=0;s--)t.addInt8(e[s]);return t.endVector()}static startPartsVector(t,e){t.startVector(1,e,1)}static addWireSets(t,e){t.addFieldOffset(3,e,0)}static createWireSetsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startWireSetsVector(t,e){t.startVector(4,e,4)}static addCircleCurves(t,e){t.addFieldOffset(4,e,0)}static startCircleCurvesVector(t,e){t.startVector(44,e,4)}static endAxis(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,10),t.requiredField(e,12),e}static createAxis(t,e,s,i,n,r){return nt.startAxis(t),nt.addWires(t,e),nt.addOrder(t,s),nt.addParts(t,i),nt.addWireSets(t,n),nt.addCircleCurves(t,r),nt.endAxis(t)}}var Te=(o=>(o[o.NONE=0]="NONE",o[o.WIRE=1]="WIRE",o[o.WIRE_SET=2]="WIRE_SET",o[o.CIRCLE_CURVE=3]="CIRCLE_CURVE",o))(Te||{});class It{constructor(){c(this,"bb",null);c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsBigShellHole(t,e){return(e||new It).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsBigShellHole(t,e){return t.setPosition(t.position()+jt),(e||new It).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+t*4):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}profileId(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint16(this.bb_pos+t):0}mutate_profile_id(t){const e=this.bb.__offset(this.bb_pos,6);return e===0?!1:(this.bb.writeUint16(this.bb_pos+e,t),!0)}static startBigShellHole(t){t.startObject(2)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(4,e,4)}static addProfileId(t,e){t.addFieldInt16(1,e,0)}static endBigShellHole(t){const e=t.endObject();return t.requiredField(e,4),e}static createBigShellHole(t,e,s){return It.startBigShellHole(t),It.addIndices(t,e),It.addProfileId(t,s),It.endBigShellHole(t)}}class Tt{constructor(){c(this,"bb",null);c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsBigShellProfile(t,e){return(e||new Tt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsBigShellProfile(t,e){return t.setPosition(t.position()+jt),(e||new Tt).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+t*4):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startBigShellProfile(t){t.startObject(1)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(4,e,4)}static endBigShellProfile(t){const e=t.endObject();return t.requiredField(e,4),e}static createBigShellProfile(t,e){return Tt.startBigShellProfile(t),Tt.addIndices(t,e),Tt.endBigShellProfile(t)}}class di{constructor(){c(this,"bb",null);c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}min(t){return(t||new Y).__init(this.bb_pos,this.bb)}max(t){return(t||new Y).__init(this.bb_pos+12,this.bb)}static sizeOf(){return 24}static createBoundingBox(t,e,s,i,n,r,a){return t.prep(4,24),t.prep(4,12),t.writeFloat32(a),t.writeFloat32(r),t.writeFloat32(n),t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class Lt{constructor(){c(this,"bb",null);c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCircleExtrusion(t,e){return(e||new Lt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCircleExtrusion(t,e){return t.setPosition(t.position()+jt),(e||new Lt).__init(t.readInt32(t.position())+t.position(),t)}radius(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat64(this.bb.__vector(this.bb_pos+e)+t*8):0}radiusLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}radiusArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float64Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}axes(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new nt).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+t*4),this.bb):null}axesLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startCircleExtrusion(t){t.startObject(2)}static addRadius(t,e){t.addFieldOffset(0,e,0)}static createRadiusVector(t,e){t.startVector(8,e.length,8);for(let s=e.length-1;s>=0;s--)t.addFloat64(e[s]);return t.endVector()}static startRadiusVector(t,e){t.startVector(8,e,8)}static addAxes(t,e){t.addFieldOffset(1,e,0)}static createAxesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAxesVector(t,e){t.startVector(4,e,4)}static endCircleExtrusion(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),e}static createCircleExtrusion(t,e,s){return Lt.startCircleExtrusion(t),Lt.addRadius(t,e),Lt.addAxes(t,s),Lt.endCircleExtrusion(t)}}class Us{constructor(){c(this,"bb",null);c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}x(){return this.bb.readFloat64(this.bb_pos)}mutate_x(t){return this.bb.writeFloat64(this.bb_pos+0,t),!0}y(){return this.bb.readFloat64(this.bb_pos+8)}mutate_y(t){return this.bb.writeFloat64(this.bb_pos+8,t),!0}z(){return this.bb.readFloat64(this.bb_pos+16)}mutate_z(t){return this.bb.writeFloat64(this.bb_pos+16,t),!0}static sizeOf(){return 24}static createDoubleVector(t,e,s,i){return t.prep(8,24),t.writeFloat64(i),t.writeFloat64(s),t.writeFloat64(e),t.offset()}}class pi{constructor(){c(this,"bb",null);c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}position(t){return(t||new Us).__init(this.bb_pos,this.bb)}xDirection(t){return(t||new Y).__init(this.bb_pos+24,this.bb)}yDirection(t){return(t||new Y).__init(this.bb_pos+36,this.bb)}static sizeOf(){return 48}static createTransform(t,e,s,i,n,r,a,l,u,d){return t.prep(8,48),t.prep(4,12),t.writeFloat32(d),t.writeFloat32(u),t.writeFloat32(l),t.prep(4,12),t.writeFloat32(a),t.writeFloat32(r),t.writeFloat32(n),t.prep(8,24),t.writeFloat64(i),t.writeFloat64(s),t.writeFloat64(e),t.offset()}}var te=(o=>(o[o.NONE=0]="NONE",o[o.LINES=1]="LINES",o[o.ELLIPSE_ARC=2]="ELLIPSE_ARC",o[o.CLOTHOID=3]="CLOTHOID",o[o.PARABOLA=4]="PARABOLA",o[o.WALLS=5]="WALLS",o))(te||{});class St{constructor(){c(this,"bb",null);c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShellHole(t,e){return(e||new St).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShellHole(t,e){return t.setPosition(t.position()+jt),(e||new St).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint16(this.bb.__vector(this.bb_pos+e)+t*2):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint16Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}profileId(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint16(this.bb_pos+t):0}mutate_profile_id(t){const e=this.bb.__offset(this.bb_pos,6);return e===0?!1:(this.bb.writeUint16(this.bb_pos+e,t),!0)}static startShellHole(t){t.startObject(2)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(2,e.length,2);for(let s=e.length-1;s>=0;s--)t.addInt16(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(2,e,2)}static addProfileId(t,e){t.addFieldInt16(1,e,0)}static endShellHole(t){const e=t.endObject();return t.requiredField(e,4),e}static createShellHole(t,e,s){return St.startShellHole(t),St.addIndices(t,e),St.addProfileId(t,s),St.endShellHole(t)}}class Ot{constructor(){c(this,"bb",null);c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShellProfile(t,e){return(e||new Ot).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShellProfile(t,e){return t.setPosition(t.position()+jt),(e||new Ot).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint16(this.bb.__vector(this.bb_pos+e)+t*2):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint16Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startShellProfile(t){t.startObject(1)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(2,e.length,2);for(let s=e.length-1;s>=0;s--)t.addInt16(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(2,e,2)}static endShellProfile(t){const e=t.endObject();return t.requiredField(e,4),e}static createShellProfile(t,e){return Ot.startShellProfile(t),Ot.addIndices(t,e),Ot.endShellProfile(t)}}var bt=(o=>(o[o.NONE=0]="NONE",o[o.BIG=1]="BIG",o))(bt||{});class ${constructor(){c(this,"bb",null);c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShell(t,e){return(e||new $).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShell(t,e){return t.setPosition(t.position()+jt),(e||new $).__init(t.readInt32(t.position())+t.position(),t)}profiles(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new Ot).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+t*4),this.bb):null}profilesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}holes(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new St).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+t*4),this.bb):null}holesLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}points(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new Y).__init(this.bb.__vector(this.bb_pos+s)+t*12,this.bb):null}pointsLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}bigProfiles(t,e){const s=this.bb.__offset(this.bb_pos,10);return s?(e||new Tt).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+t*4),this.bb):null}bigProfilesLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}bigHoles(t,e){const s=this.bb.__offset(this.bb_pos,12);return s?(e||new It).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+t*4),this.bb):null}bigHolesLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}type(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.readInt8(this.bb_pos+t):bt.NONE}mutate_type(t){const e=this.bb.__offset(this.bb_pos,14);return e===0?!1:(this.bb.writeInt8(this.bb_pos+e,t),!0)}static startShell(t){t.startObject(6)}static addProfiles(t,e){t.addFieldOffset(0,e,0)}static createProfilesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startProfilesVector(t,e){t.startVector(4,e,4)}static addHoles(t,e){t.addFieldOffset(1,e,0)}static createHolesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startHolesVector(t,e){t.startVector(4,e,4)}static addPoints(t,e){t.addFieldOffset(2,e,0)}static startPointsVector(t,e){t.startVector(12,e,4)}static addBigProfiles(t,e){t.addFieldOffset(3,e,0)}static createBigProfilesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startBigProfilesVector(t,e){t.startVector(4,e,4)}static addBigHoles(t,e){t.addFieldOffset(4,e,0)}static createBigHolesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startBigHolesVector(t,e){t.startVector(4,e,4)}static addType(t,e){t.addFieldInt8(5,e,bt.NONE)}static endShell(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,10),t.requiredField(e,12),e}static createShell(t,e,s,i,n,r,a){return $.startShell(t),$.addProfiles(t,e),$.addHoles(t,s),$.addPoints(t,i),$.addBigProfiles(t,n),$.addBigHoles(t,r),$.addType(t,a),$.endShell(t)}}const gi=65536;var me=(o=>(o[o.LINE=0]="LINE",o[o.SHELL=1]="SHELL",o))(me||{}),N=(o=>(o[o.UPDATE=0]="UPDATE",o[o.CREATE=1]="CREATE",o[o.DELETE=2]="DELETE",o[o.FINISH=3]="FINISH",o))(N||{}),Xe=(o=>(o[o.GEOMETRY=0]="GEOMETRY",o[o.WIRES=1]="WIRES",o[o.INVISIBLE=2]="INVISIBLE",o))(Xe||{}),dt=(o=>(o[o.CREATE_MODEL=0]="CREATE_MODEL",o[o.DELETE_MODEL=1]="DELETE_MODEL",o[o.EXECUTE=2]="EXECUTE",o[o.RAYCAST=3]="RAYCAST",o[o.FETCH_BOXES=4]="FETCH_BOXES",o[o.REFRESH_VIEW=5]="REFRESH_VIEW",o[o.RECOMPUTE_MESHES=6]="RECOMPUTE_MESHES",o[o.CREATE_MATERIAL=7]="CREATE_MATERIAL",o[o.THROW_ERROR=8]="THROW_ERROR",o))(dt||{});class Ue{static containedInParallelPlanes(t,e){let s=!0;for(const i of t){const r=i.distanceToPoint(e)>=0;s=s&&r}return s}static collides(t,e,s){for(const i of e)if(this.getPointDistance(i,s,t)<0)return!1;return!0}static getPointDistance(t,e,s){const i=t.normal;for(const n of this.dimensions)i[n]>=0!==e?this.tempPoint[n]=s.max[n]:this.tempPoint[n]=s.min[n];return t.distanceToPoint(this.tempPoint)}}c(Ue,"tempPoint",new p),c(Ue,"dimensions",["x","y","z"]);class Hs{static transform(t,e,s=new ge){for(let i=0;i<s.planes.length;i++){const n=s.planes[i],r=t.planes[i];n.copy(r),n.applyMatrix4(e)}return s}static isIncluded(t,e){return Ue.collides(t,e,!0)}static collides(t,e){return Ue.collides(t,e,!1)}}class mi{constructor(){c(this,"int");c(this,"float");c(this,"buffer");c(this,"s1",4);c(this,"s2",8);const{intBuffer:t,floatBuffer:e,buffer:s}=this.newBuffers();this.int=t,this.float=e,this.buffer=s}newBuffers(){const t=new Int32Array(1),e=t.buffer,s=new Float32Array(e),i=new Uint8Array(e);return{intBuffer:t,floatBuffer:s,buffer:i}}}class is{static check(t){const e=Number.isInteger(t),s=t<this._max,i=t>this._min;return e&&s&&i}}c(is,"_max",2147483647),c(is,"_min",-2147483648);const ke=class ke{constructor(){c(this,"_core",new mi);c(this,"_handlers");c(this,"_result",-1);c(this,"handleObject",t=>{const e=Object.keys(t);for(const s of e)t.hasOwnProperty(s)&&this.compute(t[s])});c(this,"handleString",t=>{const e=t.length;for(let s=0;s<e;++s){const i=t.codePointAt(s);this._core.int[0]=i,this.update()}});c(this,"handleBoolean",t=>{t?this._core.int[0]=1:this._core.int[0]=0,this.update()});c(this,"handleNumber",t=>{const s=is.check(t)?this._core.int:this._core.float;s[0]=t,this.update()});this._handlers=this.newHandlers()}get value(){return~this._result}fromMaterialData(t){const{modelId:e,objectClass:s,currentLod:i,templateId:n,...r}=t;this.reset(),this.compute(e),this.compute(s),this.compute(r),this.compute(i),this.compute(n!==void 0)}generate(t){this.reset();for(const e of t)this.compute(e);return this.value}compute(t){return this.getHandler(t)(t),this}reset(){return this._result=-1,this}getHandler(t){const e=typeof t,s=this._handlers[e];if(!s)throw new Error("Fragments: Unsupported input type");return s}newHandlers(){return{number:this.handleNumber,boolean:this.handleBoolean,string:this.handleString,object:this.handleObject}}update(){for(let t=0;t<this._core.s1;++t){this._result^=this._core.buffer[t];for(let e=0;e<this._core.s2;++e)this._result&1?this._result=this._result>>1^ke._polynomial:this._result>>=1}}};c(ke,"_polynomial",2197175160);let ns=ke;const Rt=class Rt{constructor(t,e){c(this,"_first");this._first=this.newData(t,e)}static getComplementary(t,e){let s=0;const i=t.position.length;s=this.makeBufferComplementary(i,t,s,e),s!==1/0&&e(s,1/0)}static get(t,e,s,i){const{filtered:n,position:r,size:a}=this.getData(t,s);return this.setAllBufferData(n,e,r,a,i),{position:r,size:a}}fullOf(t){const e=this._first.following,s=this._first.data;return e===null&&s===t}update(t,e){const s=this.getBufferData(t);if(!(s.data===e)){const{a:n,c:r,b:a}=this.newBuffers(t,s,e);this.setupInputData(s,n,r),this.setupUpdateBuffers(n,a,r)}}size(t){let e=0,s=this._first;for(;s!==null;)this.doesFilterPass(t,s)&&e++,s=s.following;return e}static setAllBufferData(t,e,s,i,n){for(let r=0;r<t.length;++r){const a=t[r];this.transform(a,e),this.setBuffers(s,i,r),n&&n(r,a.data)}}static makeBufferComplementary(t,e,s,i){for(let n=0;n<t;++n){const r=this.getBuffers(e,n),{position:a,size:l}=r;a>s&&i(s,a-s),s=a+l}return s}static setBuffers(t,e,s){t[s]=this._tempData.position,this._tempData.size===1/0?e[s]=this._inf:e[s]=this._tempData.size}add(t,e,s){if(!Rt._stash.length)return this.newData(e,s,t);const n=Rt._stash.pop();if(!n)throw new Error("Fragments: No stash found");return n.position=t,n.size=e,n.data=s,n}remove(t){t&&(t.following=null,t.past=null,Rt._stash.push(t))}static getData(t,e){const s=t.filter(e),i=s.length,n=new Uint32Array(i),r=new Uint32Array(i);return{filtered:s,position:n,size:r}}filter(t){const e=[];let s=this._first;for(;s!==null;)this.doesFilterPass(t,s)&&e.push(s),s=s.following;return e}static transform(t,e){const s=this.getTempData(),i=t.position+t.size,n=i===e.length;if(s.position=e[t.position],n)s.size=1/0;else{const r=e[i];s.size=r-s.position}return s}static getBuffers(t,e){const s=t.position[e],i=t.size[e]===this._inf;let n;return i?n=1/0:n=t.size[e],{position:s,size:n}}static getTempData(){return this._tempData?this._tempData:{position:0,size:0}}doesFilterPass(t,e){return!t||t(e.data)}setupUpdateBuffers(t,e,s){this.chainBuffers(t,e,s),this.setupFirstBuffer(t,e),this.setupLastBuffer(s,e),this.setupMiddleBufferStart(e),this.setupMiddleBufferEnd(e)}setupMiddleBufferEnd(t){var e;if(((e=t.following)==null?void 0:e.data)===t.data){if(!t.following)return;const s=t.following.size+t.size,i=t.following.following;t.size=s,this.remove(t.following),t.following=i,t.following&&(t.following.past=t)}}setupFirstBuffer(t,e){t.size||(t.past?t.past.following=e:this._first=e,e.past=t.past,this.remove(t))}setupMiddleBufferStart(t){var e;if(((e=t.past)==null?void 0:e.data)===t.data){if(!t.past)return;t.size=t.past.size+t.size,t.position=t.past.position;const s=t.past.past;this.remove(t.past),t.past=s,t.past?t.past.following=t:this._first=t}}chainBuffers(t,e,s){t.following=e,e.past=t,e.following=s,s.past=e}setupLastBuffer(t,e){t.size||(t.following&&(t.following.past=e),e.following=t.following,this.remove(t))}newBuffers(t,e,s){const i=t-e.position,n=this.add(e.position,i,e.data),r=this.add(t,1,s),a=e.size-n.size-1,l=this.add(t+1,a,e.data);return{a:n,c:l,b:r}}setupInputData(t,e,s){t.past?(t.past.following=e,e.past=t.past):this._first=e,t.following&&(t.following.past=s,s.following=t.following),this.remove(t)}newData(t,e,s=0){return{position:s,size:t,past:null,following:null,data:e}}getBufferData(t){let e=this._first;for(;;){const s=e===null,i=e.position<=t,n=t<e.position+e.size;if(s||i&&n)return e;e=e.following}}};c(Rt,"_stash",[]),c(Rt,"_tempData",{position:0,size:0}),c(Rt,"_inf",4294967295);let rs=Rt;class Ut{static fixNumber(t){return Number.isNaN(t)||!Number.isFinite(t)?0:t}static forEach(t,e){if(Array.isArray(t)){let s=0;for(const i of t)e(i,s++);return}e(t,0)}}class Gs{static estimateCapacity(){const t=this.capacityFactor,e=window.screen.width,s=window.screen.height,i=window.devicePixelRatio;return Math.trunc(e*s*i*i*t)}}c(Gs,"capacityFactor",200);class se{static parseMaterial(t){const e=t.r()/255,s=t.g()/255,i=t.b()/255,n=t.a()/255,r=t.a()<255,a=new Ne(e,s,i),l=t.renderedFaces();return{color:a,renderedFaces:l,opacity:n,transparent:r}}static parseBox(t,e){this.getBox(t,e,"min"),this.getBox(t,e,"max")}static parseTransform(t,e){return this.getVector(t,"position",this._doubleVector),this.getVector(t,"xDirection",this._floatVector),this.getVector(t,"yDirection",this._floatVector),this.computeZVector(),this.setTransform(e),e}static setTransform(t){const{x:e,y:s,z:i}=this._temp.xDirection,{x:n,y:r,z:a}=this._temp.yDirection,{x:l,y:u,z:d}=this._temp.zDirection,{x:f,y:b,z:g}=this._temp.position;t.set(e,n,l,f,s,r,u,b,i,a,d,g,0,0,0,1)}static getBox(t,e,s){t[s](this._floatVector);const i=this._floatVector.x(),n=this._floatVector.y(),r=this._floatVector.z();e[s].x=Ut.fixNumber(i),e[s].y=Ut.fixNumber(n),e[s].z=Ut.fixNumber(r)}static getVector(t,e,s){t[e](s);const i=this._temp[e],n=s.x(),r=s.y(),a=s.z();i.x=Ut.fixNumber(n),i.y=Ut.fixNumber(r),i.z=Ut.fixNumber(a)}static computeZVector(){this._temp.zDirection.crossVectors(this._temp.xDirection,this._temp.yDirection)}}c(se,"_temp",{position:new p,xDirection:new p,yDirection:new p,zDirection:new p}),c(se,"_doubleVector",new Us),c(se,"_floatVector",new Y);const k=class k{static get(t,e,s){this.fetchSampleTransform(t,e),this.fetchItemTransform(t,e),s.multiplyMatrices(this._item,this._sample)}static getBox(t,e){t.bbox(this._box),se.parseBox(this._box,e)}static getBoxData(t){this._min.copy(t.min),this._max.copy(t.max),this._center.addVectors(this._min,this._max),this._center.divideScalar(2),t.getSize(this._distance)}static boxSize(t){return this.getBoxData(t),this.applyTransformer(),this._edge.start=this._min.clone(),this._edge.end=this._max.clone(),this._edge}static applyTransformer(){const{x:t,y:e,z:s}=this._distance,i=Math.max(t,e,s);t===i?this._transformers.x():e===i?this._transformers.y():this._transformers.z()}static fetchItemTransform(t,e){const s=t.item();e.globalTransforms(s,this._transform),se.parseTransform(this._transform,this._item)}static fetchSampleTransform(t,e){const s=t.localTransform();e.localTransforms(s,this._transform),se.parseTransform(this._transform,this._sample)}static setBoxZ(){this._min.set(this._center.x,this._center.y,this._min.z),this._max.set(this._center.x,this._center.y,this._max.z)}static setBoxY(){this._min.set(this._center.x,this._min.y,this._center.z),this._max.set(this._center.x,this._max.y,this._center.z)}static setBoxX(){this._min.set(this._min.x,this._center.y,this._center.z),this._max.set(this._max.x,this._center.y,this._center.z)}};c(k,"_transform",new pi),c(k,"_min",new p),c(k,"_max",new p),c(k,"_center",new p),c(k,"_distance",new p),c(k,"_edge",new Vs),c(k,"_item",new pt),c(k,"_sample",new pt),c(k,"_box",new di),c(k,"_transformers",{x:()=>k.setBoxX(),y:()=>k.setBoxY(),z:()=>k.setBoxZ()});let Ss=k;class _i{static getWidth(t){return t.getSize(this._temp.vector),this._temp.vector.x>this._temp.vector.y&&this._temp.vector.set(this._temp.vector.y,this._temp.vector.x,this._temp.vector.z),this._temp.vector.y>this._temp.vector.z&&this._temp.vector.set(this._temp.vector.x,this._temp.vector.z,this._temp.vector.y),this._temp.vector.x>this._temp.vector.y&&this._temp.vector.set(this._temp.vector.y,this._temp.vector.x,this._temp.vector.z),this._temp.vector.y}}c(_i,"_temp",{vector:new p});class bi{static getEarcutDimensions(t){const e=Math.abs(t.x),s=Math.abs(t.y),i=Math.abs(t.z),n=0,r=1,a=2;return i>e&&i>s?t.z>0?[n,r]:[r,n]:s>e&&s>i?t.y>0?[a,n]:[n,a]:t.x>0?[r,a]:[a,r]}}const As=new Mt,ze=new p;class ks extends Ws{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";const t=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],e=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],s=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(s),this.setAttribute("position",new es(t,3)),this.setAttribute("uv",new es(e,2))}applyMatrix4(t){const e=this.attributes.instanceStart,s=this.attributes.instanceEnd;return e!==void 0&&(e.applyMatrix4(t),s.applyMatrix4(t),e.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const s=new je(e,6,1);return this.setAttribute("instanceStart",new Wt(s,3,0)),this.setAttribute("instanceEnd",new Wt(s,3,3)),this.instanceCount=this.attributes.instanceStart.count,this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const s=new je(e,6,1);return this.setAttribute("instanceColorStart",new Wt(s,3,0)),this.setAttribute("instanceColorEnd",new Wt(s,3,3)),this}fromWireframeGeometry(t){return this.setPositions(t.attributes.position.array),this}fromEdgesGeometry(t){return this.setPositions(t.attributes.position.array),this}fromMesh(t){return this.fromWireframeGeometry(new si(t.geometry)),this}fromLineSegments(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Mt);const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;t!==void 0&&e!==void 0&&(this.boundingBox.setFromBufferAttribute(t),As.setFromBufferAttribute(e),this.boundingBox.union(As))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Ze),this.boundingBox===null&&this.computeBoundingBox();const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(t!==void 0&&e!==void 0){const s=this.boundingSphere.center;this.boundingBox.getCenter(s);let i=0;for(let n=0,r=t.count;n<r;n++)ze.fromBufferAttribute(t,n),i=Math.max(i,s.distanceToSquared(ze)),ze.fromBufferAttribute(e,n),i=Math.max(i,s.distanceToSquared(ze));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}}de.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new fe(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}};Re.line={uniforms:ms.merge([de.common,de.fog,de.line]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};class Ht extends Ns{constructor(t){super({type:"LineMaterial",uniforms:ms.clone(Re.line.uniforms),vertexShader:Re.line.vertexShader,fragmentShader:Re.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,this.setValues(t)}get color(){return this.uniforms.diffuse.value}set color(t){this.uniforms.diffuse.value=t}get worldUnits(){return"WORLD_UNITS"in this.defines}set worldUnits(t){t===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}get linewidth(){return this.uniforms.linewidth.value}set linewidth(t){this.uniforms.linewidth&&(this.uniforms.linewidth.value=t)}get dashed(){return"USE_DASH"in this.defines}set dashed(t){t===!0!==this.dashed&&(this.needsUpdate=!0),t===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}get dashScale(){return this.uniforms.dashScale.value}set dashScale(t){this.uniforms.dashScale.value=t}get dashSize(){return this.uniforms.dashSize.value}set dashSize(t){this.uniforms.dashSize.value=t}get dashOffset(){return this.uniforms.dashOffset.value}set dashOffset(t){this.uniforms.dashOffset.value=t}get gapSize(){return this.uniforms.gapSize.value}set gapSize(t){this.uniforms.gapSize.value=t}get opacity(){return this.uniforms.opacity.value}set opacity(t){this.uniforms&&(this.uniforms.opacity.value=t)}get resolution(){return this.uniforms.resolution.value}set resolution(t){this.uniforms.resolution.value.copy(t)}get alphaToCoverage(){return"USE_ALPHA_TO_COVERAGE"in this.defines}set alphaToCoverage(t){this.defines&&(t===!0!==this.alphaToCoverage&&(this.needsUpdate=!0),t===!0?this.defines.USE_ALPHA_TO_COVERAGE="":delete this.defines.USE_ALPHA_TO_COVERAGE)}}const Ke=new Pe,Ps=new p,Ms=new p,j=new Pe,U=new Pe,gt=new Pe,Je=new p,ts=new pt,H=new Vs,Es=new p,Fe=new Mt,De=new Ze,mt=new Pe;let xt,Yt;function Cs(o,t,e){return mt.set(0,0,-t,1).applyMatrix4(o.projectionMatrix),mt.multiplyScalar(1/mt.w),mt.x=Yt/e.width,mt.y=Yt/e.height,mt.applyMatrix4(o.projectionMatrixInverse),mt.multiplyScalar(1/mt.w),Math.abs(Math.max(mt.x,mt.y))}function wi(o,t){const e=o.matrixWorld,s=o.geometry,i=s.attributes.instanceStart,n=s.attributes.instanceEnd,r=Math.min(s.instanceCount,i.count);for(let a=0,l=r;a<l;a++){H.start.fromBufferAttribute(i,a),H.end.fromBufferAttribute(n,a),H.applyMatrix4(e);const u=new p,d=new p;xt.distanceSqToSegment(H.start,H.end,d,u),d.distanceTo(u)<Yt*.5&&t.push({point:d,pointOnLine:u,distance:xt.origin.distanceTo(d),object:o,face:null,faceIndex:a,uv:null,uv1:null})}}function yi(o,t,e){const s=t.projectionMatrix,n=o.material.resolution,r=o.matrixWorld,a=o.geometry,l=a.attributes.instanceStart,u=a.attributes.instanceEnd,d=Math.min(a.instanceCount,l.count),f=-t.near;xt.at(1,gt),gt.w=1,gt.applyMatrix4(t.matrixWorldInverse),gt.applyMatrix4(s),gt.multiplyScalar(1/gt.w),gt.x*=n.x/2,gt.y*=n.y/2,gt.z=0,Je.copy(gt),ts.multiplyMatrices(t.matrixWorldInverse,r);for(let b=0,g=d;b<g;b++){if(j.fromBufferAttribute(l,b),U.fromBufferAttribute(u,b),j.w=1,U.w=1,j.applyMatrix4(ts),U.applyMatrix4(ts),j.z>f&&U.z>f)continue;if(j.z>f){const x=j.z-U.z,A=(j.z-f)/x;j.lerp(U,A)}else if(U.z>f){const x=U.z-j.z,A=(U.z-f)/x;U.lerp(j,A)}j.applyMatrix4(s),U.applyMatrix4(s),j.multiplyScalar(1/j.w),U.multiplyScalar(1/U.w),j.x*=n.x/2,j.y*=n.y/2,U.x*=n.x/2,U.y*=n.y/2,H.start.copy(j),H.start.z=0,H.end.copy(U),H.end.z=0;const I=H.closestPointToPointParameter(Je,!0);H.at(I,Es);const E=ii.lerp(j.z,U.z,I),S=E>=-1&&E<=1,T=Je.distanceTo(Es)<Yt*.5;if(S&&T){H.start.fromBufferAttribute(l,b),H.end.fromBufferAttribute(u,b),H.start.applyMatrix4(r),H.end.applyMatrix4(r);const x=new p,A=new p;xt.distanceSqToSegment(H.start,H.end,A,x),e.push({point:A,pointOnLine:x,distance:xt.origin.distanceTo(A),object:o,face:null,faceIndex:b,uv:null,uv1:null})}}}class vi extends _s{constructor(t=new ks,e=new Ht({color:Math.random()*16777215})){super(t,e),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const t=this.geometry,e=t.attributes.instanceStart,s=t.attributes.instanceEnd,i=new Float32Array(2*e.count);for(let r=0,a=0,l=e.count;r<l;r++,a+=2)Ps.fromBufferAttribute(e,r),Ms.fromBufferAttribute(s,r),i[a]=a===0?0:i[a-1],i[a+1]=i[a]+Ps.distanceTo(Ms);const n=new je(i,2,1);return t.setAttribute("instanceDistanceStart",new Wt(n,1,0)),t.setAttribute("instanceDistanceEnd",new Wt(n,1,1)),this}raycast(t,e){const s=this.material.worldUnits,i=t.camera;i===null&&!s&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const n=t.params.Line2!==void 0&&t.params.Line2.threshold||0;xt=t.ray;const r=this.matrixWorld,a=this.geometry,l=this.material;Yt=l.linewidth+n,a.boundingSphere===null&&a.computeBoundingSphere(),De.copy(a.boundingSphere).applyMatrix4(r);let u;if(s)u=Yt*.5;else{const f=Math.max(i.near,De.distanceToPoint(xt.origin));u=Cs(i,f,l.resolution)}if(De.radius+=u,xt.intersectsSphere(De)===!1)return;a.boundingBox===null&&a.computeBoundingBox(),Fe.copy(a.boundingBox).applyMatrix4(r);let d;if(s)d=Yt*.5;else{const f=Math.max(i.near,Fe.distanceToPoint(xt.origin));d=Cs(i,f,l.resolution)}Fe.expandByScalar(d),xt.intersectsBox(Fe)!==!1&&(s?wi(this,e):yi(this,i,e))}onBeforeRender(t){const e=this.material.uniforms;e&&e.resolution&&(t.getViewport(Ke),this.material.uniforms.resolution.value.set(Ke.z,Ke.w))}}class qs extends ks{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(t){const e=t.length-3,s=new Float32Array(2*e);for(let i=0;i<e;i+=3)s[2*i]=t[i],s[2*i+1]=t[i+1],s[2*i+2]=t[i+2],s[2*i+3]=t[i+3],s[2*i+4]=t[i+4],s[2*i+5]=t[i+5];return super.setPositions(s),this}setColors(t){const e=t.length-3,s=new Float32Array(2*e);for(let i=0;i<e;i+=3)s[2*i]=t[i],s[2*i+1]=t[i+1],s[2*i+2]=t[i+2],s[2*i+3]=t[i+3],s[2*i+4]=t[i+4],s[2*i+5]=t[i+5];return super.setColors(s),this}setFromPoints(t){const e=t.length-1,s=new Float32Array(6*e);for(let i=0;i<e;i++)s[6*i]=t[i].x,s[6*i+1]=t[i].y,s[6*i+2]=t[i].z||0,s[6*i+3]=t[i+1].x,s[6*i+4]=t[i+1].y,s[6*i+5]=t[i+1].z||0;return super.setPositions(s),this}fromLine(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}}class xi extends vi{constructor(t=new qs,e=new Ht({color:Math.random()*16777215})){super(t,e),this.isLine2=!0,this.type="Line2"}}class Ii{constructor(t){c(this,"model");c(this,"_endpointsMaterials",{interior:new Is({color:15658734,size:8,sizeAttenuation:!1,depthTest:!1}),exterior:new Is({color:16777215,size:16,sizeAttenuation:!1,depthTest:!1})});c(this,"_absoluteAlignments",new Ce);c(this,"_horizontalAlignments",new Ce);c(this,"_verticalAlignments",new Ce);c(this,"_alignmentMaterials",new Map([[te.NONE,new Ht({color:16777215,linewidth:5,depthTest:!1})],[te.LINES,new Ht({color:16711935,linewidth:5,depthTest:!1})],[te.CLOTHOID,new Ht({color:16711680,linewidth:5,depthTest:!1})],[te.ELLIPSE_ARC,new Ht({color:65535,linewidth:5,depthTest:!1})],[te.PARABOLA,new Ht({color:255,linewidth:5,depthTest:!1})]]));this.model=t}async getAlignments(){return this._absoluteAlignments.children.length||await this.constructAlignments(),this._absoluteAlignments}async getHorizontalAlignments(){return this._horizontalAlignments.children.length||await this.constructAlignments(),this._horizontalAlignments}async getVerticalAlignments(){return this._verticalAlignments.children.length||await this.constructAlignments(),this._verticalAlignments}async getAlignmentStyles(){return{...this._alignmentMaterials,...this._endpointsMaterials}}async constructAlignments(){const t=await this.model.threads.invoke(this.model.modelId,"getAlignments");for(const e of t)this.constructLine(e.absolute,this._absoluteAlignments),this.constructLine(e.horizontal,this._horizontalAlignments),this.constructLine(e.vertical,this._verticalAlignments)}constructLine(t,e){if(!t.length)return;const s=[],i=[],n=new Ce;e.add(n);const r=t[0].points,a=t[t.length-1].points;i.push(a[0],a[1],a[2]),i.push(r[r.length-3],r[r.length-2],r[r.length-1]);for(const d of t){const f=d.points;s.push(f[0],f[1],f[2]),s.push(f[f.length-3],f[f.length-2],f[f.length-1]);const b=new qs;b.setPositions(f);const g=this._alignmentMaterials.get(d.type),_=new xi(b,g);n.add(_),_.renderOrder=1,_.userData.points=f}const{interior:l,exterior:u}=this._endpointsMaterials;this.constructPoints(s,l,n),this.constructPoints(i,u,n)}constructPoints(t,e,s){const i=new ni,n=new ss,r=new Float32Array(t),a=new Jt(r,3);n.setAttribute("position",a),i.geometry=n,i.material=e,s.add(i),i.renderOrder=2}dispose(){this._absoluteAlignments.removeFromParent();for(const t of this._absoluteAlignments.children){const e=t;e.geometry.dispose(),e.geometry=void 0,e.material=void 0}for(const t of Object.values(this._alignmentMaterials))t.dispose();this._alignmentMaterials={}}}class Si{async setup(t,e,s,i,n){const r=this.getCreateModelMessage(t,s,i,n),a=this.formatModelData(s),l=await t.threads.fetch(r,a);this.updateBox(e,l)}formatModelData(t){if(t instanceof ArrayBuffer)return[t]}updateBox(t,e){t.min.copy(e.boundingBox.min),t.max.copy(e.boundingBox.max)}getCreateModelMessage(t,e,s,i){return{class:dt.CREATE_MODEL,modelId:t.modelId,modelData:e,raw:s,config:i}}}class Ai{async getBoxes(t,e){const s=this.getIndividualBoxesIds(e),i=this.getBoxRequest(t,s),n=await t.threads.fetch(i);return this.getAllBoxes(n,t)}async getMergedBox(t,e){const s=this.getBoxRequest(t,[e]),{boxes:i}=await t.threads.fetch(s),[n]=i;return this.getAbsoluteBox(n,t)}getAbsoluteBox(t,e){const s=new Mt;return s.copy(t),s.applyMatrix4(e.object.matrixWorld),s}getIndividualBoxesIds(t){if(!t)return;const e=[];for(const s of t)e.push([s]);return e}getAllBoxes(t,e){const s=t.boxes,i=[];for(const n of s){const r=new Mt;r.copy(n),r.applyMatrix4(e.object.matrixWorld),i.push(r)}return i}getBoxRequest(t,e){return{class:dt.FETCH_BOXES,modelId:t.modelId,localIds:e}}}class Pi{constructor(){c(this,"_coordinationMatrices",new Map)}async getCoordinationMatrix(t){let e=this._coordinationMatrices.get(t.modelId);if(e)return e;e=new pt,this._coordinationMatrices.set(t.modelId,e);const[s,i,n,r,a,l,u,d,f]=await this.getCoordinates(t),b=new p(r,a,l),g=new p(u,d,f),_=new p().crossVectors(b,g);return e.set(r,u,_.x,s,a,d,_.y,i,l,f,_.z,n,0,0,0,1),e}async getCoordinates(t){const e=t.modelId;return t.threads.invoke(e,"getCoordinates")}async getPositions(t,e){const s=[e],i=await t.threads.invoke(t.modelId,"getPositions",s);return this.getAbsolutePositions(i,t)}getAbsolutePositions(t,e){const s=[];for(const i of t){const{x:n,y:r,z:a}=i,l=new p(n,r,a);l.applyMatrix4(e.object.matrixWorld),s.push(l)}return s}}class Mi extends Map{constructor(e,s){super(s);c(this,"tracker",null);c(this,"localId");c(this,"guard",()=>!0);this.localId=e}get object(){const e={};for(const[s,i]of this.entries())e[s]=i.value;return e}set(e,s){if(!(this.guard??(()=>!0))(e,s))return this;const r=s.type!==void 0?s:{value:s.value,type:this.getType(e)};if(!this.tracker)return super.set(e,r);if(this.localId===null)return console.warn("Item attributes are missing a valid localId. Changes can't be tracked."),super.set(e,r);let a=this.tracker.get(this.localId);return a||(a={type:"modified",added:{},deleted:[],modified:{}},this.tracker.set(this.localId,a)),a.type==="added"?a.data[e]=r:a.type==="modified"&&(this.has(e)?a.modified[e]=r:a.deleted.includes(e)?(a.deleted=a.deleted.filter(l=>l!==e),a.modified[e]=r):a.added[e]=r),super.set(e,r)}setValue(e,s){return this.set(e,{value:s,type:this.getType(e)})}setType(e,s){const i=this.getValue(e);return i?this.set(e,{value:i,type:s}):this}delete(e){if(!this.tracker)return super.delete(e);const s=this.get("localId");if(s===void 0||typeof s!="number")return console.warn("Item attributes are missing a valid localId. Changes can't be tracked."),e==="localId"?!1:super.delete(e);if(e==="localId"||!this.has(e))return!1;let i=this.tracker.get(s);return i||(i={type:"modified",added:{},deleted:[],modified:{}},this.tracker.set(s,i)),i.type==="added"?delete i.data[e]:i.type==="modified"&&(e in i.added?delete i.added[e]:(e in i.modified&&delete i.modified[e],i.deleted.push(e))),super.delete(e)}getValue(e){const s=this.get(e);return s?s.value:null}getType(e){var s;return(s=this.get(e))==null?void 0:s.type}}class Ei extends Map{constructor(e,s){super(s);c(this,"tracker",null);c(this,"localId");c(this,"guard",()=>!0);c(this,"onItemsRequested",null);this.localId=e}get itemChanges(){if(!this.tracker)return null;if(!this.localId)return console.warn("Item relations can't be tracked."),null;let e=this.tracker.get(this.localId);return e||(e={type:"modified",added:{},deleted:new Set,removed:{},modified:{}},this.tracker.set(this.localId,e)),e}set(e,s){const i=this.has(e);if(!(this.guard??(()=>!0))(e,s))return this;const a=this.itemChanges;return a?(i?a.modified[e]=s:a.added[e]=s,super.set(e,s)):super.set(e,s)}add(e,s){var a;const i=this.has(e);let n=this.get(e);if(!n)return n=new Set([s]),this.set(e,n),!0;if(!n||n.has(s))return!1;const r=this.itemChanges;if(!r)return n.add(s),!0;if(i)if((a=r.removed[e])!=null&&a.has(s))r.removed[e].delete(s),r.removed[e].size===0&&delete r.removed[e];else{let l=r.modified[e];l||(l=new Set,r.modified[e]=l),l.add(s)}else{let l=r.added[e];l||(l=new Set,r.added[e]=l),l.add(s)}return n.add(s),!0}remove(e,s){var r;const i=this.get(e);if(!i||!i.has(s))return!1;const n=this.itemChanges;if(!n)return i.delete(s);if((r=n.modified[e])!=null&&r.has(s))n.modified[e].delete(s),n.modified[e].size===0&&delete n.modified[e];else{let a=n.removed[e];a||(a=new Set,n.removed[e]=a),a.add(s)}return i.delete(s)}delete(e){if(!this.has(e))return!1;const s=this.itemChanges;return s?(s.deleted.add(e),super.delete(e)):super.delete(e)}async getItems(e){if(!this.onItemsRequested)return null;const s=this.get(e);return s?await this.onItemsRequested([...s]):null}}class Ci{constructor(t,e){c(this,"model");c(this,"localId");c(this,"_indices",null);c(this,"_transform",null);c(this,"_normals",null);c(this,"_positions",null);c(this,"_vertices",null);c(this,"_triangles",null);c(this,"_position",null);c(this,"_box",null);this.model=t,this.localId=e}async get(){const[t]=await this.model.threads.invoke(this.model.modelId,"getItemsGeometry",[[this.localId]]);for(const e of t){e.transform=new pt().fromArray(e.transform.elements);const{indices:s,normals:i,positions:n,transform:r}=e;this._indices||(this._indices=[]),this._normals||(this._normals=[]),this._positions||(this._positions=[]),this._transform||(this._transform=[]),this._indices.push(s),this._normals.push(i),this._positions.push(n),this._transform.push(r)}return t}async getIndices(){return this._indices!==null?this._indices:(await this.get(),this._indices)}async getTransform(){return this._transform!==null?this._transform:(await this.get(),this._transform)}async getNormals(){return this._normals!==null?this._normals:(await this.get(),this._normals)}async getPositions(){return this._positions!==null?this._positions:(await this.get(),this._positions)}async getVertices(){if(this._vertices)return this._vertices;const t=await this.getPositions(),e=await this.getTransform();if(!t||!e)return this._vertices;this._vertices=[];for(let s=0;s<t.length;s++){const i=t[s],n=e[s];if(!i||!n)continue;const r=[];this._vertices.push(r);const a=Object.keys(i).length/3,l=[];for(let u=0;u<a;u++){const d=i[u*3],f=i[u*3+1],b=i[u*3+2];if(typeof d!="number"||typeof f!="number"||typeof b!="number")continue;const g=`${d},${f},${b}`;if(l.includes(g))continue;l.push(g);const _=new p(d,f,b);_.applyMatrix4(n),r.push(_)}}return this._vertices}async getTriangles(){if(this._triangles)return this._triangles;const t=await this.getIndices(),e=await this.getPositions(),s=await this.getTransform();if(!t||!e||!s)return this._triangles;this._triangles=[];for(let i=0;i<t.length;i++){const n=t[i],r=e[i],a=s[i];if(!n||!r||!a)continue;const l=[];this._triangles.push(l);for(let u=0;u<n.length;u+=3){const d=n[u],f=n[u+1],b=n[u+2],g=new p(r[d*3],r[d*3+1],r[d*3+2]),_=new p(r[f*3],r[f*3+1],r[f*3+2]),I=new p(r[b*3],r[b*3+1],r[b*3+2]);g.applyMatrix4(a),_.applyMatrix4(a),I.applyMatrix4(a),l.push(new ri(g,_,I))}}return this._triangles}async getPosition(){if(!this._position){if(this.localId===null)return null;this._position=await this.model.getPositions([this.localId])}return this._position}async getBox(){if(!this._box){if(this.localId===null)return null;this._box=await this.model.getBoxes([this.localId])}return this._box}async setVisibility(t){await this.model.setVisible([this.localId],t)}async getVisibility(){const[t]=await this.model.getVisible([this.localId]);return t}}class zi{constructor(t,e){c(this,"model");c(this,"_localId",null);c(this,"_attributes",null);c(this,"_relations",null);c(this,"_guid",null);c(this,"_category",null);c(this,"_geometry",null);this.model=t,typeof e=="number"&&(this._localId=e),typeof e=="string"&&(this._guid=e)}async getLocalId(){if(!this._localId)if(this._guid)[this._localId]=await this.model.threads.invoke(this.model.modelId,"getLocalIdsByGuids",[[this._guid]]);else throw new Error("Fragments: Item localId couldn't be get.");return this._localId}async getAttributes(){if(this._attributes)return this._attributes;const t=await this.getLocalId();if(t===null)return null;const e=await this.model.threads.invoke(this.model.modelId,"getItemAttributes",[t]);if(this._attributes=new Mi(t),!e){const i=this.model.attrsChanges.get(t);if(!(i&&i.type==="added"))return null;this._attributes.localId=t;for(const[n,r]of Object.entries(i.data))this._attributes.set(n,r);return this._attributes}const s=this.model.attrsChanges.get(t);if(s&&s.type==="modified")for(const[i,n]of Object.entries(s.added))this._attributes.set(i,n);for(const i in e){const{value:n,type:r}=e[i];(s==null?void 0:s.type)==="modified"&&s.deleted.includes(i)||((s==null?void 0:s.type)==="modified"&&i in s.modified?this._attributes.set(i,s.modified[i]):this._attributes.set(i,{value:n,type:r}))}return this._attributes.tracker=this.model.attrsChanges,this._attributes}async getRelations(){if(this._relations)return this._relations;const t=await this.getLocalId();if(t===null)return null;const e=await this.model.threads.invoke(this.model.modelId,"getItemRelations",[t]);if(!e)return null;this._relations=new Ei(t),this._relations.onItemsRequested=async i=>{const n=[];for(const r of i){const a=this.model.getItem(r);a&&n.push(a)}return n};const s=this.model.relsChanges.get(t);if(s&&s.type==="modified")for(const[i,n]of Object.entries(s.added))this._relations.set(i,n);for(const[i,n]of Object.entries(e))if(!((s==null?void 0:s.type)==="modified"&&s.deleted.has(i)))if((s==null?void 0:s.type)==="modified"&&i in s.modified){const r=new Set([...s.modified[i],...n]);this._relations.set(i,new Set(r))}else this._relations.set(i,new Set(n));return this._relations.tracker=this.model.relsChanges,this._relations}async getGuid(){if(!this._guid){const t=await this.getLocalId();if(t===null)return null;[this._guid]=await this.model.threads.invoke(this.model.modelId,"getGuidsByLocalIds",[[t]])}return this._guid}async getCategory(){if(!this._category){const t=await this.getLocalId();if(t===null)return null;this._category=await this.model.threads.invoke(this.model.modelId,"getItemCategory",[t])}return this._category}async getGeometry(){if(this._geometry)return this._geometry;const t=await this.getLocalId();return t===null?null:new Ci(this.model,t)}async getData(t=[]){var a;const e=await this.getLocalId();if(e==null)return{};t.push(e);const s=(a=await this.getAttributes())==null?void 0:a.object,i=await this.getRelations(),n={};if(i)for(const l of i.keys()){const u=[];n[l]=u;const d=await i.getItems(l);if(d)for(const f of d){const b=await f.getLocalId();if(!b||t.find(_=>_===b)!==void 0)continue;t.push(b);const g=await f.getData(t);g&&u.push(g)}}return{...s,...n}}}class Fi{getItem(t,e){return new zi(t,e)}async getItemsData(t,e,s){return t.threads.invoke(t.modelId,"getItemsData",[e,s])}async getItemsChildren(t,e){return t.threads.invoke(t.modelId,"getItemsChildren",[e])}}class Di{constructor(){c(this,"getClippingPlanesEvent",()=>[]);c(this,"_tempMatrix",new pt);c(this,"_tempVec",new p);c(this,"_tempFrustum",new ge);c(this,"_updateCameraPositionEvent",()=>{});c(this,"_updateCameraFrustumEvent",()=>{});c(this,"_updateFOVEvent",()=>{});c(this,"_updateOrthoSizeEvent",()=>{})}async refreshView(t,e){const s=this.setup(e,t),i=Hs.transform(this._tempFrustum,this._tempMatrix),n=this.newViewRequest(i,s,t);await t.threads.fetch(n)}useCamera(t){const e=new pt;this.setCameraPosition(t),this.setCameraFrustum(t,e),this.setFov(t),this.setOrtho()}getOrthoSize(){let t=this._updateOrthoSizeEvent();if(t){const e=this._tempMatrix.getMaxScaleOnAxis();t*=e}return t}setup(t,e){return t.requests.clean(e.modelId),this._tempMatrix.copy(e.object.matrixWorld).invert(),this._updateCameraPositionEvent(this._tempVec),this._updateCameraFrustumEvent(this._tempFrustum),this._updateFOVEvent()}newViewRequest(t,e,s){const i=this.newView(t,e,s),n={};return n.class=dt.REFRESH_VIEW,n.modelId=s.modelId,n.cameraFrustum=t,n.view=i,n}newView(t,e,s){const i={};return i.cameraFrustum=t,i.cameraPosition=this._tempVec.applyMatrix4(this._tempMatrix),i.fov=e,i.orthogonalDimension=this.getOrthoSize(),i.viewSize=Math.max(window.innerWidth,window.innerHeight),i.graphicThreshold=Gs.estimateCapacity(),i.graphicQuality=s.graphicsQuality*-1.5+2,i.clippingPlanes=this.getPlanes(),i.modelPlacement=s.object.matrixWorld,i}setOrtho(){this._updateOrthoSizeEvent=()=>{}}setFov(t){this._updateFOVEvent=()=>{if(t instanceof oi)return t.fov}}getPlanes(){const t=[],e=this.getClippingPlanesEvent();for(const s of e){const i=s.clone();i.applyMatrix4(this._tempMatrix),t.push(i)}return t}setCameraPosition(t){this._updateCameraPositionEvent=e=>{e.copy(t.position)}}setCameraFrustum(t,e){this._updateCameraFrustumEvent=s=>{t.updateProjectionMatrix(),t.updateWorldMatrix(!0,!0);const{projectionMatrix:i,matrixWorldInverse:n}=t;e.multiplyMatrices(i,n),s.setFromProjectionMatrix(e)}}}class Bi{constructor(){c(this,"_caster",new ai);c(this,"_ray",new bs);c(this,"_frustum",new ge);c(this,"_inverseTransform",new pt);c(this,"_t",new Bt);c(this,"_r",new Bt);c(this,"_b",new Bt);c(this,"_l",new Bt);c(this,"_n",new Bt);c(this,"_f",new Bt);c(this,"_tl",new p);c(this,"_tr",new p);c(this,"_bl",new p);c(this,"_br",new p);c(this,"_tln",new p);c(this,"_brn",new p);c(this,"_tlp",new fe);c(this,"_brp",new fe);c(this,"distance",10)}async raycast(t,e){const{frustum:s,ray:i}=this.getRayAndFrustum(e),n=this.getRequest(t,s,i);if(!n)return null;const r=await t.threads.fetch(n);if(r.results&&r.results.length){const[a]=r.results;return this.getResult({hit:a,frustum:s,ray:i,model:t})}return null}async rectangleRaycast(t,e,s){const i=this.getFrustum(s),n=this.getRequest(t,i);if(!n)return null;n.fullyIncluded=s.fullyIncluded;const r=await t.threads.fetch(n);return r.localIds&&r.localIds.length?this.newRectangleCastResponse(r,e):null}async raycastWithSnapping(t,e){const{frustum:s,ray:i}=this.getRayAndFrustum(e),n=this.getRequest(t,s,i);if(!n)return null;n.snappingClass=e.snappingClasses;const r=await t.threads.fetch(n);return r.results?this.newRaycastSnapResult(r,s,i,t):null}screenRectToFrustum(t,e,s,i){return this.screenToCast(t,s,this._tlp),this.screenToCast(e,s,this._brp),this.setVectors(i),this.setPlanes(i),this.newFrustum()}screenToCasterPoint(t,e,s){const i=this.screenToCast(t,e);return this._caster.setFromCamera(i,s),this._caster.ray.clone()}setPlanes(t){this.setBasePoints(),t.getWorldDirection(this._n.normal),this.setEnds(t)}setVectors(t){this.setVector(this._tl,this._tlp,this._tlp,1,t),this.setVector(this._tr,this._brp,this._tlp,1,t),this.setVector(this._bl,this._tlp,this._brp,1,t),this.setVector(this._br,this._brp,this._brp,1,t),this.setVector(this._tln,this._tlp,this._tlp,0,t),this.setVector(this._brn,this._brp,this._brp,0,t)}newFrustum(){return new ge(this._t,this._b,this._l,this._r,this._f,this._n)}setEnds(t){this._n.constant=t.position.length(),this._f.normal=this._n.normal,this._f.constant=1/0}screenToCast(t,e,s=new fe){const i=e.getBoundingClientRect(),n=i.width/e.clientWidth,r=i.height/e.clientHeight,a=(t.x-i.left)/n,l=(t.y-i.top)/r;return s.x=a/e.clientWidth*2-1,s.y=-(l/e.clientHeight)*2+1,s}setVector(t,e,s,i,n){t.set(e.x,s.y,i),t.unproject(n)}setPlane(t,e,s,i){t.setFromCoplanarPoints(e,s,i)}setBasePoints(){this.setPlane(this._t,this._tln,this._tl,this._tr),this.setPlane(this._r,this._brn,this._tr,this._br),this.setPlane(this._b,this._brn,this._br,this._bl),this.setPlane(this._l,this._tln,this._bl,this._tl)}setupRay(t,e){t&&(this._ray.copy(t),this._ray.applyMatrix4(this._inverseTransform),e.ray=this._ray)}setupMatrix(t){this._inverseTransform.copy(t.matrixWorld),this._inverseTransform.invert()}getRequest(t,e,s){const{object:i,box:n,modelId:r}=t;return e.intersectsBox(n)?this.newCastRequest(i,r,s,e):null}getRayAndFrustum(t){this.updateCamera(t.camera);const{bottomLeft:e,topRight:s}=this.getCorners(t.mouse),i=this.screenToCasterPoint(t.mouse,t.dom,t.camera),n=this.screenRectToFrustum(e,s,t.dom,t.camera);return{ray:i,frustum:n}}getFrustum(t){return this.updateCamera(t.camera),this.screenRectToFrustum(t.topLeft,t.bottomRight,t.dom,t.camera)}getCorners(t){const e=t.clone().subScalar(this.distance),s=t.clone().addScalar(this.distance);return{bottomLeft:e,topRight:s}}getResult(t){const{hit:e,frustum:s,ray:i,model:n}=t,r={};return this.setPoint(n,e,r),this.setNormal(n,e,r),this.setDistance(n,e,r),this.setRayDistance(n,e,r),this.setBasicHitData(n,e,r,i,s),this.setSnapEdge(n,e,r,"snappedEdgeP1"),this.setSnapEdge(n,e,r,"snappedEdgeP2"),r.facePoints=e.facePoints,r.faceIndices=e.faceIndices,r}updateCamera(t){t.updateProjectionMatrix(),t.updateWorldMatrix(!0,!0)}newCastRequest(t,e,s,i){this.setupMatrix(t);const n={};return n.class=dt.RAYCAST,n.modelId=e,this.setupRay(s,n),Hs.transform(i,this._inverseTransform,this._frustum),n.frustum=this._frustum,n}setSnapEdge(t,e,s,i){if(e[i]){const n=new p;n.copy(e[i]),n.applyMatrix4(t.object.matrixWorld),s[i]=n}else s[i]=void 0}setNormal(t,e,s){if(e.normal){const i=new p;i.copy(e.normal),i.transformDirection(t.object.matrixWorld),i.normalize(),s.normal=i;return}s.normal=void 0}setDistance(t,e,s){const i=Math.sqrt(e.cameraSquaredDistance),n=t.object.matrixWorld.getMaxScaleOnAxis();s.distance=i*n}setPoint(t,e,s){const i=new p;i.copy(e.point),i.applyMatrix4(t.object.matrixWorld),s.point=i}newRaycastSnapResult(t,e,s,i){const n=[];for(const r of t.results){const a=this.getResult({hit:r,frustum:e,ray:s,model:i});n.push(a)}return n}newRectangleCastResponse(t,e){return{localIds:t.localIds,fragments:e.list.get(t.modelId)}}setRayDistance(t,e,s){if(e.raySquaredDistance!==void 0){const i=t.object.matrixWorld.getMaxScaleOnAxis(),n=Math.sqrt(e.raySquaredDistance);s.rayDistance=n*i;return}s.rayDistance=void 0}setBasicHitData(t,e,s,i,n){s.itemId=e.itemId,s.localId=e.localId,s.object=t.object,s.fragments=t,s.ray=i,s.frustum=n,s.representationClass=e.representationClass,s.snappingClass=e.snappingClass}}class Li{async resetVisible(t){await t.threads.invoke(t.modelId,"resetVisible")}async getItemsByVisibility(t,e){return t.threads.invoke(t.modelId,"getItemsByVisibility",[e])}async getVisible(t,e){return t.threads.invoke(t.modelId,"getVisible",[e])}}class He{}c(He,"vertex",`
            #include <common>
            #include <clipping_planes_pars_vertex>

            attribute float itemFilter;
            uniform vec2 lodSize;
            attribute vec3 itemFirst;
            attribute vec3 itemLast;

            float lodWidth = 2.0;
            
            void cutLodLine(const in vec4 first, inout vec4 second ) {
                float projValue1 = projectionMatrix[2][2];
                float projValue2 = projectionMatrix[3][2];
                float approxResult = -(projValue2 / projValue1) / 2.0;
                float diff1 = approxResult - first.z;
                float diff2 = second.z - first.z;
                float cutFilter = diff1 / diff2;
                second.xyz = mix(first.xyz, second.xyz, cutFilter);
            }
                
            void main() {
                if (itemFilter == 0.0) {
                    gl_Position = vec4(0,0,0,0);
                    return;
                }

                vec4 rawFirst = vec4(itemFirst, 1.0);
                vec4 rawLast = vec4(itemLast, 1.0);
                vec4 first = modelViewMatrix * rawFirst;
                vec4 last = modelViewMatrix * rawLast;
                
                bool lodPerspective = projectionMatrix[2][3] == -1.0;
                if (lodPerspective) {
                    bool firstCut = first.z < 0.0 && last.z >= 0.0;
                    bool lastCut = last.z < 0.0 && first.z >= 0.0;
                    if (firstCut) {
                        cutLodLine( first, last );
                    } else if (lastCut) {
                        cutLodLine( last, first );
                    }
                }

                vec4 firstCut = projectionMatrix * first;
                vec4 lastCut = projectionMatrix * last;
                vec3 firstNdc = firstCut.xyz / firstCut.w;
                vec3 lastNdc = lastCut.xyz / lastCut.w;

                vec2 lodOrientation = lastNdc.xy - firstNdc.xy;

                float lodRatio = lodSize.x / lodSize.y;
                lodOrientation.x *= lodRatio;
                lodOrientation = normalize(lodOrientation);
                
                vec2 lodDistance = vec2(lodOrientation.y, - lodOrientation.x);
                lodOrientation.x /= lodRatio;
                lodDistance.x /= lodRatio;

                if (position.x < 0.0) { 
                    lodDistance *= - 1.0;
                }

                if (position.y < 0.0) {
                    lodDistance += -lodOrientation;
                } else if (position.y > 1.0) {
                    lodDistance += lodOrientation;
                }

                lodDistance *= lodWidth;
                lodDistance /= lodSize.y;

                bool isFirst = position.y < 0.5;
                vec4 lodPosition = isFirst ? firstCut : lastCut;
                lodDistance *= lodPosition.w;
                lodPosition.xy += lodDistance;
                gl_Position = lodPosition;

                vec4 mvPosition = isFirst ? first : last;
                #include <clipping_planes_vertex>
            }
    `),c(He,"fragment",`
            #include <common>
            #include <clipping_planes_pars_fragment>

            uniform vec3 lodColor;
            uniform float lodOpacity;

            void main() {
                #include <clipping_planes_fragment>
                gl_FragColor = vec4(lodColor, lodOpacity);
                #include <colorspace_fragment>
            }
    `);const Q=class Q{static setupLodMeshResize(t){t.onBeforeRender=e=>{e.getSize(t.material[0].lodSize)}}static setupLodAttributes(t){t.setIndex(Q.indices),t.setAttribute("position",Q.vertices)}static setLodBuffer(t,e,s){let i=t.getItemFirst(),n=t.getItemLast(),r=this.setItemFirst(t,i,e,n);({itemFirst:i,dataBuffer:r,itemLast:n}=this.resetAttributes(i,r,e,n)),this.setupFinish(s,r),t.setAttribute("itemFirst",i),t.setAttribute("itemLast",n)}static setLodVisibility(t,e){const s=this.setupItemFilter(t);this.applyVisibilityState(t,e,s),s.needsUpdate=!0}static getInterAttribute(t,e){return t.getAttribute(e)}static computeLodSphere(t){if(!t.boundingSphere)return;const e=t.getItemFirst();if(e){const s=Q.getLodMidPoint(t,e),i=Q.getLodRadius(s,e);t.boundingSphere.radius=i}}static newLodMaterialParams(t){const e={lodColor:{value:new Ne(t.color)},lodSize:{value:new fe(1,1)},lodOpacity:{value:t.opacity??1}},s=ms.merge([de.common,e]),i=t.transparent??!1;return{uniforms:s,transparent:i,vertexShader:He.vertex,fragmentShader:He.fragment}}static setLodFilter(t,e){const s=t.getItemFilter(),i=s.array;for(let n=0;n<e.position.length;++n){const r=e.position[n]/2,a=e.size[n]/2;a===4294967295?i.fill(1,r):i.fill(1,r,r+a)}s.needsUpdate=!0}static getInstancedAttribute(t,e){return t.getAttribute(e)}static computeLodBox(t){if(!t.boundingBox)return;const e=t.getItemFirst();if(e){const s=e.data.array;t.boundingBox.setFromArray(s);return}t.boundingBox.makeEmpty()}static setDataBuffer(t,e,s){return t=e.data,t.array=s,t.needsUpdate=!0,t}static disposeAllData(t){delete t.attributes.itemFilter,delete t.attributes.position,t.index=null,t.dispose(),Q.setupLodAttributes(t)}static setItemFirst(t,e,s,i){let n=null;return e&&(s.length===e.data.array.length?n=this.setDataBuffer(n,e,s):(e=void 0,this.disposeAllData(t))),n}static setupFinish(t,e){t&&(e.onUploadCallback=t)}static resetAttributes(t,e,s,i){return t||(e=new je(s,6,1),t=new Wt(e,3,0),i=new Wt(e,3,3)),{itemFirst:t,dataBuffer:e,itemLast:i}}static setupItemFilter(t){const s=t.getItemFirst().count;let i=t.getItemFilter();return i?i.array.fill(0):(i=new ci(new Uint8Array(s),1),t.setAttribute("itemFilter",i)),i}static applyVisibilityState(t,e,s){if(e===!0){s.array.fill(1);return}e&&this.setLodFilter(t,e)}static getLodMidPoint(t,e){const s=t.boundingSphere.center;return this.tempBox.setFromArray(e.data.array),this.tempBox.getCenter(s),s}static getLodRadius(t,e){let s=0;const i=e.data.array.length;for(let n=0;n<i;n+=3){const r=e.data.array;Q.tempVec.fromArray(r,n);const a=t.distanceToSquared(Q.tempVec);s=Math.max(s,a)}return Math.sqrt(s)}};c(Q,"tempVec",new p),c(Q,"tempBox",new Mt),c(Q,"vertices",new es([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),c(Q,"indices",new hi([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5],1));let st=Q;class zs extends _s{constructor(e,s){super(e,s);c(this,"geometry");c(this,"material");this.geometry=e,this.material=s,st.setupLodMeshResize(this)}}class Ri extends Ws{constructor(){super();c(this,"isLODGeometry",!0);st.setupLodAttributes(this)}isFiltered(){return!!this.getItemFilter()}computeBoundingBox(){this.boundingBox||(this.boundingBox=new Mt),st.computeLodBox(this)}applyMatrix4(e){return this.applyTransformToBuffers(e),this.updateBounds(),this}computeBoundingSphere(){this.boundingSphere||(this.boundingSphere=new Ze),st.computeLodSphere(this)}getItemFilter(){return st.getInstancedAttribute(this,"itemFilter")}getItemLast(){return st.getInterAttribute(this,"itemLast")}getItemFirst(){return st.getInterAttribute(this,"itemFirst")}applyTransformToBuffers(e){this.getItemFirst().applyMatrix4(e),this.getItemLast().applyMatrix4(e)}updateBounds(){this.boundingBox&&this.computeBoundingBox(),this.boundingSphere&&this.computeBoundingSphere()}}class Ti extends Ns{constructor(e){super(st.newLodMaterialParams(e));c(this,"isLodMaterial",!0);c(this,"isLineMaterial",!0);this.clipping=!0,this.lights=!1,this.needsUpdate=!0}get lodSize(){return this.uniforms.lodSize.value}set lodColor(e){this.uniforms.lodColor.value=e}set lodSize(e){this.uniforms.lodSize.value.copy(e)}get lodColor(){return this.uniforms.lodColor.value}}class vs{constructor(){c(this,"list",new ws);c(this,"_modelMaterialMapping",new Map);c(this,"_definitions",new Map);c(this,"_idGenerator",new ns);c(this,"white",4294967295)}static resetColors(t){for(const e of t){if(!(e&&e.color))continue;const{color:s}=e;if(s.isColor)continue;const{r:i,g:n,b:r}=s;e.color=new Ne(i,n,r)}}dispose(t){this._definitions.delete(t);const e=this._modelMaterialMapping.get(t);if(e){for(const s of e){const i=this.list.get(s);i&&(i.dispose(),this.list.delete(s))}this._modelMaterialMapping.delete(t)}}get(t,e){const{modelId:s,objectClass:i,currentLod:n,templateId:r}=e;if(!(s&&i!==void 0&&n!==void 0))throw new Error("Fragments: material definition information is missing to create the material.");this._idGenerator.fromMaterialData({modelId:s,objectClass:i,currentLod:n,templateId:r,...t});const{value:a}=this._idGenerator;return this.getUniqueMaterial(a,t,e)}addDefinitions(t,e){const s=this._definitions.get(t);s?s.push(...e):this._definitions.set(t,e)}createHighlights(t,e){const{tileData:{highlightData:s,highlightIds:i},modelId:n,material:r}=e,{geometry:a}=t,l=t.material.slice(0,2),u=new Map,d=this._definitions.get(n);if(!d)return l;for(let f=0;f<s.position.length;f++){const b=i[f];this.processHighlight(u,b,d,r,e,l);const g=s.position[f],_=s.size[f],E=_===this.white?1/0:_;a.addGroup(g,E,u.get(i[f]))}return l}getFromRequest(t){const{material:e,modelId:s}=t,i=this._definitions.get(s),n=i==null?void 0:i[e];if(!n)throw new Error(`Fragments: Missing mesh material for index ${e}`);return this.get(n,t)}newLODMaterial(t,e){const{data:s}=t,i=new Ne(s.color);e.currentLod===Xe.WIRES&&i.multiplyScalar(.85);const n={color:i,...this.getParameters(s)},r=new Ti(n);return r.userData={customId:s.customId},r}getParameters(t){const{opacity:e,transparent:s}=t,i=e<1;return{opacity:e,transparent:s||i,clipIntersection:!1}}new(t,e){const{objectClass:s,templateId:i}=e;let n;if(s===me.SHELL)n=new li({color:t.color,transparent:t.opacity<1,opacity:t.opacity,userData:{customId:t.customId},depthTest:t.depthTest??!0});else if(s===me.LINE)n=this.newLODMaterial({data:t,instancing:i!==void 0},e);else throw new Error("Fragments: Unsupported object class");return n}addMaterialToModel(t,e){let s=this._modelMaterialMapping.get(t);s||(s=new Set,this._modelMaterialMapping.set(t,s)),s.add(e)}processHighlight(t,e,s,i,n,r){if(!t.has(e)){const a=s[i],l=s[e],u={...a,...l},d=this.get(u,n);r.push(d),t.set(e,r.length-1)}}getUniqueMaterial(t,e,s){const i=s.modelId;let n=this.list.get(t);return n||(n=this.new(e,s),this.list.set(t,n),this.addMaterialToModel(i,t),n)}}class Oi{async getHighlight(t,e){const s=await t.threads.invoke(t.modelId,"getHighlight",[e]);return vs.resetColors(s),s}async highlight(t,e,s){await t.threads.invoke(t.modelId,"highlight",[e,s])}async getHighlightItemIds(t){return t.threads.invoke(t.modelId,"getHighlightItemIds")}async resetHighlight(t,e){await t.threads.invoke(t.modelId,"resetHighlight",[e])}}class Vi{async getSection(t,e,s){const i=[e,s];return await t.threads.invoke(t.modelId,"getSection",i)}}class Wi{async dispose(t,e,s){e.list.delete(t.modelId),await this.requestModelDelete(t),t.threads.delete(t.modelId),this.deleteAllTiles(t),e.materials.dispose(t.modelId),s.dispose()}async getBuffer(t,e){return t.threads.invoke(t.modelId,"getBuffer",[e])}async getCategories(t){return t.threads.invoke(t.modelId,"getCategories")}async getMaxLocalId(t){return t.threads.invoke(t.modelId,"getMaxLocalId")}async getLocalIdsByGuids(t,e){return t.threads.invoke(t.modelId,"getLocalIdsByGuids",[e])}async getSpatialStructure(t){return t.threads.invoke(t.modelId,"getSpatialStructure")}async getItemsWithGeometry(t){return(await t.threads.invoke(t.modelId,"getItemsWithGeometry",[])).map(i=>t.getItem(i))}async getItemsWithGeometryCategories(t){return t.threads.invoke(t.modelId,"getItemsWithGeometryCategories",[])}async getItemsIdsWithGeometry(t){return t.threads.invoke(t.modelId,"getItemsWithGeometry",[])}async getItemsOfCategories(t,e){const s=[e];return await t.threads.invoke(t.modelId,"getItemsOfCategories",s)}async getItemsByQuery(t,e){const s=[e];return await t.threads.invoke(t.modelId,"getItemsByQuery",s)}async getMetadata(t){return t.threads.invoke(t.modelId,"getMetadata",[])}async getGuidsByLocalIds(t,e){return t.threads.invoke(t.modelId,"getGuidsByLocalIds",[e])}async requestModelDelete(t){await t.threads.fetch({class:dt.DELETE_MODEL,modelId:t.modelId})}deleteAllTiles(t){for(const[e]of t.tiles)t.tiles.delete(e)}}class Ni{async getSequenced(t,e,s,i){const n=[e,s,i];return await t.threads.invoke(t.modelId,"getSequenced",n)}}class ji{constructor(t,e,s){c(this,"attrsChanges",new Map);c(this,"relsChanges",new Map);c(this,"threads");c(this,"tiles",new ws);c(this,"object",new ui);c(this,"graphicsQuality",0);c(this,"_boxManager",new Ai);c(this,"_itemsManager",new Fi);c(this,"_coordinatesManager",new Pi);c(this,"_setupManager",new Si);c(this,"_viewManager",new Di);c(this,"_raycastManager",new Bi);c(this,"_visibilityManager",new Li);c(this,"_highlightManager",new Oi);c(this,"_sectionManager",new Vi);c(this,"_dataManager",new Wi);c(this,"_sequenceManager",new Ni);c(this,"_bbox",new Mt);c(this,"_alignmentsManager");c(this,"_meshManager");c(this,"_isProcessing",!1);c(this,"_isLoaded",!1);c(this,"_frozen",!1);c(this,"_isSetup",!1);this.object.name=t,this.object.up.set(0,0,1),this._meshManager=e,this.threads=s,this._alignmentsManager=new Ii(this),this.tiles.onItemSet.add(({value:i})=>this.object.add(i)),this.tiles.onBeforeDelete.add(({value:i})=>{this.object.remove(i),i.geometry.dispose(),Ut.forEach(i.material,n=>n.dispose())})}get modelId(){return this.object.name}get box(){return this._bbox.clone().applyMatrix4(this.object.matrixWorld)}get isBusy(){const t=this._meshManager.requests.arePending;return!this._isLoaded||this._isProcessing||t}get frozen(){return!!this._frozen}set frozen(t){t!==this._frozen&&(this._frozen=t,!t&&this._refreshView())}get getClippingPlanesEvent(){return this._viewManager.getClippingPlanesEvent}set getClippingPlanesEvent(t){this._viewManager.getClippingPlanesEvent=t}async dispose(){this._isLoaded=!1,await this._dataManager.dispose(this,this._meshManager,this._alignmentsManager)}async getSpatialStructure(){return this._dataManager.getSpatialStructure(this)}async getLocalIdsByGuids(t){return this._dataManager.getLocalIdsByGuids(this,t)}async getCategories(){return this._dataManager.getCategories(this)}async getItemsWithGeometryCategories(){return this._dataManager.getItemsWithGeometryCategories(this)}async getItemsWithGeometry(){return this._dataManager.getItemsWithGeometry(this)}async getItemsIdsWithGeometry(){return this._dataManager.getItemsIdsWithGeometry(this)}async getMetadata(){return this._dataManager.getMetadata(this)}async getGuidsByLocalIds(t){return this._dataManager.getGuidsByLocalIds(this,t)}async getBuffer(t=!1){return this._dataManager.getBuffer(this,t)}async getItemsOfCategories(t){return this._dataManager.getItemsOfCategories(this,t)}async getGuids(){return await this.threads.invoke(this.modelId,"getGuids",[])}async getLocalIds(){return await this.threads.invoke(this.modelId,"getLocalIds",[])}async getItemsByQuery(t){return this._dataManager.getItemsByQuery(this,t)}async getItemsMaterialDefinition(t){return await this.threads.invoke(this.modelId,"getItemsMaterialDefinition",[t])}async getItemsGeometry(t){return await this.threads.invoke(this.modelId,"getItemsGeometry",[t])}async getItemsVolume(t){return await this.threads.invoke(this.modelId,"getItemsVolume",[t])}async getAttributeNames(){return await this.threads.invoke(this.modelId,"getAttributeNames",[])}async getAttributeValues(){return await this.threads.invoke(this.modelId,"getAttributeValues",[])}async getAttributesUniqueValues(t){return await this.threads.invoke(this.modelId,"getAttributesUniqueValues",[t])}async getAttributeTypes(){return await this.threads.invoke(this.modelId,"getAttributeTypes",[])}async getRelationNames(){return await this.threads.invoke(this.modelId,"getRelationNames",[])}async getMaxLocalId(){return this._dataManager.getMaxLocalId(this)}getItem(t){return this._itemsManager.getItem(this,t)}async getItemsChildren(t){return this._itemsManager.getItemsChildren(this,t)}async getItemsData(t,e){return this._itemsManager.getItemsData(this,t,e)}async getPositions(t){return this._coordinatesManager.getPositions(this,t)}async getCoordinates(){return this._coordinatesManager.getCoordinates(this)}async getCoordinationMatrix(){return this._coordinatesManager.getCoordinationMatrix(this)}async getMergedBox(t){return this._boxManager.getMergedBox(this,t)}async getBoxes(t){return this._boxManager.getBoxes(this,t)}async getAlignments(){return this._alignmentsManager.getAlignments()}async getHorizontalAlignments(){return this._alignmentsManager.getHorizontalAlignments()}async getVerticalAlignments(){return this._alignmentsManager.getVerticalAlignments()}getAlignmentStyles(){return this._alignmentsManager.getAlignmentStyles()}useCamera(t){this._viewManager.useCamera(t)}async rectangleRaycast(t){return this._raycastManager.rectangleRaycast(this,this._meshManager,t)}async raycast(t){return this._raycastManager.raycast(this,t)}async raycastWithSnapping(t){return this._raycastManager.raycastWithSnapping(this,t)}async setVisible(t,e){const s=[t,e];await this.threads.invoke(this.modelId,"setVisible",s)}async toggleVisible(t){const e=[t];await this.threads.invoke(this.modelId,"toggleVisible",e)}async getItemsByVisibility(t){return this._visibilityManager.getItemsByVisibility(this,t)}async getVisible(t){return this._visibilityManager.getVisible(this,t)}async resetVisible(){return this._visibilityManager.resetVisible(this)}async highlight(t,e){return this._highlightManager.highlight(this,t,e)}async getHighlight(t){return this._highlightManager.getHighlight(this,t)}async resetHighlight(t){return this._highlightManager.resetHighlight(this,t)}async getHighlightItemIds(){return this._highlightManager.getHighlightItemIds(this)}async getSection(t,e){return this._sectionManager.getSection(this,t,e)}async getSequenced(t,e,s){return this._sequenceManager.getSequenced(this,t,e,s)}async handleRequest(t){await this._meshManager.requests.handleRequest(this._meshManager,t)}_finishProcessing(){this._isProcessing=!1}async _refreshView(){this.frozen||(this._isProcessing=!0,await this._viewManager.refreshView(this,this._meshManager))}async _setup(t,e,s){this._isSetup||(this._setupManager.setup(this,this._bbox,t,e,s),this._isLoaded=!0,this._isProcessing=!0,this._isSetup=!0)}}class Ui{constructor(){c(this,"list",[]);c(this,"onFinish",()=>{})}get arePending(){return this.list.length>0}async handleRequest(t,e){if(e.class===dt.RECOMPUTE_MESHES)this.add(e.list),e.list=void 0;else if(e.class===dt.CREATE_MATERIAL){const{materialDefinitions:s,modelId:i}=e;vs.resetColors(s),t.materials.addDefinitions(i,s),e.materialDefinitions=void 0}else e.class===dt.THROW_ERROR&&console.error(e)}add(t){for(const e of t)this.insert(e)||this.list.push(e),e.tileRequestClass===N.FINISH&&this.onFinish()}clean(t){const e=this.list.filter(s=>s.modelId!==t||s.tileRequestClass!==N.FINISH);this.list=e}insert(t){const{modelId:e,tileId:s,tileRequestClass:i,tileData:n}=t;if(s===void 0)return!1;if(i===N.DELETE){const r=this.list.filter(a=>!((a.tileRequestClass===N.CREATE||a.tileRequestClass===N.DELETE)&&a.modelId===e&&a.tileId===s));this.list=r}if(i===N.CREATE){const r=this.list.filter(a=>!(a.tileRequestClass===N.CREATE&&a.modelId===e&&a.tileId===s));this.list=r}if(i===N.UPDATE){const r=this.list.find(a=>a.modelId===e&&a.tileId===s);if(r)return(r.tileRequestClass===N.CREATE||r.tileRequestClass===N.UPDATE)&&(r.tileData=n),!0}return!1}}class Hi{constructor(t){c(this,"_materials");c(this,"white",4294967295);this._materials=t}createMesh(t,e){const s=this._materials.getFromRequest(e);if(!("isLodMaterial"in s&&s.isLodMaterial))throw new Error("Fragments: material is not an instance of LodMaterial.");const{positions:i}=e;if(!i)throw new Error("Fragments: no positions provided to create the LOD mesh.");const n=new Ri,r=this.deleteAttributeEvent(t);return st.setLodBuffer(n,i,r),new zs(n,[s])}updateVisibility(t,e){const{geometry:s}=t,{visibilityData:i,highlightData:n}=e;st.setLodVisibility(s,i),n?(st.setLodFilter(s,n),rs.getComplementary(n,(r,a)=>{s.addGroup(r,a,0)})):s.addGroup(0,1/0,0)}processMesh(t,e){const{geometry:s}=t,{tileData:{visibilityData:i},currentLod:n}=e;if(n===Xe.WIRES&&t instanceof zs)this.updateVisibility(t,e.tileData);else if(i&&i.position.length>0)for(let r=0;r<i.position.length;++r){const a=i.size[r]===this.white,l=i.position[r],u=a?1/0:i.size[r];s.addGroup(l,u,0)}}deleteAttributeEvent(t){function e(){delete this.array}return e}}class Gi{constructor(t){c(this,"list",new ws);c(this,"materials",new vs);c(this,"lod",new Hi(this.materials));c(this,"requests",new Ui);c(this,"updateThreshold",4);c(this,"_updateFinished",!0);c(this,"_onUpdate");this._onUpdate=t,this.requests.onFinish=()=>this._updateFinished=!0}forceUpdateFinish(t=200){return new Promise(s=>{this._updateFinished=!1;const i=setInterval(()=>{this.update(),this._updateFinished&&(clearInterval(i),s())},t)})}update(){const t=performance.now();for(;this.requests.arePending;){const e=this.requests.list.shift();if(e&&(this.processTileRequest(e),this._onUpdate(),performance.now()-t>this.updateThreshold))return}}setTileData(t,e){const{tileId:s,itemId:i,matrix:n,aabb:r}=e;this.setMeshData(t,s,i,n),this.setupBoundings(t,r),this.updateStatus(t,e)}processTileRequest(t){const{tileRequestClass:e,tileId:s,modelId:i}=t,n=this.list.get(i);if(n)if(e===N.CREATE){const r=this.create(t);this.setTileData(r,t),n.tiles.set(r.userData.tileId,r)}else if(e===N.DELETE)n.tiles.delete(s);else if(e===N.UPDATE){const r=n.tiles.get(s);r&&this.updateStatus(r,t)}else e===N.FINISH&&n._finishProcessing()}createMesh(t){const{indices:e,positions:s,normals:i,itemIds:n,faceIds:r}=t,a=new ss;this.setIndex(a,e),this.setPositions(s,a),this.setNormals(i,a),this.setItemIds(n,a),this.setFaceIds(r,a);const l=this.materials.getFromRequest(t);return new _s(a,[l])}setupBoundings(t,e){const{geometry:s}=t,i=new Mt().copy(e),n=new Ze;i.getBoundingSphere(n),s.boundingBox=i,s.boundingSphere=n}create(t){if(t.objectClass===me.SHELL)return this.createMesh(t);if(t.objectClass===me.LINE){const e=new ss;return this.lod.createMesh(e,t)}throw new Error(`Fragments: object class ${t.objectClass} is not supported.`)}updateStatus(t,e){const{tileData:{highlightData:s},currentLod:i}=e,{geometry:n}=t;if(n.clearGroups(),this.lod.processMesh(t,e),!(s&&i!==Xe.WIRES))return;const r=this.materials.createHighlights(t,e);t.material=r}cleanAttributeMemory(t,e){t.attributes[e].onUpload(this.deleteAttribute(t))}setPositions(t,e){if(!t)throw new Error("Fragments: no positions provided to create the mesh.");e.setAttribute("position",new Jt(t,3)),this.cleanAttributeMemory(e,"position")}setFaceIds(t,e){t&&(e.setAttribute("color",new Jt(t,3)),this.cleanAttributeMemory(e,"color"))}setIndex(t,e){if(!e)throw new Error("Fragments: no indices provided to create the mesh.");t.setIndex(new Jt(e,1)),t.index.onUpload(this.deleteAttribute(t))}setNormals(t,e){t&&e.setAttribute("normal",new Jt(t,3,!0)),this.cleanAttributeMemory(e,"normal")}setItemIds(t,e){t&&(e.setAttribute("id",new Jt(t,1,!1)),this.cleanAttributeMemory(e,"id"))}deleteAttribute(t){function e(){delete this.array}return e}setMeshData(t,e,s,i){t.userData={tileId:e,itemId:s},t.matrixAutoUpdate=!1,t.applyMatrix4(i),t.matrix.copy(i)}}class ki{constructor(){c(this,"_list",new Map);c(this,"_communicationKey",0)}setupInput(t){t.requestId=this._communicationKey++}set(t,e,s){const i=this.newHandler(e,s);this._list.set(t,i)}run(t){const e=this._list.get(t.requestId);this._list.delete(t.requestId),e(t)}newHandler(t,e){return s=>{if(s.errorInfo){t(s.errorInfo);return}e(s)}}}class X{static newThread(t){return new Worker(t,{type:"module"})}static newUpdater(t,e){return setInterval(t,e)}static getMeshComputeRequest(t,e){return{class:dt.RECOMPUTE_MESHES,modelId:t,list:e}}static planeSet(t){const e=[];for(const s of t){const i=this.array(s.normal),n=s.constant,r=new Bt(i,n);e.push(r)}return e}static data(t){var I,E;if((t==null?void 0:t.elements)!==void 0)return X.transform(t);if((t==null?void 0:t.origin)!==void 0&&(t==null?void 0:t.direction)!==void 0)return X.beam(t);if((t==null?void 0:t.planes)!==void 0)return X.frustum(t);const n=(t==null?void 0:t.normal)!==void 0,r=(t==null?void 0:t.constant)!==void 0;if(n&&r)return X.plane(t);const l=((I=t[0])==null?void 0:I.normal)!==void 0,u=((E=t[0])==null?void 0:E.constant)!==void 0;if(l&&u)return X.planeSet(t);const f=(t==null?void 0:t.x)!==void 0,b=(t==null?void 0:t.y)!==void 0,g=(t==null?void 0:t.z)!==void 0;return f&&b&&g?X.array(t):t}static getExecuteRequest(t,e,s){const i=Array.from(s);return{class:dt.EXECUTE,modelId:t,function:e,parameters:i}}static plane(t){const e=this.array(t.normal),s=t.constant;return new Bt(e,s)}static getRequestContent(t){const e=[];for(const s of t.list)X.setupCreateRequest(s,e),X.setupUpdateRequest(s,e);return e}static array(t){const e=new p;return e.set(t.x,t.y,t.z),e}static cleanRequests(t){const e=[],s=X;for(const i of t)s.isFinishRequest(i)||e.push(i);return e}static frustum(t){const e=this.planeSet(t.planes),[s,i,n,r,a,l]=e;return new ge(s,i,n,r,a,l)}static beam(t){const e=this.array(t.origin),s=this.array(t.direction);return new bs(e,s)}static transform(t){const e=new pt;return e.copy(t),e}static deleteUpdater(t){clearInterval(t)}static areCoresAvailable(t){const e=X.getCpuCapacity(),s=Math.max(e,2);return t<s}static isFinishRequest(t){return t.tileRequestClass===N.FINISH}static setupUpdateRequest(t,e){t.tileRequestClass===N.UPDATE&&this.addAllTileData(t,e)}static getCpuCapacity(){var e;return(e=globalThis.navigator)!=null&&e.hardwareConcurrency?navigator.hardwareConcurrency-3:0}static addAllTileData(t,e){this.addRequestTileData(t,e,"visibilityData");const s=["highlightIds"];this.addRequestTileData(t,e,"highlightData",s)}static addRequestContent(t,e,s){if(!e[t])return;const i=e[t].buffer;s.push(i)}static addRequestTileData(t,e,s,i=[]){const n=t.tileData[s];if(n){e.push(n.position.buffer),e.push(n.size.buffer);for(const r of i)e.push(t.tileData[r].buffer)}}static setupCreateRequest(t,e){if(t.tileRequestClass!==N.CREATE)return;const s=this.getCreateRequestIds();for(const i of s)this.addRequestContent(i,t,e);this.addAllTileData(t,e)}static getCreateRequestIds(){return["positions","indices","normals","itemIds"]}}class qi{constructor(t){c(this,"_handlers",new ki);c(this,"_handleInput");c(this,"_port");c(this,"onInput",t=>{if(t.data.toMainThread){this._handlers.run(t.data);return}this.manageInput(t.data)});this._handleInput=t}fetchMeshCompute(t,e){const s=X,i=s.getMeshComputeRequest(t,e),n=s.getRequestContent(i);this.fetch(i,n)}fetch(t,e){return this._handlers.setupInput(t),new Promise((s,i)=>{this._handlers.set(t.requestId,i,s),this.executeConnection(t,e)})}init(t){this._port=t,this.initConnection(t)}initConnection(t){t.onmessage=this.onInput}async fetchConnection(t){if(!this._port)throw new Error("Fragments: Connection not initialized");return this._port}async executeConnection(t,e){(await this.fetchConnection(t)).postMessage(t,e)}async manageOutput(t){const e=await this.fetchConnection(t);t.toMainThread=!0,e.postMessage(t)}async manageConnection(t){try{await this._handleInput(t)}catch(e){t.errorInfo=e.toString(),console.error(e)}}async manageInput(t){await this.manageConnection(t),await this.manageOutput(t)}}class Zi{constructor(t){c(this,"_modelThread",new Map);c(this,"_threadsModelAmount",new Map);c(this,"_threadPort",new Map);c(this,"_threadPath");c(this,"_placeholder");this._placeholder={},this._threadPath=t}get path(){return this._threadPath}usePlaceholder(t){this._modelThread.set(t,this._placeholder)}getAmount(t){return this._threadsModelAmount.get(t)}getThread(t){return this._modelThread.get(t)}getAndCheckThread(t){const e=this._modelThread.get(t);if(e===this._placeholder)throw new Error("Fragments: Error fetching thread!");return e}set(t,e){this._modelThread.set(t,e)}deleteModel(t){const e=this.getThreadSafe(t),i=this.getAmountSafe(e)-1;this.setAmount(e,i),this._modelThread.delete(t)}getThreadSafe(t){const e=this.getThread(t);if(!e)throw new Error(`Fragments: Thread for model ${t} not found`);return e}deleteThread(t){this._threadsModelAmount.delete(t),this._threadPort.delete(t),t.terminate()}getThreadAmount(){return this._threadsModelAmount.size}balanceThreadLoad(t){const{lessBusyThread:e,modelAmount:s}=this.getLessBusyThread();return this._threadsModelAmount.set(e,s+1),this._modelThread.set(t.modelId,e),this._threadPort.get(e)}getAmountSafe(t){const e=this.getAmount(t);if(!e)throw new Error(`Fragments: Amount for thread ${t} not found`);return e}setPort(t,e){this._threadPort.set(t,e)}setAmount(t,e){this._threadsModelAmount.set(t,e)}getPort(t){return this._threadPort.get(t)}getLessBusyThread(){let t=Number.MAX_VALUE,e=this._threadsModelAmount.keys().next().value;for(const[s,i]of this._threadsModelAmount)i<t&&(t=i,e=s);return{lessBusyThread:e,modelAmount:t}}}class Xi extends qi{constructor(e,s){super(e);c(this,"_data");this._data=new Zi(s)}delete(e){const s=this._data.getThreadSafe(e),i=this._data.getAmountSafe(s)-1;this._data.deleteModel(e),i===0&&this._data.deleteThread(s)}async invoke(e,s,i=[]){const r=X.getExecuteRequest(e,s,i);return(await this.fetch(r)).result}async fetchConnection(e){const s=this._data.getAndCheckThread(e.modelId);return s?this._data.getPort(s):this.setupNewThread(e)}setupNewThread(e){const s=X;this._data.usePlaceholder(e.modelId);const i=this._data.getThreadAmount();return s.areCoresAvailable(i)?this.newThread(e,this._data.path):this._data.balanceThreadLoad(e)}setupThread(e){const s=new MessageChannel,i=s.port1,n=s.port2;this.initConnection(i),this._data.setPort(e,i),e.postMessage(n,[n])}newThread(e,s){const i=X.newThread(s);return this.setupThread(i),this._data.setAmount(i,1),this._data.set(e.modelId,i),this._data.getPort(i)}}const Yi=2**15-1,F=class F{static getProfile(t,e,s){return t.type()===bt.BIG?t.bigProfiles(e,s):t.profiles(e,s)}static getPoints(t){const e=new Float32Array(t.pointsLength()*3);for(let s=0;s<t.pointsLength();s++)t.points(s,this._tempPoint),e[s*3]=this._tempPoint.x(),e[s*3+1]=this._tempPoint.y(),e[s*3+2]=this._tempPoint.z();return e}static getProfileIndices(t,e){const s=t.type()===bt.BIG,i={outer:[],inners:[]},n=s?t.bigHolesLength():t.holesLength(),r=s?"bigHoles":"holes",a=F.getProfile(t,e);i.outer=Array.from(a.indicesArray());for(let l=0;l<n;l++){const u=t[r](l);if(u.profileId()===e){const d=Array.from(u.indicesArray());i.inners.push(d)}}return i}static getHole(t,e,s){return t.type()===bt.BIG?t.bigHoles(e,s):t.holes(e,s)}static getProfilesLength(t){return t.type()===bt.BIG?t.bigProfilesLength():t.profilesLength()}static getHolesLength(t){return t.type()===bt.BIG?t.bigHolesLength():t.holesLength()}static getShell(t,e){return t.shells(e,this._shell)}static point(t,e,s){t instanceof $&&t.points(e,this._tempPoint);const i=this._tempPoint.x(),n=this._tempPoint.y(),r=this._tempPoint.z();s.set(i,n,r)}static getNormalsOfShellProfile(t,e){const s=F.getProfilesLength(t);for(let i=0;i<s;i++){const n=F.getProfile(t,i),r=this.fetchNormalsOfProfile(t,n);e.push(r)}return e}static computeNormalsAvg(t,e,s,i){this.setupNormalBuffer(t);const n=s[e];for(let r=0;r<t.length;r++){const a=t[r],l=i.get(a);this.aggregateNormals(l,s,n),this.computeAvgNormal(r)}return this._normalBuffer}static getBuffer(t){const e=t.bb,i=e.__offset(t.bb_pos,8),n=t.pointsLength()*3,r=e.__vector(t.bb_pos+i),l=e.bytes().buffer;return new Float32Array(l,r,n)}static getPointsShell(t){return this._pointsByProfile.clear(),this.fetchAllPointsByProfile(t),F.fetchAllPointsByHole(t),this._pointsByProfile}static addNormals(t,e,s){for(const i of t){const n=e[i];s.dot(n)>this._faceThreshold&&this._tempNormal.add(n)}}static setupNormalBuffer(t){const e=t.length*3;this._normalBuffer.length<e&&(this._normalBuffer=new Int16Array(e))}static fetchNormalsOfProfile(t,e){const s=e.indicesLength();return this.isTooSmall(t,s)?new p(1,0,0):this.computeProfileNormal(s,e,t)}static fetchAllPointsByHole(t){const e=F.getHolesLength(t),s=this.getTempHole(t);for(let i=0;i<e;i++){F.getHole(t,i,s);const n=s.profileId(),r=s.indicesLength();for(let a=0;a<r;a++){const l=s.indices(a);F.savePointByProfile(l,n)}}}static computeProfileNormal(t,e,s){this._v3.set(0,0,0);for(let n=0;n<t;n++)this.fetchPointsForNormal(n,t,e,s),this.computeProfilePointNormal();const i=this._v3.clone();return i.normalize(),i}static computeProfilePointNormal(){const t=this._v1.x-this._v2.x,e=this._v1.y-this._v2.y,s=this._v1.z-this._v2.z,i=this._v1.x+this._v2.x,n=this._v1.y+this._v2.y,r=this._v1.z+this._v2.z;this._v3.x+=e*r,this._v3.y+=s*i,this._v3.z+=t*n}static aggregateNormals(t,e,s){if(this._tempNormal.set(0,0,0),!t||!t.length){this._tempNormal.set(1,0,0);return}if(t.length===1){const r=t[0];this._tempNormal=e[r].clone();return}F.addNormals(t,e,s)}static fetchPointsForNormal(t,e,s,i){const r=(t+1)%e,a=s.indices(t),l=s.indices(r);this.point(i,a,this._v1),this.point(i,l,this._v2)}static savePointByProfile(t,e){this._pointsByProfile.has(t)||this._pointsByProfile.set(t,[]),this._pointsByProfile.get(t).push(e)}static isTooSmall(t,e){const s=t.pointsLength()<=2,i=e<=2;return s||i}static fetchAllPointsByProfile(t){const e=this.getProfilesLength(t),s=this.getTempProfile(t);for(let i=0;i<e;i++){F.getProfile(t,i,s);const n=s.indicesLength();for(let r=0;r<n;r++){const a=s.indices(r);F.savePointByProfile(a,i)}}}static computeAvgNormal(t){this._tempNormal.normalize(),this._tempNormal.multiplyScalar(Yi),this._tempNormal.toArray(this._normalBuffer,t*3)}static getTempProfile(t){return t.type()===bt.BIG?this._bigShellProfile:this._shellProfile}static getTempHole(t){return t.type()===bt.BIG?this._bigShellHole:this._shellHole}};c(F,"_faceThreshold",Math.cos(Math.PI/8)),c(F,"_shell",new $),c(F,"_normalBuffer",new Int16Array),c(F,"_tempNormal",new p),c(F,"_tempPoint",new Y),c(F,"_shellProfile",new Ot),c(F,"_bigShellProfile",new Tt),c(F,"_shellHole",new St),c(F,"_bigShellHole",new It),c(F,"_pointsByProfile",new Map),c(F,"_v1",new p),c(F,"_v2",new p),c(F,"_v3",new p);let Fs=F;function Qi(o,t,e,s,i,n){const r=t&&t.length,a=r?t[0]*e:o.length;let l=Zs(o,0,a,e,!0,s,i);if(!l||l.next===l.prev)return;let u,d,f;if(r&&(l=en(o,t,l,e,s,i)),o.length>80*e){let b=o[s],g=o[i];u=b,d=g;for(let _=e;_<a;_+=e){const I=o[_+s],E=o[_+i];I<u&&(u=I),E<d&&(d=E),I>b&&(b=I),E>g&&(g=E)}f=Math.max(b-u,g-d),f=f!==0?1/f:0}_e(l,n,e,u,d,f)}function Zs(o,t,e,s,i,n,r){let a,l,u;if(i===dn(o,t,e,s,n,r)>0)for(u=t;u<e;u+=s)a=Ds(u,o[u+n],o[u+r],a);else for(u=e-s;u>=t;u-=s)a=Ds(u,o[u+n],o[u+r],a);return a&&Ye(a,a.next)&&(l=a.next,we(a),a=l),a}function Nt(o,t){if(!o)return o;t||(t=o);let e=o,s,i;do if(s=!1,!e.steiner&&(Ye(e,e.next)||B(e.prev,e,e.next)===0)){if(i=e.prev,we(e),e=t=i,e===e.next)break;s=!0}else e=e.next;while(s||e!==t);return t}function _e(o,t,e,s,i,n,r){!r&&n&&an(o,s,i,n);let a=o;for(;o.prev!==o.next;){const l=o.prev,u=o.next;if(n?Ki(o,s,i,n):$i(o)){t(l.i/e,o.i/e,u.i/e),we(o),o=u.next,a=u.next;continue}if(o=u,o===a){r?r===1?(o=Ji(Nt(o),t,e),_e(o,t,e,s,i,n,2)):r===2&&tn(o,t,e,s,i,n):_e(Nt(o),t,e,s,i,n,1);break}}}function $i(o){const t=o.prev,e=o,s=o.next;if(B(t,e,s)>=0)return!1;let i=o.next.next;for(;i!==o.prev;){if(ee(t.x,t.y,e.x,e.y,s.x,s.y,i.x,i.y)&&B(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function Ki(o,t,e,s){const i=o.prev,n=o,r=o.next;if(B(i,n,r)>=0)return!1;const a=Math.min(i.x,n.x,r.x),l=Math.min(i.y,n.y,r.y),u=Math.max(i.x,n.x,r.x),d=Math.max(i.y,n.y,r.y),f=os(a,l,t,e,s),b=os(u,d,t,e,s);let g=o.prevZ,_=o.nextZ;for(;g&&g.z>=f&&_&&_.z<=b;){if(g!==o.prev&&g!==o.next&&ee(i.x,i.y,n.x,n.y,r.x,r.y,g.x,g.y)&&B(g.prev,g,g.next)>=0||(g=g.prevZ,_!==o.prev&&_!==o.next&&ee(i.x,i.y,n.x,n.y,r.x,r.y,_.x,_.y)&&B(_.prev,_,_.next)>=0))return!1;_=_.nextZ}for(;g&&g.z>=f;){if(g!==o.prev&&g!==o.next&&ee(i.x,i.y,n.x,n.y,r.x,r.y,g.x,g.y)&&B(g.prev,g,g.next)>=0)return!1;g=g.prevZ}for(;_&&_.z<=b;){if(_!==o.prev&&_!==o.next&&ee(i.x,i.y,n.x,n.y,r.x,r.y,_.x,_.y)&&B(_.prev,_,_.next)>=0)return!1;_=_.nextZ}return!0}function Ji(o,t,e){let s=o;do{const i=s.prev,n=s.next.next;!Ye(i,n)&&Xs(i,s,s.next,n)&&be(i,n)&&be(n,i)&&(t(i.i/e,s.i/e,n.i/e),we(s.next),we(s),s=o=n),s=s.next}while(s!==o);return Nt(s)}function tn(o,t,e,s,i,n){let r=o;do{let a=r.next.next;for(;a!==r.prev;){if(r.i!==a.i&&ln(r,a)){let l=Ys(r,a);r=Nt(r,r.next),l=Nt(l,l.next),_e(r,t,e,s,i,n),_e(l,t,e,s,i,n);return}a=a.next}r=r.next}while(r!==o)}function en(o,t,e,s,i,n){const r=[];for(let a=0,l=t.length;a<l;a++){const u=t[a]*s,d=a<l-1?t[a+1]*s:o.length,f=Zs(o,u,d,s,!1,i,n);f===f.next&&(f.steiner=!0),r.push(hn(f))}r.sort(sn);for(let a=0;a<r.length;a++)e=nn(r[a],e),e=Nt(e,e.next);return e}function sn(o,t){return o.x-t.x}function nn(o,t){const e=rn(o,t);if(!e)return t;const s=Ys(e,o),i=Nt(e,e.next);return Nt(s,s.next),t===t.next||e===t?i:t}function rn(o,t){let e=t;const s=o.x,i=o.y;let n=-1/0,r;do{if(i<=e.y&&i>=e.next.y&&e.next.y!==e.y){const f=e.x+(i-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(f<=s&&f>n){if(n=f,f===s){if(i===e.y)return e;if(i===e.next.y)return e.next}r=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!r)return null;if(s===n)return r;const a=r,l=r.x,u=r.y;let d=1/0;e=r;do{if(s>=e.x&&e.x>=l&&s!==e.x&&ee(i<u?s:n,i,l,u,i<u?n:s,i,e.x,e.y)){const f=Math.abs(i-e.y)/(s-e.x);be(e,o)&&(f<d||f===d&&(e.x>r.x||e.x===r.x&&on(r,e)))&&(r=e,d=f)}e=e.next}while(e!==a);return r}function on(o,t){return B(o.prev,o,t.prev)<0&&B(t.next,o,o.next)<0}function an(o,t,e,s){let i=o;do i.z===null&&(i.z=os(i.x,i.y,t,e,s)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==o);i.prevZ.nextZ=null,i.prevZ=null,cn(i)}function cn(o){let t=1,e;do{let s=o,i;o=null;let n=null;for(e=0;s;){e++;let r=s,a=0;for(let u=0;u<t&&(a++,r=r.nextZ,!!r);u++);let l=t;for(;a>0||l>0&&r;)a!==0&&(l===0||!r||s.z<=r.z)?(i=s,s=s.nextZ,a--):(i=r,r=r.nextZ,l--),n?n.nextZ=i:o=i,i.prevZ=n,n=i;s=r}n.nextZ=null,t*=2}while(e>1);return o}function os(o,t,e,s,i){return o=32767*(o-e)*i,t=32767*(t-s)*i,o=(o|o<<8)&16711935,o=(o|o<<4)&252645135,o=(o|o<<2)&858993459,o=(o|o<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,o|t<<1}function hn(o){let t=o,e=o;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==o);return e}function ee(o,t,e,s,i,n,r,a){return(i-r)*(t-a)-(o-r)*(n-a)>=0&&(o-r)*(s-a)-(e-r)*(t-a)>=0&&(e-r)*(n-a)-(i-r)*(s-a)>=0}function ln(o,t){return o.next.i!==t.i&&o.prev.i!==t.i&&!un(o,t)&&(be(o,t)&&be(t,o)&&fn(o,t)&&(B(o.prev,o,t.prev)||B(o,t.prev,t))||Ye(o,t)&&B(o.prev,o,o.next)>0&&B(t.prev,t,t.next)>0)}function B(o,t,e){return(t.y-o.y)*(e.x-t.x)-(t.x-o.x)*(e.y-t.y)}function Ye(o,t){return o.x===t.x&&o.y===t.y}function Xs(o,t,e,s){const i=Le(B(o,t,e)),n=Le(B(o,t,s)),r=Le(B(e,s,o)),a=Le(B(e,s,t));return!!(i!==n&&r!==a||i===0&&Be(o,e,t)||n===0&&Be(o,s,t)||r===0&&Be(e,o,s)||a===0&&Be(e,t,s))}function Be(o,t,e){return t.x<=Math.max(o.x,e.x)&&t.x>=Math.min(o.x,e.x)&&t.y<=Math.max(o.y,e.y)&&t.y>=Math.min(o.y,e.y)}function Le(o){return o>0?1:o<0?-1:0}function un(o,t){let e=o;do{if(e.i!==o.i&&e.next.i!==o.i&&e.i!==t.i&&e.next.i!==t.i&&Xs(e,e.next,o,t))return!0;e=e.next}while(e!==o);return!1}function be(o,t){return B(o.prev,o,o.next)<0?B(o,t,o.next)>=0&&B(o,o.prev,t)>=0:B(o,t,o.prev)<0||B(o,o.next,t)<0}function fn(o,t){let e=o,s=!1;const i=(o.x+t.x)/2,n=(o.y+t.y)/2;do e.y>n!=e.next.y>n&&e.next.y!==e.y&&i<(e.next.x-e.x)*(n-e.y)/(e.next.y-e.y)+e.x&&(s=!s),e=e.next;while(e!==o);return s}function Ys(o,t){const e=as(o.i,o.x,o.y),s=as(t.i,t.x,t.y),i=o.next,n=t.prev;return o.next=t,t.prev=o,e.next=i,i.prev=e,s.next=e,e.prev=s,n.next=s,s.prev=n,s}function Ds(o,t,e,s){const i=as(o,t,e);return s?(i.next=s.next,i.prev=s,s.next.prev=i,s.next=i):(i.prev=i,i.next=i),i}function we(o){o.next.prev=o.prev,o.prev.next=o.next,o.prevZ&&(o.prevZ.nextZ=o.nextZ),o.nextZ&&(o.nextZ.prevZ=o.prevZ),o.next=o,o.prev=o}function as(o,t,e){return{i:o,x:t,y:e,prev:null,next:null,z:null,prevZ:null,nextZ:null,steiner:!1}}function dn(o,t,e,s,i,n){let r=0;for(let a=t,l=e-s;a<e;a+=s)r+=(o[l+i]-o[a+i])*(o[a+n]+o[l+n]),l=a;return r}const pe=class pe{static create(t,e,s,i,n,r,a,l){const u=t.length,d=a.verticesAmount;pe.processBuffers(u,t,n,a,e,s);const f=n.positionBuffer,g=(a.verticesAmount-d)/3;this.processNormals(f,this._tempVec,g,d),this.triangulate(r,i,u,n,a,d),this.setFaceId(d,a,n,l)}static setFaceId(t,e,s,i){const n=t/3,r=e.verticesAmount/3;for(let a=n;a<r;a++)s.faceIdBuffer[a]=i}static getVertices(t,e,s){const n=t.positionBuffer.buffer,r=e*4,a=s.verticesAmount-e;return new Float32Array(n,r,a)}static getEvent(t,e,s){return(i,n,r)=>{const a=t.indexBuffer;a[e.indices++]=i+s/3,a[e.indices++]=n+s/3,a[e.indices++]=r+s/3}}static processBuffers(t,e,s,i,n,r){for(let a=0;a<t;a++)this.processPositionBuffer(s,e,a,i,n),this.processNormalbuffer(s,r,a,i),this.updateBufferData(i)}static getHoles(t,e,s,i,n){if(!t)return;if(t.has(e)){const a=t.get(e),l=[];for(const u of a.indices)l.push(u+s);return this.setHolesBuffers(i,a,n),l}}static setHolesBuffers(t,e,s){const i=t.positionBuffer,n=t.normalBuffer;i.set(e.points,s.verticesAmount);const r=e.points.length;s.verticesAmount+=r,s.vertices+=r/3,n.set(e.normals,s.normalsAmount),s.normalsAmount+=r}static updateBufferData(t){t.vertices+=1,t.verticesAmount+=3,t.normalsAmount+=3}static processPositionBuffer(t,e,s,i,n){const r=t.positionBuffer;for(let a=0;a<3;a++){const l=e[s]*3;r[i.verticesAmount+a]=n[l+a]}}static triangulate(t,e,s,i,n,r){const l=this.getHoles(t,e,s,i,n),u=pe.getVertices(i,r,n),d=bi.getEarcutDimensions(this._tempVec),f=this.getEvent(i,n,r),b=d[0],g=d[1];Qi(u,l,3,b,g,f)}static processNormals(t,e,s,i=0){e.set(0,0,0);for(let n=0;n<s;n++){const r=(n+1)%s,a=i+n*3,l=i+r*3,u=t[a+0],d=t[l+0],f=t[a+1],b=t[l+1],g=t[a+2],_=t[l+2];e.x+=(f-b)*(g+_),e.y+=(g-_)*(u+d),e.z+=(u-d)*(f+b)}e.normalize()}static processNormalbuffer(t,e,s,i){const n=t.normalBuffer,r=s*3,a=e[r],l=e[r+1],u=e[r+2];n.set([a,l,u],i.normalsAmount)}};c(pe,"_tempVec",new p);let cs=pe;const L=class L{static create(t,e,s,i,n,r,a){if(this.setAllVectors(t,e),this.getIsConvex()){this.processConvexFace4(n,r,s,a);return}cs.create(t,e,s,i,n,void 0,r,a)}static setAllVectors(t,e){this.setVector(t,e,this.a,0),this.setVector(t,e,this.b,1),this.setVector(t,e,this.c,2),this.setVector(t,e,this.d,3),this.getCrossVectors()}static processConvexFace4(t,e,s,i){this.processIndices(t,e),this.processPoints(t,e),this.processNormal(t,e,s),this.setFaceId(t,e,i),this.updateData(e)}static setFaceId(t,e,s){const i=t.faceIdBuffer;for(let n=e.vertices;n<e.vertices+4;n++)i[n]=s}static getIsConvex(){return this.h.dot(this.i)>0}static getCrossVectors(){this.e.copy(this.b),this.f.copy(this.c),this.g.copy(this.d),this.e.sub(this.a),this.f.sub(this.a),this.g.sub(this.a),this.h.crossVectors(this.e,this.f),this.i.crossVectors(this.f,this.g)}static updateData(t){t.normalsAmount+=this.totalIncrease,t.vertices+=this.vertexIncrease,t.verticesAmount+=this.totalIncrease}static processPoints(t,e){let s=0;const i=t.positionBuffer,n=e.verticesAmount;for(let r=0;r<this.vertexIncrease;r++){const a=this._vecs[r];i[n+s++]=a.x,i[n+s++]=a.y,i[n+s++]=a.z}}static setVector(t,e,s,i){const n=t[i]*3,r=e[n],a=e[n+1],l=e[n+2];s.set(r,a,l)}static processNormal(t,e,s){const i=t.normalBuffer,n=e.normalsAmount;for(let r=0;r<this.totalIncrease;r++)i[n+r]=s[r]}static processIndices(t,e){const s=t.indexBuffer;for(let i=0;i<this.indexIncrease;i++){const n=this._convexIndices[i];s[e.indices+i]=e.vertices+n}e.indices+=this.indexIncrease}};c(L,"a",new p),c(L,"b",new p),c(L,"c",new p),c(L,"d",new p),c(L,"e",new p),c(L,"f",new p),c(L,"g",new p),c(L,"h",new p),c(L,"i",new p),c(L,"_vecs",[L.a,L.b,L.c,L.d]),c(L,"_convexIndices",[0,1,3,3,1,2]),c(L,"totalIncrease",12),c(L,"indexIncrease",6),c(L,"vertexIncrease",4);let Bs=L;class C{static circleCurve3Divisions(t){const n=t.aperture(),r=t.radius(),a=n*r*4,l=Math.round(a);return Math.min(Math.max(l,4),32)}static traverseCircleCurve(t,e,s){const i=t.circleCurvesLength(),n=2;for(let r=0;r<i;r++){this.getAllCircleCurveData(t,r);const a=s(this._circleCurve);this._circlePoints.length=a-n,this.getCircleCurveMids(a),this.getNewCircleCurveData(),e(this._circleP1,this._circlePoints,this._circleP2)}}static traverseWireSets(t,e){const s=t.wireSetsLength();for(let i=0;i<s;i++)t.wireSets(i,this._wireSet),this.traverseWireSetWires(e)}static raycastCircleExtr(t,e,s,i){const n=e.distanceTo(t);return this.setupCircleExtrusionAxes(e,t),this.setupCircleExtrusionTransform(t,i),this.setupCircleExtrusionRay(s),this.computeCircleExtrusionRaycast(n,i)}static traverseWires(t,e){const s=t.wiresLength();for(let i=0;i<s;i++)t.wires(i,this._wire),this.setWire(),e(this._wireP1,this._wireP2)}static getNewCircleCurveData(){this._circleP2.copy(this._circleP1);const t=this._circleCurve.aperture(),e=this._circleCurve.radius();this._circleP2.applyAxisAngle(this._circleOrientation,t),this._circleP2.multiplyScalar(e),this._circleP2.add(this._circleOrigin),this._circleP1.multiplyScalar(e),this._circleP1.add(this._circleOrigin)}static setWire(){this.setWirePoint("p1",this._wireP1),this.setWirePoint("p2",this._wireP2)}static getCircleCurveMids(t){const e=this._circlePoints.length;for(let s=0;s<e;s++)this._circlePoints[s]=this.newCirclePoint(s,t)}static newCirclePoint(t,e){const s=e-1,i=t+1,n=new p;n.copy(this._circleP1);const r=this._circleCurve.radius(),u=this._circleCurve.aperture()*i/s;return n.applyAxisAngle(this._circleOrientation,u),n.multiplyScalar(r),n.add(this._circleOrigin),n}static getAllCircleCurveData(t,e){t.circleCurves(e,this._circleCurve),this.getCircleCurveData(this._circleOrigin,"position"),this.getCircleCurveData(this._circleOrientation,"xDirection"),this.getCircleCurveData(this._circleP1,"yDirection")}static setWirePoint(t,e){this._wire[t](this._floats);const s=this._floats.x(),i=this._floats.y(),n=this._floats.z();e.set(s,i,n)}static getCircleCurveData(t,e){const s=this._circleCurve[e]();this.getVectorData(s,t)}static getVectorData(t,e){const s=t.x(),i=t.y(),n=t.z();e.set(s,i,n)}static traverseWireSetWires(t){const s=this._wireSet.psLength()-1;for(let i=0;i<s;i++)this.getWiresetPoint(this._currentWireSetPoint,i),this.getWiresetPoint(this._nextWireSetPoint,i+1),t(this._currentWireSetPoint,this._nextWireSetPoint)}static getWiresetPoint(t,e){const s=this._wireSet.ps(e);this.getVectorData(s,t)}static setupCircleExtrusionTransform(t,e){this._ceTransform.identity(),this._ceTransform.makeBasis(this._ceAxisX,this._ceAxisY,this._ceAxisZ),this._ceTransform.setPosition(t),this._ceSize.set(e,e,e),this._ceTransform.scale(this._ceSize)}static computeCircleExtrusionRaycastFactors(){const s=this._ceRay.direction,i=this._ceRay.origin,n=s.x*s.x+s.y*s.y,r=2*i.x*s.x+2*i.y*s.y,a=i.x*i.x+i.y*i.y-1,l=4*n*a,u=r*r;if(l>u)return null;const f=2*n,b=Math.sqrt(u-l),g=(-r+b)/f,_=(-r-b)/f;return{factorA:g,factorB:_}}static computeCircleExtrusionRaycast(t,e){const s=this.computeCircleExtrusionRaycastFactors();if(s===null)return[];const{factorA:i,factorB:n}=s;return this._ceInverseTransform.transpose(),this._ceRaycastPoints=[],this.computeCircleExtrusionRaycastPoints(i,t,e),this.computeCircleExtrusionRaycastPoints(n,t,e),this._ceRaycastPoints}static setupCircleExtrusionRay(t){this._ceInverseTransform.copy(this._ceTransform),this._ceInverseTransform.invert(),this._ceRay.copy(t),this._ceRay.applyMatrix4(this._ceInverseTransform)}static computeCircleExtrusionRaycastPoints(t,e,s){if(!this.checkIfCircleExtrusionClashes(t,e,s))return;this._ceRaycastPoint.applyMatrix4(this._ceTransform);const n=this._ceRaycastPoint.clone();this._ceRaycastPoints.push({point:n})}static setupCircleExtrusionAxes(t,e){this._ceAxisZ.copy(t),this._ceAxisZ.sub(e),this._ceAxisZ.normalize(),this.computeNormal(this._ceAxisZ,this._ceAxisX),this._ceAxisY.crossVectors(this._ceAxisZ,this._ceAxisX)}static computeNormal(t,e){const i=t.dot(this._ceAbsoluteX),a=Math.abs(i)>.9?this._ceAbsoluteZ:this._ceAbsoluteX;e.crossVectors(t,a),e.normalize()}static setupCircleExtrusionRaycastPoint(t){this._ceRaycastPoint.copy(this._ceRay.direction),this._ceRaycastPoint.normalize(),this._ceRaycastPoint.multiplyScalar(t),this._ceRaycastPoint.add(this._ceRay.origin)}static checkIfCircleExtrusionClashes(t,e,s){this.setupCircleExtrusionRaycastPoint(t);const i=e/s,n=this._ceRaycastPoint.z;return n>=0&&n<=i}}c(C,"_floats",new Y),c(C,"_wire",new js),c(C,"_wireSet",new Pt),c(C,"_circleCurve",new ys),c(C,"_wireP1",new p),c(C,"_wireP2",new p),c(C,"_circleP1",new p),c(C,"_circleP2",new p),c(C,"_circleOrigin",new p),c(C,"_circleOrientation",new p),c(C,"_currentWireSetPoint",new p),c(C,"_nextWireSetPoint",new p),c(C,"_ceAxisZ",new p),c(C,"_ceAxisY",new p),c(C,"_ceAxisX",new p),c(C,"_ceRaycastPoint",new p),c(C,"_ceSize",new p),c(C,"_ceAbsoluteX",new p(0,0,1)),c(C,"_ceAbsoluteZ",new p(1,0,0)),c(C,"_circlePoints",[]),c(C,"_ceTransform",new pt),c(C,"_ceInverseTransform",new pt),c(C,"_ceRay",new bs),c(C,"_ceRaycastPoints",[]);const P=class P{static newPaths(t,e){const s=P.newPathData();return this.fetchCircleCurveData(t,s),this.fetchCircleCurveMids(e,s,t),this.fetchCircleCurveEnds(s,t),this.fetchCircleCurveCuts(s),s.cuts}static getAxisPartSize(t,e,s){const i=t.parts(e),n=t.order(e),r=P.getAxisPartData(i,s,t,n);return P.fetchAxisPartSize(s,r),this._axisPartSize}static vertexLength(t,e=200){const s=Math.round(t*e),i=Math.max(s,P._minSize);return Math.min(i,P._maxSize)}static setPathVertices(t){const e=this.circleCurvePoints,s=!e,i=e&&e.length!==t;if(s||i){this.circleCurvePoints=[];for(let n=0;n<t;n++){const l=2*Math.PI*n/t,u=Math.sin(l),d=Math.cos(l),f=new p(u,d,0);this.circleCurvePoints.push(f)}}}static fetchCircleCurveEnds(t,e){t.last.copy(t.first),t.last.applyAxisAngle(t.axis,e.aperture()),t.last.multiplyScalar(e.radius()),t.last.add(t.center),t.first.multiplyScalar(e.radius()),t.first.add(t.center)}static getAxisPartData(t,e,s,i){return{[Te.WIRE]:this.getAxisPartWireData,[Te.WIRE_SET]:this.getAxisPartWireSetData,[Te.CIRCLE_CURVE]:this.getAxisPartCircleCurveData}[t](s,i,e)}static newEmptyAxisPartData(){return{indices:0,points:0,faces:0,links:0}}static fetchCircleCurveMids(t,e,s){const i=t-2;for(let n=0;n<i;n++){const r=new p;r.copy(e.first);const a=s.aperture(),l=t-1,d=a*(n+1)/l;r.applyAxisAngle(e.axis,d),r.multiplyScalar(s.radius()),r.add(e.center),e.mids[n]=r}}static validSize(t,e,s){const i=t+e+s;return gi>=i}static fetchCircleCurveCuts(t){t.cuts.push(t.first),t.cuts.push(...t.mids),t.cuts.push(t.last)}static fetchCircleCurveData(t,e){const s=t.position();e.center.set(s.x(),s.y(),s.z());const i=t.xDirection();e.axis.set(i.x(),i.y(),i.z());const n=t.yDirection();e.first.set(n.x(),n.y(),n.z())}static newPathData(){return{axis:new p,cuts:[],center:new p,last:new p,first:new p,mids:[]}}static fetchAxisPartSize(t,e){const s=t-2,n=e.faces*s*3,r=e.links*t*this._wireSize;this._axisPartSize.verticesLength=e.points,this._axisPartSize.indicesLength=e.indices+n+r}};c(P,"up",new p(0,0,1)),c(P,"circleCurves",[]),c(P,"circleCurvePoints"),c(P,"temp",{circleExtrusion:new Lt,circleCurve:new ys,wireSet:new Pt,axis:new nt,rotation:new fi,vector:new p}),c(P,"_wireSize",6),c(P,"_minSize",6),c(P,"_maxSize",30),c(P,"_axisPartSize",{verticesLength:0,indicesLength:0}),c(P,"getAxisPartWireSetData",(t,e,s)=>{const n=P.newEmptyAxisPartData();t.wireSets(e,P.temp.wireSet);const r=P.temp.wireSet.psLength()-1;return n.points=r*2*s,n.indices=P._wireSize*r*s,n.faces=r*2,n}),c(P,"getAxisPartWireData",(t,e,s)=>{const i=P.newEmptyAxisPartData();return i.points=2*s,i.indices=P._wireSize*s,i.faces=2,i}),c(P,"getAxisPartCircleCurveData",(t,e,s)=>{const i=P.newEmptyAxisPartData();t.circleCurves(e,P.temp.circleCurve);const n=C.circleCurve3Divisions(P.temp.circleCurve),r=s*n;i.points=r;const a=s*(n-1),l=P._wireSize*a;i.indices=l;const u=2;return i.faces=u,i.links=u,i});let Ls=P;const Kt=typeof performance=="object"&&performance&&typeof performance.now=="function"?performance:Date,Qs=new Set,hs=typeof process=="object"&&process?process:{},$s=(o,t,e,s)=>{typeof hs.emitWarning=="function"?hs.emitWarning(o,t,e,s):console.error(`[${e}] ${t}: ${o}`)};let Ge=globalThis.AbortController,Rs=globalThis.AbortSignal;var Os;if(typeof Ge>"u"){Rs=class{constructor(){c(this,"onabort");c(this,"_onabort",[]);c(this,"reason");c(this,"aborted",!1)}addEventListener(s,i){this._onabort.push(i)}},Ge=class{constructor(){c(this,"signal",new Rs);t()}abort(s){var i,n;if(!this.signal.aborted){this.signal.reason=s,this.signal.aborted=!0;for(const r of this.signal._onabort)r(s);(n=(i=this.signal).onabort)==null||n.call(i,s)}}};let o=((Os=hs.env)==null?void 0:Os.LRU_CACHE_IGNORE_AC_WARNING)!=="1";const t=()=>{o&&(o=!1,$s("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",t))}}const pn=o=>!Qs.has(o),Ct=o=>o&&o===Math.floor(o)&&o>0&&isFinite(o),Ks=o=>Ct(o)?o<=Math.pow(2,8)?Uint8Array:o<=Math.pow(2,16)?Uint16Array:o<=Math.pow(2,32)?Uint32Array:o<=Number.MAX_SAFE_INTEGER?Oe:null:null;class Oe extends Array{constructor(t){super(t),this.fill(0)}}var ie;const Gt=class Gt{constructor(t,e){c(this,"heap");c(this,"length");if(!h(Gt,ie))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t),this.length=0}static create(t){const e=Ks(t);if(!e)return[];w(Gt,ie,!0);const s=new Gt(t,e);return w(Gt,ie,!1),s}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}};ie=new WeakMap,y(Gt,ie,!1);let ls=Gt;var rt,K,ot,kt,at,ne,re,O,ct,R,D,v,q,J,G,V,ht,W,lt,ut,tt,ft,Vt,Z,oe,ye,fs,qt,At,ve,et,qe,Js,Zt,ae,xe,wt,zt,yt,Ft,Ie,ds,gn,ce,Ve,he,We,M,z,Se,ps,Xt,ue,vt,Dt,Ae,gs;const xs=class xs{constructor(t){y(this,ye);y(this,qe);y(this,wt);y(this,yt);y(this,Ie);y(this,ce);y(this,he);y(this,M);y(this,Se);y(this,Xt);y(this,vt);y(this,Ae);y(this,rt,void 0);y(this,K,void 0);y(this,ot,void 0);y(this,kt,void 0);y(this,at,void 0);y(this,ne,void 0);y(this,re,void 0);c(this,"ttl");c(this,"ttlResolution");c(this,"ttlAutopurge");c(this,"updateAgeOnGet");c(this,"updateAgeOnHas");c(this,"allowStale");c(this,"noDisposeOnSet");c(this,"noUpdateTTL");c(this,"maxEntrySize");c(this,"sizeCalculation");c(this,"noDeleteOnFetchRejection");c(this,"noDeleteOnStaleGet");c(this,"allowStaleOnFetchAbort");c(this,"allowStaleOnFetchRejection");c(this,"ignoreFetchAbort");y(this,O,void 0);y(this,ct,void 0);y(this,R,void 0);y(this,D,void 0);y(this,v,void 0);y(this,q,void 0);y(this,J,void 0);y(this,G,void 0);y(this,V,void 0);y(this,ht,void 0);y(this,W,void 0);y(this,lt,void 0);y(this,ut,void 0);y(this,tt,void 0);y(this,ft,void 0);y(this,Vt,void 0);y(this,Z,void 0);y(this,oe,void 0);y(this,qt,()=>{});y(this,At,()=>{});y(this,ve,()=>{});y(this,et,()=>!1);y(this,Zt,t=>{});y(this,ae,(t,e,s)=>{});y(this,xe,(t,e,s,i)=>{if(s||i)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0});c(this,gn,"LRUCache");const{max:e=0,ttl:s,ttlResolution:i=1,ttlAutopurge:n,updateAgeOnGet:r,updateAgeOnHas:a,allowStale:l,dispose:u,onInsert:d,disposeAfter:f,noDisposeOnSet:b,noUpdateTTL:g,maxSize:_=0,maxEntrySize:I=0,sizeCalculation:E,fetchMethod:S,memoMethod:T,noDeleteOnFetchRejection:x,noDeleteOnStaleGet:A,allowStaleOnFetchRejection:it,allowStaleOnFetchAbort:le,ignoreFetchAbort:Qt}=t;if(e!==0&&!Ct(e))throw new TypeError("max option must be a nonnegative integer");const Me=e?Ks(e):Array;if(!Me)throw new Error("invalid max value: "+e);if(w(this,rt,e),w(this,K,_),this.maxEntrySize=I||h(this,K),this.sizeCalculation=E,this.sizeCalculation){if(!h(this,K)&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!="function")throw new TypeError("sizeCalculation set to non-function")}if(T!==void 0&&typeof T!="function")throw new TypeError("memoMethod must be a function if defined");if(w(this,re,T),S!==void 0&&typeof S!="function")throw new TypeError("fetchMethod must be a function if specified");if(w(this,ne,S),w(this,Vt,!!S),w(this,R,new Map),w(this,D,new Array(e).fill(void 0)),w(this,v,new Array(e).fill(void 0)),w(this,q,new Me(e)),w(this,J,new Me(e)),w(this,G,0),w(this,V,0),w(this,ht,ls.create(e)),w(this,O,0),w(this,ct,0),typeof u=="function"&&w(this,ot,u),typeof d=="function"&&w(this,kt,d),typeof f=="function"?(w(this,at,f),w(this,W,[])):(w(this,at,void 0),w(this,W,void 0)),w(this,ft,!!h(this,ot)),w(this,oe,!!h(this,kt)),w(this,Z,!!h(this,at)),this.noDisposeOnSet=!!b,this.noUpdateTTL=!!g,this.noDeleteOnFetchRejection=!!x,this.allowStaleOnFetchRejection=!!it,this.allowStaleOnFetchAbort=!!le,this.ignoreFetchAbort=!!Qt,this.maxEntrySize!==0){if(h(this,K)!==0&&!Ct(h(this,K)))throw new TypeError("maxSize must be a positive integer if specified");if(!Ct(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");m(this,qe,Js).call(this)}if(this.allowStale=!!l,this.noDeleteOnStaleGet=!!A,this.updateAgeOnGet=!!r,this.updateAgeOnHas=!!a,this.ttlResolution=Ct(i)||i===0?i:1,this.ttlAutopurge=!!n,this.ttl=s||0,this.ttl){if(!Ct(this.ttl))throw new TypeError("ttl must be a positive integer if specified");m(this,ye,fs).call(this)}if(h(this,rt)===0&&this.ttl===0&&h(this,K)===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!h(this,rt)&&!h(this,K)){const $t="LRU_CACHE_UNBOUNDED";pn($t)&&(Qs.add($t),$s("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",$t,xs))}}static unsafeExposeInternals(t){return{starts:h(t,ut),ttls:h(t,tt),sizes:h(t,lt),keyMap:h(t,R),keyList:h(t,D),valList:h(t,v),next:h(t,q),prev:h(t,J),get head(){return h(t,G)},get tail(){return h(t,V)},free:h(t,ht),isBackgroundFetch:e=>{var s;return m(s=t,M,z).call(s,e)},backgroundFetch:(e,s,i,n)=>{var r;return m(r=t,he,We).call(r,e,s,i,n)},moveToTail:e=>{var s;return m(s=t,Xt,ue).call(s,e)},indexes:e=>{var s;return m(s=t,wt,zt).call(s,e)},rindexes:e=>{var s;return m(s=t,yt,Ft).call(s,e)},isStale:e=>{var s;return h(s=t,et).call(s,e)}}}get max(){return h(this,rt)}get maxSize(){return h(this,K)}get calculatedSize(){return h(this,ct)}get size(){return h(this,O)}get fetchMethod(){return h(this,ne)}get memoMethod(){return h(this,re)}get dispose(){return h(this,ot)}get onInsert(){return h(this,kt)}get disposeAfter(){return h(this,at)}getRemainingTTL(t){return h(this,R).has(t)?1/0:0}*entries(){for(const t of m(this,wt,zt).call(this))h(this,v)[t]!==void 0&&h(this,D)[t]!==void 0&&!m(this,M,z).call(this,h(this,v)[t])&&(yield[h(this,D)[t],h(this,v)[t]])}*rentries(){for(const t of m(this,yt,Ft).call(this))h(this,v)[t]!==void 0&&h(this,D)[t]!==void 0&&!m(this,M,z).call(this,h(this,v)[t])&&(yield[h(this,D)[t],h(this,v)[t]])}*keys(){for(const t of m(this,wt,zt).call(this)){const e=h(this,D)[t];e!==void 0&&!m(this,M,z).call(this,h(this,v)[t])&&(yield e)}}*rkeys(){for(const t of m(this,yt,Ft).call(this)){const e=h(this,D)[t];e!==void 0&&!m(this,M,z).call(this,h(this,v)[t])&&(yield e)}}*values(){for(const t of m(this,wt,zt).call(this))h(this,v)[t]!==void 0&&!m(this,M,z).call(this,h(this,v)[t])&&(yield h(this,v)[t])}*rvalues(){for(const t of m(this,yt,Ft).call(this))h(this,v)[t]!==void 0&&!m(this,M,z).call(this,h(this,v)[t])&&(yield h(this,v)[t])}[Symbol.iterator](){return this.entries()}find(t,e={}){for(const s of m(this,wt,zt).call(this)){const i=h(this,v)[s],n=m(this,M,z).call(this,i)?i.__staleWhileFetching:i;if(n!==void 0&&t(n,h(this,D)[s],this))return this.get(h(this,D)[s],e)}}forEach(t,e=this){for(const s of m(this,wt,zt).call(this)){const i=h(this,v)[s],n=m(this,M,z).call(this,i)?i.__staleWhileFetching:i;n!==void 0&&t.call(e,n,h(this,D)[s],this)}}rforEach(t,e=this){for(const s of m(this,yt,Ft).call(this)){const i=h(this,v)[s],n=m(this,M,z).call(this,i)?i.__staleWhileFetching:i;n!==void 0&&t.call(e,n,h(this,D)[s],this)}}purgeStale(){let t=!1;for(const e of m(this,yt,Ft).call(this,{allowStale:!0}))h(this,et).call(this,e)&&(m(this,vt,Dt).call(this,h(this,D)[e],"expire"),t=!0);return t}info(t){const e=h(this,R).get(t);if(e===void 0)return;const s=h(this,v)[e],i=m(this,M,z).call(this,s)?s.__staleWhileFetching:s;if(i===void 0)return;const n={value:i};if(h(this,tt)&&h(this,ut)){const r=h(this,tt)[e],a=h(this,ut)[e];if(r&&a){const l=r-(Kt.now()-a);n.ttl=l,n.start=Date.now()}}return h(this,lt)&&(n.size=h(this,lt)[e]),n}dump(){const t=[];for(const e of m(this,wt,zt).call(this,{allowStale:!0})){const s=h(this,D)[e],i=h(this,v)[e],n=m(this,M,z).call(this,i)?i.__staleWhileFetching:i;if(n===void 0||s===void 0)continue;const r={value:n};if(h(this,tt)&&h(this,ut)){r.ttl=h(this,tt)[e];const a=Kt.now()-h(this,ut)[e];r.start=Math.floor(Date.now()-a)}h(this,lt)&&(r.size=h(this,lt)[e]),t.unshift([s,r])}return t}load(t){this.clear();for(const[e,s]of t){if(s.start){const i=Date.now()-s.start;s.start=Kt.now()-i}this.set(e,s.value,s)}}set(t,e,s={}){var b,g,_,I,E,S,T;if(e===void 0)return this.delete(t),this;const{ttl:i=this.ttl,start:n,noDisposeOnSet:r=this.noDisposeOnSet,sizeCalculation:a=this.sizeCalculation,status:l}=s;let{noUpdateTTL:u=this.noUpdateTTL}=s;const d=h(this,xe).call(this,t,e,s.size||0,a);if(this.maxEntrySize&&d>this.maxEntrySize)return l&&(l.set="miss",l.maxEntrySizeExceeded=!0),m(this,vt,Dt).call(this,t,"set"),this;let f=h(this,O)===0?void 0:h(this,R).get(t);if(f===void 0)f=h(this,O)===0?h(this,V):h(this,ht).length!==0?h(this,ht).pop():h(this,O)===h(this,rt)?m(this,ce,Ve).call(this,!1):h(this,O),h(this,D)[f]=t,h(this,v)[f]=e,h(this,R).set(t,f),h(this,q)[h(this,V)]=f,h(this,J)[f]=h(this,V),w(this,V,f),Ee(this,O)._++,h(this,ae).call(this,f,d,l),l&&(l.set="add"),u=!1,h(this,oe)&&((b=h(this,kt))==null||b.call(this,e,t,"add"));else{m(this,Xt,ue).call(this,f);const x=h(this,v)[f];if(e!==x){if(h(this,Vt)&&m(this,M,z).call(this,x)){x.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:A}=x;A!==void 0&&!r&&(h(this,ft)&&((g=h(this,ot))==null||g.call(this,A,t,"set")),h(this,Z)&&((_=h(this,W))==null||_.push([A,t,"set"])))}else r||(h(this,ft)&&((I=h(this,ot))==null||I.call(this,x,t,"set")),h(this,Z)&&((E=h(this,W))==null||E.push([x,t,"set"])));if(h(this,Zt).call(this,f),h(this,ae).call(this,f,d,l),h(this,v)[f]=e,l){l.set="replace";const A=x&&m(this,M,z).call(this,x)?x.__staleWhileFetching:x;A!==void 0&&(l.oldValue=A)}}else l&&(l.set="update");h(this,oe)&&((S=this.onInsert)==null||S.call(this,e,t,e===x?"update":"replace"))}if(i!==0&&!h(this,tt)&&m(this,ye,fs).call(this),h(this,tt)&&(u||h(this,ve).call(this,f,i,n),l&&h(this,At).call(this,l,f)),!r&&h(this,Z)&&h(this,W)){const x=h(this,W);let A;for(;A=x==null?void 0:x.shift();)(T=h(this,at))==null||T.call(this,...A)}return this}pop(){var t;try{for(;h(this,O);){const e=h(this,v)[h(this,G)];if(m(this,ce,Ve).call(this,!0),m(this,M,z).call(this,e)){if(e.__staleWhileFetching)return e.__staleWhileFetching}else if(e!==void 0)return e}}finally{if(h(this,Z)&&h(this,W)){const e=h(this,W);let s;for(;s=e==null?void 0:e.shift();)(t=h(this,at))==null||t.call(this,...s)}}}has(t,e={}){const{updateAgeOnHas:s=this.updateAgeOnHas,status:i}=e,n=h(this,R).get(t);if(n!==void 0){const r=h(this,v)[n];if(m(this,M,z).call(this,r)&&r.__staleWhileFetching===void 0)return!1;if(h(this,et).call(this,n))i&&(i.has="stale",h(this,At).call(this,i,n));else return s&&h(this,qt).call(this,n),i&&(i.has="hit",h(this,At).call(this,i,n)),!0}else i&&(i.has="miss");return!1}peek(t,e={}){const{allowStale:s=this.allowStale}=e,i=h(this,R).get(t);if(i===void 0||!s&&h(this,et).call(this,i))return;const n=h(this,v)[i];return m(this,M,z).call(this,n)?n.__staleWhileFetching:n}async fetch(t,e={}){const{allowStale:s=this.allowStale,updateAgeOnGet:i=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,ttl:r=this.ttl,noDisposeOnSet:a=this.noDisposeOnSet,size:l=0,sizeCalculation:u=this.sizeCalculation,noUpdateTTL:d=this.noUpdateTTL,noDeleteOnFetchRejection:f=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:b=this.allowStaleOnFetchRejection,ignoreFetchAbort:g=this.ignoreFetchAbort,allowStaleOnFetchAbort:_=this.allowStaleOnFetchAbort,context:I,forceRefresh:E=!1,status:S,signal:T}=e;if(!h(this,Vt))return S&&(S.fetch="get"),this.get(t,{allowStale:s,updateAgeOnGet:i,noDeleteOnStaleGet:n,status:S});const x={allowStale:s,updateAgeOnGet:i,noDeleteOnStaleGet:n,ttl:r,noDisposeOnSet:a,size:l,sizeCalculation:u,noUpdateTTL:d,noDeleteOnFetchRejection:f,allowStaleOnFetchRejection:b,allowStaleOnFetchAbort:_,ignoreFetchAbort:g,status:S,signal:T};let A=h(this,R).get(t);if(A===void 0){S&&(S.fetch="miss");const it=m(this,he,We).call(this,t,A,x,I);return it.__returned=it}else{const it=h(this,v)[A];if(m(this,M,z).call(this,it)){const Qe=s&&it.__staleWhileFetching!==void 0;return S&&(S.fetch="inflight",Qe&&(S.returnedStale=!0)),Qe?it.__staleWhileFetching:it.__returned=it}const le=h(this,et).call(this,A);if(!E&&!le)return S&&(S.fetch="hit"),m(this,Xt,ue).call(this,A),i&&h(this,qt).call(this,A),S&&h(this,At).call(this,S,A),it;const Qt=m(this,he,We).call(this,t,A,x,I),$t=Qt.__staleWhileFetching!==void 0&&s;return S&&(S.fetch=le?"stale":"refresh",$t&&le&&(S.returnedStale=!0)),$t?Qt.__staleWhileFetching:Qt.__returned=Qt}}async forceFetch(t,e={}){const s=await this.fetch(t,e);if(s===void 0)throw new Error("fetch() returned undefined");return s}memo(t,e={}){const s=h(this,re);if(!s)throw new Error("no memoMethod provided to constructor");const{context:i,forceRefresh:n,...r}=e,a=this.get(t,r);if(!n&&a!==void 0)return a;const l=s(t,a,{options:r,context:i});return this.set(t,l,r),l}get(t,e={}){const{allowStale:s=this.allowStale,updateAgeOnGet:i=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,status:r}=e,a=h(this,R).get(t);if(a!==void 0){const l=h(this,v)[a],u=m(this,M,z).call(this,l);return r&&h(this,At).call(this,r,a),h(this,et).call(this,a)?(r&&(r.get="stale"),u?(r&&s&&l.__staleWhileFetching!==void 0&&(r.returnedStale=!0),s?l.__staleWhileFetching:void 0):(n||m(this,vt,Dt).call(this,t,"expire"),r&&s&&(r.returnedStale=!0),s?l:void 0)):(r&&(r.get="hit"),u?l.__staleWhileFetching:(m(this,Xt,ue).call(this,a),i&&h(this,qt).call(this,a),l))}else r&&(r.get="miss")}delete(t){return m(this,vt,Dt).call(this,t,"delete")}clear(){return m(this,Ae,gs).call(this,"delete")}};gn=Symbol.toStringTag,rt=new WeakMap,K=new WeakMap,ot=new WeakMap,kt=new WeakMap,at=new WeakMap,ne=new WeakMap,re=new WeakMap,O=new WeakMap,ct=new WeakMap,R=new WeakMap,D=new WeakMap,v=new WeakMap,q=new WeakMap,J=new WeakMap,G=new WeakMap,V=new WeakMap,ht=new WeakMap,W=new WeakMap,lt=new WeakMap,ut=new WeakMap,tt=new WeakMap,ft=new WeakMap,Vt=new WeakMap,Z=new WeakMap,oe=new WeakMap,ye=new WeakSet,fs=function(){const t=new Oe(h(this,rt)),e=new Oe(h(this,rt));w(this,tt,t),w(this,ut,e),w(this,ve,(n,r,a=Kt.now())=>{if(e[n]=r!==0?a:0,t[n]=r,r!==0&&this.ttlAutopurge){const l=setTimeout(()=>{h(this,et).call(this,n)&&m(this,vt,Dt).call(this,h(this,D)[n],"expire")},r+1);l.unref&&l.unref()}}),w(this,qt,n=>{e[n]=t[n]!==0?Kt.now():0}),w(this,At,(n,r)=>{if(t[r]){const a=t[r],l=e[r];if(!a||!l)return;n.ttl=a,n.start=l,n.now=s||i();const u=n.now-l;n.remainingTTL=a-u}});let s=0;const i=()=>{const n=Kt.now();if(this.ttlResolution>0){s=n;const r=setTimeout(()=>s=0,this.ttlResolution);r.unref&&r.unref()}return n};this.getRemainingTTL=n=>{const r=h(this,R).get(n);if(r===void 0)return 0;const a=t[r],l=e[r];if(!a||!l)return 1/0;const u=(s||i())-l;return a-u},w(this,et,n=>{const r=e[n],a=t[n];return!!a&&!!r&&(s||i())-r>a})},qt=new WeakMap,At=new WeakMap,ve=new WeakMap,et=new WeakMap,qe=new WeakSet,Js=function(){const t=new Oe(h(this,rt));w(this,ct,0),w(this,lt,t),w(this,Zt,e=>{w(this,ct,h(this,ct)-t[e]),t[e]=0}),w(this,xe,(e,s,i,n)=>{if(m(this,M,z).call(this,s))return 0;if(!Ct(i))if(n){if(typeof n!="function")throw new TypeError("sizeCalculation must be a function");if(i=n(s,e),!Ct(i))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return i}),w(this,ae,(e,s,i)=>{if(t[e]=s,h(this,K)){const n=h(this,K)-t[e];for(;h(this,ct)>n;)m(this,ce,Ve).call(this,!0)}w(this,ct,h(this,ct)+t[e]),i&&(i.entrySize=s,i.totalCalculatedSize=h(this,ct))})},Zt=new WeakMap,ae=new WeakMap,xe=new WeakMap,wt=new WeakSet,zt=function*({allowStale:t=this.allowStale}={}){if(h(this,O))for(let e=h(this,V);!(!m(this,Ie,ds).call(this,e)||((t||!h(this,et).call(this,e))&&(yield e),e===h(this,G)));)e=h(this,J)[e]},yt=new WeakSet,Ft=function*({allowStale:t=this.allowStale}={}){if(h(this,O))for(let e=h(this,G);!(!m(this,Ie,ds).call(this,e)||((t||!h(this,et).call(this,e))&&(yield e),e===h(this,V)));)e=h(this,q)[e]},Ie=new WeakSet,ds=function(t){return t!==void 0&&h(this,R).get(h(this,D)[t])===t},ce=new WeakSet,Ve=function(t){var n,r;const e=h(this,G),s=h(this,D)[e],i=h(this,v)[e];return h(this,Vt)&&m(this,M,z).call(this,i)?i.__abortController.abort(new Error("evicted")):(h(this,ft)||h(this,Z))&&(h(this,ft)&&((n=h(this,ot))==null||n.call(this,i,s,"evict")),h(this,Z)&&((r=h(this,W))==null||r.push([i,s,"evict"]))),h(this,Zt).call(this,e),t&&(h(this,D)[e]=void 0,h(this,v)[e]=void 0,h(this,ht).push(e)),h(this,O)===1?(w(this,G,w(this,V,0)),h(this,ht).length=0):w(this,G,h(this,q)[e]),h(this,R).delete(s),Ee(this,O)._--,e},he=new WeakSet,We=function(t,e,s,i){const n=e===void 0?void 0:h(this,v)[e];if(m(this,M,z).call(this,n))return n;const r=new Ge,{signal:a}=s;a==null||a.addEventListener("abort",()=>r.abort(a.reason),{signal:r.signal});const l={signal:r.signal,options:s,context:i},u=(I,E=!1)=>{const{aborted:S}=r.signal,T=s.ignoreFetchAbort&&I!==void 0;if(s.status&&(S&&!E?(s.status.fetchAborted=!0,s.status.fetchError=r.signal.reason,T&&(s.status.fetchAbortIgnored=!0)):s.status.fetchResolved=!0),S&&!T&&!E)return f(r.signal.reason);const x=g;return h(this,v)[e]===g&&(I===void 0?x.__staleWhileFetching?h(this,v)[e]=x.__staleWhileFetching:m(this,vt,Dt).call(this,t,"fetch"):(s.status&&(s.status.fetchUpdated=!0),this.set(t,I,l.options))),I},d=I=>(s.status&&(s.status.fetchRejected=!0,s.status.fetchError=I),f(I)),f=I=>{const{aborted:E}=r.signal,S=E&&s.allowStaleOnFetchAbort,T=S||s.allowStaleOnFetchRejection,x=T||s.noDeleteOnFetchRejection,A=g;if(h(this,v)[e]===g&&(!x||A.__staleWhileFetching===void 0?m(this,vt,Dt).call(this,t,"fetch"):S||(h(this,v)[e]=A.__staleWhileFetching)),T)return s.status&&A.__staleWhileFetching!==void 0&&(s.status.returnedStale=!0),A.__staleWhileFetching;if(A.__returned===A)throw I},b=(I,E)=>{var T;const S=(T=h(this,ne))==null?void 0:T.call(this,t,n,l);S&&S instanceof Promise&&S.then(x=>I(x===void 0?void 0:x),E),r.signal.addEventListener("abort",()=>{(!s.ignoreFetchAbort||s.allowStaleOnFetchAbort)&&(I(void 0),s.allowStaleOnFetchAbort&&(I=x=>u(x,!0)))})};s.status&&(s.status.fetchDispatched=!0);const g=new Promise(b).then(u,d),_=Object.assign(g,{__abortController:r,__staleWhileFetching:n,__returned:void 0});return e===void 0?(this.set(t,_,{...l.options,status:void 0}),e=h(this,R).get(t)):h(this,v)[e]=_,_},M=new WeakSet,z=function(t){if(!h(this,Vt))return!1;const e=t;return!!e&&e instanceof Promise&&e.hasOwnProperty("__staleWhileFetching")&&e.__abortController instanceof Ge},Se=new WeakSet,ps=function(t,e){h(this,J)[e]=t,h(this,q)[t]=e},Xt=new WeakSet,ue=function(t){t!==h(this,V)&&(t===h(this,G)?w(this,G,h(this,q)[t]):m(this,Se,ps).call(this,h(this,J)[t],h(this,q)[t]),m(this,Se,ps).call(this,h(this,V),t),w(this,V,t))},vt=new WeakSet,Dt=function(t,e){var i,n,r,a;let s=!1;if(h(this,O)!==0){const l=h(this,R).get(t);if(l!==void 0)if(s=!0,h(this,O)===1)m(this,Ae,gs).call(this,e);else{h(this,Zt).call(this,l);const u=h(this,v)[l];if(m(this,M,z).call(this,u)?u.__abortController.abort(new Error("deleted")):(h(this,ft)||h(this,Z))&&(h(this,ft)&&((i=h(this,ot))==null||i.call(this,u,t,e)),h(this,Z)&&((n=h(this,W))==null||n.push([u,t,e]))),h(this,R).delete(t),h(this,D)[l]=void 0,h(this,v)[l]=void 0,l===h(this,V))w(this,V,h(this,J)[l]);else if(l===h(this,G))w(this,G,h(this,q)[l]);else{const d=h(this,J)[l];h(this,q)[d]=h(this,q)[l];const f=h(this,q)[l];h(this,J)[f]=h(this,J)[l]}Ee(this,O)._--,h(this,ht).push(l)}}if(h(this,Z)&&((r=h(this,W))!=null&&r.length)){const l=h(this,W);let u;for(;u=l==null?void 0:l.shift();)(a=h(this,at))==null||a.call(this,...u)}return s},Ae=new WeakSet,gs=function(t){var e,s,i;for(const n of m(this,yt,Ft).call(this,{allowStale:!0})){const r=h(this,v)[n];if(m(this,M,z).call(this,r))r.__abortController.abort(new Error("deleted"));else{const a=h(this,D)[n];h(this,ft)&&((e=h(this,ot))==null||e.call(this,r,a,t)),h(this,Z)&&((s=h(this,W))==null||s.push([r,a,t]))}}if(h(this,R).clear(),h(this,v).fill(void 0),h(this,D).fill(void 0),h(this,tt)&&h(this,ut)&&(h(this,tt).fill(0),h(this,ut).fill(0)),h(this,lt)&&h(this,lt).fill(0),w(this,G,0),w(this,V,0),h(this,ht).length=0,w(this,ct,0),w(this,O,0),h(this,Z)&&h(this,W)){const n=h(this,W);let r;for(;r=n==null?void 0:n.shift();)(i=h(this,at))==null||i.call(this,...r)}};let us=xs;const _t=class _t{static get(t){return this._meshes.get(t)}static lockIn(t){Object.seal(t)}static add(t,e){this._meshes.set(t,e)}static delete(t){for(const e of t)this._meshes.delete(e)}static setCapacity(t){t!==this._capacity&&(this._meshes.clear(),this._meshes=this.setupMeshes(t),this._capacity=t)}static setupMeshes(t){const e=Math.max(t??this.computeCapacity(),1),s=this.getSizeCalculationEvent(),i={maxSize:e,sizeCalculation:s};return new us(i)}static computeCapacity(){const t=globalThis.navigator&&"deviceMemory"in globalThis.navigator?globalThis.navigator.deviceMemory:null,s=t!==null?t:2,i=this.oneHundredMb*s;return Math.trunc(i)}static getDataSetMemory(t){let e=0;for(const s of t)e+=s.usedMemory;return Math.max(e,1)}static getSizeCalculationEvent(){return t=>Array.isArray(t)?this.getDataSetMemory(t):Math.max(t.usedMemory,1)}};c(_t,"oneHundredMb",1e8),c(_t,"_meshes",_t.setupMeshes()),c(_t,"_capacity"),c(_t,"_memoryAttributes",["positionBuffer","indexBuffer","normalBuffer"]),c(_t,"updateMeshMemory",t=>{t.usedMemory=0;for(const e of _t._memoryAttributes)t.usedMemory!==void 0&&t[e]&&(t.usedMemory+=t[e].byteLength);_t.lockIn(t)});let Ts=_t;class yn{constructor(t){c(this,"onModelLoaded",new Et);c(this,"models");c(this,"settings",{autoCoordinate:!0,maxUpdateRate:100,graphicsQuality:0});c(this,"baseCoordinates",null);c(this,"_connection");c(this,"_isDisposed",!1);c(this,"_autoRedrawInterval",null);c(this,"_lastUpdate",0);const e=this.newRequestEvent(),s=this.newUpdateEvent();this._connection=new Xi(e,t),this.models=new Gi(s),this.models.list.onItemDeleted.add(()=>{this.models.list.size===0&&(this.baseCoordinates=null)})}async load(t,e){const s=new ji(e.modelId,this.models,this._connection);e.userData&&(s.object.userData=e.userData),s.frozen=!0,s.graphicsQuality=this.settings.graphicsQuality;try{if(this.models.list.set(s.modelId,s),await s._setup(t,e.raw,e.virtualModelConfig),this.settings.autoCoordinate){const n=await s.getCoordinates();if(this.baseCoordinates===null)this.baseCoordinates=n;else{const[r,a,l]=n,[u,d,f]=this.baseCoordinates,b=new p(u-r,d-a,f-l);s.object.position.add(b)}}}catch(n){throw this.models.list.delete(s.modelId),n}const{camera:i}=e;return i&&s.useCamera(i),s.frozen=!1,this.onModelLoaded.trigger(s),s}async dispose(){this._isDisposed=!0;const t=Array.from(this.models.list.values()),e=[];for(const s of t)e.push(s.dispose());await Promise.all(e),this.onModelLoaded.reset()}async disposeModel(t){const e=this.models.list.get(t);e&&await e.dispose()}async update(t=!1){if(this._isDisposed)return;const e=performance.now();if(e-this._lastUpdate<this.settings.maxUpdateRate)return;this._lastUpdate=e;const s=[];for(const i of this.models.list.values())s.push(i._refreshView());await Promise.all(s),t?await this.models.forceUpdateFinish():this.models.update()}async manageRequest(t){const e=this.models.list.get(t.modelId);e&&await e.handleRequest(t)}newUpdateEvent(){return()=>{this._autoRedrawInterval&&clearTimeout(this._autoRedrawInterval);const t=this.settings.maxUpdateRate+1;this._autoRedrawInterval=setTimeout(()=>{this.update()},t)}}newRequestEvent(){return t=>{this.manageRequest(t)}}}export{Te as A,di as B,Lt as C,Et as E,Y as F,te as G,$ as S,pi as T,js as W,bt as a,Tt as b,Ot as c,It as d,St as e,nt as f,ys as g,yn as h};
