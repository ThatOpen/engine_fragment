import{V as T,cd as Ee,M as rt,ce as Et,f as He,cf as Ii,cg as aa,ch as vn,ci as nn,cj as rn,ck as Nr,cl as Rl,P as Yt,cm as si,cn as Wi,co as Wn,cp as Is,cq as Al,T as ji,cr as Pr,cs as oa,ct as Gs,g as Mr,bZ as wl,b_ as Fl,b$ as Sl,c0 as yl,c1 as fo,cu as ii,cv as xl,cw as Ol,cx as vl,cy as _a,cz as un,cA as Ll,e as Dr,k as Ea,l as ma,d as Ur,m as Nl,n as Pl,o as Ml,p as Dl,q as Ul,r as Vl,s as Bl,t as zl,u as Gl,v as kl,w as Yl,x as Hl,y as Wl,z as jl,A as ql,B as Zl,C as Xl,D as $l,E as Ql,G as Kl,H as Jl,J as th,K as eh,N as sh,R as ih,U as nh,W as rh,X as ah,Y as oh,Z as lh,_ as hh,$ as ch,a0 as dh,a1 as uh,a2 as fh,j as po,a3 as ph,a4 as bh,a5 as Ih,a6 as _h,a7 as Eh,a8 as mh,a9 as Ch,aa as gh,ab as Th,ac as Rh,ad as Ah,ae as wh,af as Fh,ag as Sh,ah as yh,ai as xh,aj as Oh,ak as vh,al as Lh,am as Nh,an as Ph,ao as Mh,ap as Dh,aq as Uh,ar as Vh,as as Bh,at as zh,au as Gh,av as kh,aw as Yh,ax as Hh,ay as Wh,az as jh,aA as qh,aB as Zh,aC as Xh,aD as $h,aE as Qh,aF as Kh,aG as Jh,aH as tc,aI as ec,aJ as sc,aK as ic,aL as nc,aM as rc,aN as ac,aO as oc,aP as lc,aQ as hc,aR as cc,aS as dc,aT as uc,aU as fc,aV as pc,aW as bc,aX as Ic,aY as _c,aZ as Ec,a_ as mc,a$ as Cc,b0 as gc,b1 as Tc,b2 as Rc,b3 as Ac,b4 as wc,b5 as Fc,b6 as Sc,b7 as yc,b8 as xc,b9 as Oc,ba as vc,bb as Lc,bc as Nc,bd as Pc,be as Mc,bf as Dc,bg as Uc,bh as Vc,bi as Bc,bj as zc,bk as Gc,bl as kc,bm as Yc,bn as Hc,bo as Wc,bp as jc,bq as qc,br as Zc,bs as Xc,bt as $c,bu as Qc,bv as Kc,bw as Jc,bx as td,by as ed,bz as sd,bA as id,i as bo,h as Io,bB as nd,bC as rd,bD as ad,bE as od,bF as ld,bG as hd,bH as cd,bI as dd,bJ as ud,bK as fd,bL as pd,bM as bd,bN as Id,bO as _d,bP as Ed,bQ as md,bR as Cd,bS as gd,bT as Td,bU as Rd,bV as Ad,bW as wd,bX as Fd,bY as Sd,I as Vr,L as _o,O as yd,c as xd,cB as Eo,cC as mo,Q as Co,cD as Od,c3 as vd,c4 as Ld,c5 as Nd,c6 as Pd,c7 as Md,cc as Dd,c9 as Ud}from"./pako.esm-TbDA1OGb.js";import{B as Vd}from"./byte-buffer-BEl4AvDu.js";var Bd=Object.defineProperty,zd=(n,t,e)=>t in n?Bd(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e,Gd=(n,t,e)=>(zd(n,t+"",e),e),go=(n,t,e)=>{if(!t.has(n))throw TypeError("Cannot "+e)},j=(n,t,e)=>(go(n,t,"read from private field"),e?e.call(n):t.get(n)),ws=(n,t,e)=>{if(t.has(n))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(n):t.set(n,e)},pi=(n,t,e,s)=>(go(n,t,"write to private field"),t.set(n,e),e),kd=`.container{background-color:var(--base00);color:var(--base05);padding:10px;letter-spacing:0.5px;font-family:monospace;border-radius:3px}.toolbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;padding-bottom:5px;border-bottom:solid 1px var(--base02)}.toolbar .options,.toolbar .search-wrapper{display:flex;align-items:center}.toolbar .icon-wrapper{height:15px;display:flex;align-items:center;padding:2px 5px}.toolbar .icon-wrapper:hover{background-color:var(--base02);border-radius:3px}.toolbar .icon-wrapper:first-child{margin-left:0px}.toolbar .search.icon{margin-right:5px}.toolbar .search-input{border:none;background:transparent;outline:none;flex:1;font-size:16px;color:var(--base0D)}.match{background-color:yellow;font-weight:bold;color:red}.data-row{padding:3px 0}.data-row .data-row{border-left:solid 1px var(--base02);padding-left:20px;margin-left:5px;display:none}.data-row.expanded>.data-row{display:block}.data-row .key-value-wrapper{display:flex;align-items:center}.data-row .key{color:var(--base07)}.data-row .key.number{color:var(--base0C)}.data-row .colon{color:var(--base07);margin:0 5px}.clickable{cursor:pointer}.data-row .opening-parenthesis,.data-row .closing-parenthesis{color:var(--base07)}.data-row .ellipsis{color:var(--base09)}.data-row.expanded>.key-value-wrapper .closing-parenthesis,.data-row.expanded>.key-value-wrapper .ellipsis{display:none}.data-row>.closing-parenthesis{display:none}.data-row.expanded>.closing-parenthesis{display:inline-block}.data-row .items-size{margin-left:10px;color:var(--base04);font-style:italic;display:none}.show-size .data-row .items-size{display:inline-block}.data-row .value.bool,.data-row .value.boolean{color:var(--base0E)}.data-row .value.function{color:var(--base0D)}.data-row .value.int,.data-row .value.integer{color:var(--base0F)}.data-row .value.float{color:var(--base0B)}.data-row .value.string{color:var(--base09)}.data-row .value.string .content{overflow-wrap:break-word}.data-row .value.string .content::before{content:open-quote}.data-row .value.string .content::after{content:close-quote}.data-row .value.regexp{color:var(--base0A)}.data-row .value.nan{color:var(--base08)}.data-row .value.null{color:var(--base0A)}.data-row .value.undefined{color:var(--base05)}.data-row .value.date{color:var(--base0D)}.data-row .value.nan,.data-row .value.null,.data-row .value.undefined{border-radius:3px;background-color:var(--base02);padding:1px 2px}.data-row .value .type{font-size:smaller;margin-right:4px;opacity:0.8;display:none}.data-row .value .value-data{word-break:break-all}.show-data-types .data-row .value .type{display:inline-block}.icon-wrapper,.copy-icon-wrapper{display:inline-block;cursor:pointer}.icon{display:block;position:relative}.icon:before,.icon:after{content:"";position:absolute;display:block}.expand.icon{margin-right:5px}.expand-icon-arrow .expand.icon{margin-left:3px;width:0;height:0;border-left:solid 6px var(--base0E);border-top:solid 6px transparent;border-bottom:solid 6px transparent}.expand-icon-arrow .expanded>.key-value-wrapper .expand.icon,.expand-icon-arrow .expanded.icon.expand{transform:rotate(90deg);border-left-color:var(--base0D)}.expand-icon-square .expand.icon,.expand-icon-circle .expand.icon{display:block;width:9px;height:9px;border-radius:2px;border:solid 1px var(--base0E)}.expand-icon-circle .expand.icon{border-radius:50%}.expand-icon-square .expand.icon:before,.expand-icon-circle .expand.icon:before,.expand-icon-square .expand.icon:after,.expand-icon-circle .expand.icon:after{width:5px;height:1px;background-color:var(--base0E);left:2px;top:4px}.expand-icon-square .expand.icon:after,.expand-icon-circle .expand.icon:after{transform:rotate(90deg)}.expand-icon-square .expanded>.key-value-wrapper .expand.icon:after,.expand-icon-circle .expanded>.key-value-wrapper .expand.icon:after,.expand-icon-square .expand.icon.expanded:after,.expand-icon-circle .expand.icon.expanded:after{display:none}.expand-icon-square .expanded>.key-value-wrapper .expand.icon,.expand-icon-circle .expanded>.key-value-wrapper .expand.icon,.expand-icon-square .expand.icon.expanded,.expand-icon-circle .expanded.expand.icon{border-color:var(--base0D)}.expand-icon-square .expanded>.key-value-wrapper .expand.icon:before,.expand-icon-circle .expanded>.key-value-wrapper .expand.icon:before,.expand-icon-square .expanded.expand.icon:before,.expand-icon-circle .expanded.expand.icon:before{background-color:var(--base0D)}.icon-wrapper{display:inline-block;cursor:pointer}.show-copy .key-value-wrapper:hover .icon.copy{display:block}.copy.icon{margin-left:10px;display:none;width:8px;height:10px;border:solid 1px var(--base0D);border-radius:1px;position:relative;top:4px;transition:0.2s all}.copy.icon:active{transform:scale(1.6);background-color:var(--base0B)}.copy.icon:before{content:"";display:block;left:-3px;top:-3px;width:8px;height:10px;border-top:solid 1px var(--base0D);border-left:solid 1px var(--base0D);border-radius:1px 0 0 0}.plus.icon{width:11px;height:1px;background-color:var(--base0D)}.plus.icon:after{content:"";width:11px;height:1px;background-color:var(--base0D);-webkit-transform:rotate(90deg);transform:rotate(90deg)}.minus.icon{width:11px;height:1px;background-color:var(--base0D)}.indent.icon{color:var(--base0D);width:17px;height:8px;border-top:solid 1px var(--base0D);border-bottom:solid 1px var(--base0D)}.indent.icon:before{content:"";position:absolute;top:2px;right:0;width:11px;height:2px;border-top:solid 1px var(--base0D);border-bottom:solid 1px var(--base0D)}.indent.icon:after{content:"";position:absolute;top:1px;width:0;height:0;border-top:solid 3px transparent;border-bottom:solid 3px transparent;border-left:solid 3px var(--base0D);border-right:solid 3px transparent}.outdent.icon{color:var(--base0D);margin-left:2px;width:17px;height:8px;border-top:solid 1px var(--base0D);border-bottom:solid 1px var(--base0D)}.outdent.icon:before{content:"";top:2px;right:0;width:11px;height:2px;border-top:solid 1px var(--base0D);border-bottom:solid 1px var(--base0D)}.outdent.icon:after{content:"";top:1px;left:-3px;width:0;height:0;border-top:solid 3px transparent;border-bottom:solid 3px transparent;border-left:solid 3px transparent;border-right:solid 3px var(--base0D)}.refresh.icon{color:var(--base0D);width:10px;height:10px;border-radius:50%;border-top:solid 1px var(--base0D);border-bottom:solid 1px var(--base0D);border-left:solid 1px transparent;border-right:solid 1px var(--base0D)}.refresh.icon:before{content:"";left:1px;top:8px;width:3px;height:3px;border-top:solid 1px var(--base0D);border-left:solid 1px var(--base0D);-webkit-transform:rotate(-22.5deg);transform:rotate(-22.5deg)}.info.icon{width:12px;height:11px;border:solid 1px var(--base0D);border-radius:2px}.info.icon::before{top:5px;left:5px;width:2px;height:5px;background-color:var(--base0D)}.info.icon::after{top:2px;left:5px;width:2px;height:2px;background-color:var(--base0D)}.info.icon.active{background-color:var(--base0D)}.info.icon.active::before,.info.icon.active::after{background-color:var(--base02)}.search.icon{color:var(--base0D);width:11px;height:11px;border:solid 1px var(--base0D);border-radius:100%;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}.search.icon:before{content:"";top:11px;left:5px;height:6px;width:1px;background-color:var(--base0D)}
`,Ca={apathy:["#031a16","#0b342d","#184e45","#2b685e","#5f9c92","#81b5ac","#a7cec8","#d2e7e4","#3e9688","#3e7996","#3e4c96","#883e96","#963e4c","#96883e","#4c963e","#3e965b"],ashes:["#1c2023","#393f45","#565e65","#747c84","#adb3ba","#c7ccd1","#dfe2e5","#f3f4f5","#c7ae95","#c7c795","#aec795","#95c7ae","#95aec7","#ae95c7","#c795ae","#c79595"],"atelier-dune-light":["#fefbec","#e8e4cf","#a6a28c","#999580","#7d7a68","#6e6b5e","#292824","#20201d","#d73737","#b65611","#ae9513","#60ac39","#1fad83","#6684e1","#b854d4","#d43552"],"atelier-dune":["#20201d","#292824","#6e6b5e","#7d7a68","#999580","#a6a28c","#e8e4cf","#fefbec","#d73737","#b65611","#ae9513","#60ac39","#1fad83","#6684e1","#b854d4","#d43552"],atlas:["#002635","#00384d","#517f8d","#6c8b91","#869696","#a1a19a","#e6e6dc","#fafaf8","#ff5a67","#f08e48","#ffcc1b","#7fc06e","#14747e","#5dd7b9","#9a70a4","#c43060"],bespin:["#28211c","#36312e","#5e5d5c","#666666","#797977","#8a8986","#9d9b97","#baae9e","#cf6a4c","#cf7d34","#f9ee98","#54be0d","#afc4db","#5ea6ea","#9b859d","#937121"],"black-metal":["#000000","#121212","#222222","#333333","#999999","#c1c1c1","#999999","#c1c1c1","#5f8787","#aaaaaa","#a06666","#dd9999","#aaaaaa","#888888","#999999","#444444"],brewer:["#0c0d0e","#2e2f30","#515253","#737475","#959697","#b7b8b9","#dadbdc","#fcfdfe","#e31a1c","#e6550d","#dca060","#31a354","#80b1d3","#3182bd","#756bb1","#b15928"],bright:["#000000","#303030","#505050","#b0b0b0","#d0d0d0","#e0e0e0","#f5f5f5","#ffffff","#fb0120","#fc6d24","#fda331","#a1c659","#76c7b7","#6fb3d2","#d381c3","#be643c"],brogrammer:["#1f1f1f","#f81118","#2dc55e","#ecba0f","#2a84d2","#4e5ab7","#1081d6","#d6dbe5","#d6dbe5","#de352e","#1dd361","#f3bd09","#1081d6","#5350b9","#0f7ddb","#ffffff"],"brushtrees-dark":["#485867","#5a6d7a","#6d828e","#8299a1","#98afb5","#b0c5c8","#c9dbdc","#e3efef","#b38686","#d8bba2","#aab386","#87b386","#86b3b3","#868cb3","#b386b2","#b39f9f"],brushtrees:["#e3efef","#c9dbdc","#b0c5c8","#98afb5","#8299a1","#6d828e","#5a6d7a","#485867","#b38686","#d8bba2","#aab386","#87b386","#86b3b3","#868cb3","#b386b2","#b39f9f"],chalk:["#151515","#202020","#303030","#505050","#b0b0b0","#d0d0d0","#e0e0e0","#f5f5f5","#fb9fb1","#eda987","#ddb26f","#acc267","#12cfc0","#6fc2ef","#e1a3ee","#deaf8f"],circus:["#191919","#202020","#303030","#5f5a60","#505050","#a7a7a7","#808080","#ffffff","#dc657d","#4bb1a7","#c3ba63","#84b97c","#4bb1a7","#639ee4","#b888e2","#b888e2"],"classic-dark":["#151515","#202020","#303030","#505050","#b0b0b0","#d0d0d0","#e0e0e0","#f5f5f5","#ac4142","#d28445","#f4bf75","#90a959","#75b5aa","#6a9fb5","#aa759f","#8f5536"],"classic-light":["#f5f5f5","#e0e0e0","#d0d0d0","#b0b0b0","#505050","#303030","#202020","#151515","#ac4142","#d28445","#f4bf75","#90a959","#75b5aa","#6a9fb5","#aa759f","#8f5536"],codeschool:["#232c31","#1c3657","#2a343a","#3f4944","#84898c","#9ea7a6","#a7cfa3","#b5d8f6","#2a5491","#43820d","#a03b1e","#237986","#b02f30","#484d79","#c59820","#c98344"],cupcake:["#fbf1f2","#f2f1f4","#d8d5dd","#bfb9c6","#a59daf","#8b8198","#72677e","#585062","#d57e85","#ebb790","#dcb16c","#a3b367","#69a9a7","#7297b9","#bb99b4","#baa58c"],cupertino:["#ffffff","#c0c0c0","#c0c0c0","#808080","#808080","#404040","#404040","#5e5e5e","#c41a15","#eb8500","#826b28","#007400","#318495","#0000ff","#a90d91","#826b28"],darcula:["#2b2b2b","#323232","#323232","#606366","#a4a3a3","#a9b7c6","#ffc66d","#ffffff","#4eade5","#689757","#bbb529","#6a8759","#629755","#9876aa","#cc7832","#808080"],darktooth:["#1d2021","#32302f","#504945","#665c54","#928374","#a89984","#d5c4a1","#fdf4c1","#fb543f","#fe8625","#fac03b","#95c085","#8ba59b","#0d6678","#8f4673","#a87322"],"default-dark":["#181818","#282828","#383838","#585858","#b8b8b8","#d8d8d8","#e8e8e8","#f8f8f8","#ab4642","#dc9656","#f7ca88","#a1b56c","#86c1b9","#7cafc2","#ba8baf","#a16946"],"default-light":["#ffffff","#e8e8e8","#d8d8d8","#b8b8b8","#585858","#383838","#282828","#181818","#ab4642","#dc9656","#ab4642","#a1b56c","#86c1b9","#7cafc2","#ba8baf","#a16946"],dracula:["#282936","#3a3c4e","#4d4f68","#626483","#62d6e8","#e9e9f4","#f1f2f8","#f7f7fb","#ea51b2","#b45bcf","#00f769","#ebff87","#a1efe4","#62d6e8","#b45bcf","#00f769"],eighties:["#2d2d2d","#393939","#515151","#747369","#a09f93","#d3d0c8","#e8e6df","#f2f0ec","#f2777a","#f99157","#ffcc66","#99cc99","#66cccc","#6699cc","#cc99cc","#d27b53"],embers:["#16130f","#2c2620","#433b32","#5a5047","#8a8075","#a39a90","#beb6ae","#dbd6d1","#826d57","#828257","#6d8257","#57826d","#576d82","#6d5782","#82576d","#825757"],flat:["#2c3e50","#34495e","#7f8c8d","#95a5a6","#bdc3c7","#e0e0e0","#f5f5f5","#ecf0f1","#e74c3c","#e67e22","#f1c40f","#2ecc71","#1abc9c","#3498db","#9b59b6","#be643c"],"fruit-soda":["#f1ecf1","#e0dee0","#d8d5d5","#b5b4b6","#979598","#515151","#474545","#2d2c2c","#fe3e31","#fe6d08","#f7e203","#47f74c","#0f9cfd","#2931df","#611fce","#b16f40"],github:["#ffffff","#f5f5f5","#c8c8fa","#969896","#e8e8e8","#333333","#ffffff","#969896","#ed6a43","#0086b3","#795da3","#183691","#183691","#795da3","#a71d5d","#333333"],"google-dark":["#1d1f21","#282a2e","#373b41","#969896","#b4b7b4","#c5c8c6","#e0e0e0","#ffffff","#cc342b","#f96a38","#fba922","#198844","#3971ed","#3971ed","#a36ac7","#3971ed"],"google-light":["#ffffff","#e0e0e0","#c5c8c6","#b4b7b4","#969896","#373b41","#282a2e","#1d1f21","#cc342b","#f96a38","#fba922","#198844","#3971ed","#3971ed","#a36ac7","#3971ed"],"grayscale-dark":["#101010","#252525","#464646","#525252","#ababab","#b9b9b9","#e3e3e3","#f7f7f7","#7c7c7c","#999999","#a0a0a0","#8e8e8e","#868686","#686868","#747474","#5e5e5e"],"grayscale-light":["#f7f7f7","#e3e3e3","#b9b9b9","#ababab","#525252","#464646","#252525","#101010","#7c7c7c","#999999","#a0a0a0","#8e8e8e","#868686","#686868","#747474","#5e5e5e"],greenscreen:["#001100","#003300","#005500","#007700","#009900","#00bb00","#00dd00","#00ff00","#007700","#009900","#007700","#00bb00","#005500","#009900","#00bb00","#005500"],"gruvbox-dark-hard":["#1d2021","#3c3836","#504945","#665c54","#bdae93","#d5c4a1","#ebdbb2","#fbf1c7","#fb4934","#fe8019","#fabd2f","#b8bb26","#8ec07c","#83a598","#d3869b","#d65d0e"],"gruvbox-light-hard":["#f9f5d7","#ebdbb2","#d5c4a1","#bdae93","#665c54","#504945","#3c3836","#282828","#9d0006","#af3a03","#b57614","#79740e","#427b58","#076678","#8f3f71","#d65d0e"],"harmonic-dark":["#0b1c2c","#223b54","#405c79","#627e99","#aabcce","#cbd6e2","#e5ebf1","#f7f9fb","#bf8b56","#bfbf56","#8bbf56","#56bf8b","#568bbf","#8b56bf","#bf568b","#bf5656"],"harmonic-light":["#f7f9fb","#e5ebf1","#cbd6e2","#aabcce","#627e99","#405c79","#223b54","#0b1c2c","#bf8b56","#bfbf56","#8bbf56","#56bf8b","#568bbf","#8b56bf","#bf568b","#bf5656"],"heetch-light":["#feffff","#392551","#7b6d8b","#9c92a8","#ddd6e5","#5a496e","#470546","#190134","#27d9d5","#bdb6c5","#5ba2b6","#f80059","#c33678","#47f9f5","#bd0152","#dedae2"],heetch:["#190134","#392551","#5a496e","#7b6d8b","#9c92a8","#bdb6c5","#dedae2","#feffff","#27d9d5","#5ba2b6","#8f6c97","#c33678","#f80059","#bd0152","#82034c","#470546"],helios:["#1d2021","#383c3e","#53585b","#6f7579","#cdcdcd","#d5d5d5","#dddddd","#e5e5e5","#d72638","#eb8413","#f19d1a","#88b92d","#1ba595","#1e8bac","#be4264","#c85e0d"],hopscotch:["#322931","#433b42","#5c545b","#797379","#989498","#b9b5b8","#d5d3d5","#ffffff","#dd464c","#fd8b19","#fdcc59","#8fc13e","#149b93","#1290bf","#c85e7c","#b33508"],"horizon-dark":["#1c1e26","#232530","#2e303e","#676a8d","#ced1d0","#cbced0","#dcdfe4","#e3e6ee","#e93c58","#e58d7d","#efb993","#efaf8e","#24a8b4","#df5273","#b072d1","#e4a382"],"ia-dark":["#1a1a1a","#222222","#1d414d","#767676","#b8b8b8","#cccccc","#e8e8e8","#f8f8f8","#d88568","#d86868","#b99353","#83a471","#7c9cae","#8eccdd","#b98eb2","#8b6c37"],"ia-light":["#f6f6f6","#dedede","#bde5f2","#898989","#767676","#181818","#e8e8e8","#898989","#9c5a02","#c43e18","#c48218","#38781c","#2d6bb1","#48bac2","#a94598","#8b6c37"],icy:["#021012","#031619","#041f23","#052e34","#064048","#095b67","#0c7c8c","#109cb0","#16c1d9","#b3ebf2","#80deea","#4dd0e1","#26c6da","#00bcd4","#00acc1","#0097a7"],isotope:["#000000","#404040","#606060","#808080","#c0c0c0","#d0d0d0","#e0e0e0","#ffffff","#ff0000","#ff9900","#ff0099","#33ff00","#00ffff","#0066ff","#cc00ff","#3300ff"],macintosh:["#000000","#404040","#404040","#808080","#808080","#c0c0c0","#c0c0c0","#ffffff","#dd0907","#ff6403","#fbf305","#1fb714","#02abea","#0000d3","#4700a5","#90713a"],marrakesh:["#201602","#302e00","#5f5b17","#6c6823","#86813b","#948e48","#ccc37a","#faf0a5","#c35359","#b36144","#a88339","#18974e","#75a738","#477ca1","#8868b3","#b3588e"],materia:["#263238","#2c393f","#37474f","#707880","#c9ccd3","#cdd3de","#d5dbe5","#ffffff","#ec5f67","#ea9560","#ffcc00","#8bd649","#80cbc4","#89ddff","#82aaff","#ec5f67"],"material-lighter":["#fafafa","#e7eaec","#cceae7","#ccd7da","#8796b0","#80cbc4","#80cbc4","#666666","#ff5370","#f76d47","#ffb62c","#91b859","#39adb5","#6182b8","#7c4dff","#e53935"],material:["#263238","#2e3c43","#314549","#546e7a","#b2ccd6","#eeffff","#eeffff","#ffffff","#f07178","#f78c6c","#ffcb6b","#c3e88d","#89ddff","#82aaff","#c792ea","#ff5370"],"mellow-purple":["#1e0528","#1a092d","#331354","#320f55","#873582","#ffeeff","#ffeeff","#f8c0ff","#00d9e9","#aa00a3","#955ae7","#05cb0d","#b900b1","#550068","#8991bb","#4d6fff"],"mexico-light":["#f8f8f8","#e8e8e8","#d8d8d8","#b8b8b8","#585858","#383838","#282828","#181818","#ab4642","#dc9656","#f79a0e","#538947","#4b8093","#7cafc2","#96609e","#a16946"],mocha:["#3b3228","#534636","#645240","#7e705a","#b8afad","#d0c8c6","#e9e1dd","#f5eeeb","#cb6077","#d28b71","#f4bc87","#beb55b","#7bbda4","#8ab3b5","#a89bb9","#bb9584"],monokai:["#272822","#383830","#49483e","#75715e","#a59f85","#f8f8f2","#f5f4f1","#f9f8f5","#f92672","#fd971f","#f4bf75","#a6e22e","#a1efe4","#66d9ef","#ae81ff","#cc6633"],nord:["#2e3440","#3b4252","#434c5e","#4c566a","#d8dee9","#e5e9f0","#eceff4","#8fbcbb","#88c0d0","#81a1c1","#5e81ac","#bf616a","#d08770","#ebcb8b","#a3be8c","#b48ead"],ocean:["#2b303b","#343d46","#4f5b66","#65737e","#a7adba","#c0c5ce","#dfe1e8","#eff1f5","#bf616a","#d08770","#ebcb8b","#a3be8c","#96b5b4","#8fa1b3","#b48ead","#ab7967"],"one-light":["#fafafa","#f0f0f1","#e5e5e6","#a0a1a7","#696c77","#383a42","#202227","#090a0b","#ca1243","#d75f00","#c18401","#50a14f","#0184bc","#4078f2","#a626a4","#986801"],onedark:["#282c34","#353b45","#3e4451","#545862","#565c64","#abb2bf","#b6bdca","#c8ccd4","#e06c75","#d19a66","#e5c07b","#98c379","#56b6c2","#61afef","#c678dd","#be5046"],"papercolor-dark":["#1c1c1c","#af005f","#5faf00","#d7af5f","#5fafd7","#808080","#d7875f","#d0d0d0","#585858","#5faf5f","#afd700","#af87d7","#ffaf00","#ff5faf","#00afaf","#5f8787"],"papercolor-light":["#eeeeee","#af0000","#008700","#5f8700","#0087af","#878787","#005f87","#444444","#bcbcbc","#d70000","#d70087","#8700af","#d75f00","#d75f00","#005faf","#005f87"],paraiso:["#2f1e2e","#41323f","#4f424c","#776e71","#8d8687","#a39e9b","#b9b6b0","#e7e9db","#ef6155","#f99b15","#fec418","#48b685","#5bc4bf","#06b6ef","#815ba4","#e96ba8"],pico:["#000000","#1d2b53","#7e2553","#008751","#ab5236","#5f574f","#c2c3c7","#fff1e8","#ff004d","#ffa300","#fff024","#00e756","#29adff","#83769c","#ff77a8","#ffccaa"],pop:["#000000","#202020","#303030","#505050","#b0b0b0","#d0d0d0","#e0e0e0","#ffffff","#eb008a","#f29333","#f8ca12","#37b349","#00aabb","#0e5a94","#b31e8d","#7a2d00"],railscasts:["#2b2b2b","#272935","#3a4055","#5a647e","#d4cfc9","#e6e1dc","#f4f1ed","#f9f7f3","#da4939","#cc7833","#ffc66d","#a5c261","#519f50","#6d9cbe","#b6b3eb","#bc9458"],seti:["#151718","#282a2b","#3b758c","#41535b","#43a5d5","#d6d6d6","#eeeeee","#ffffff","#cd3f45","#db7b55","#e6cd69","#9fca56","#55dbbe","#55b5db","#a074c4","#8a553f"],"solarized-dark":["#002b36","#073642","#586e75","#657b83","#839496","#93a1a1","#eee8d5","#fdf6e3","#dc322f","#cb4b16","#b58900","#859900","#2aa198","#268bd2","#6c71c4","#d33682"],"solarized-light":["#fdf6e3","#eee8d5","#93a1a1","#839496","#657b83","#586e75","#073642","#002b36","#dc322f","#cb4b16","#b58900","#859900","#2aa198","#268bd2","#6c71c4","#d33682"],spacemacs:["#1f2022","#282828","#444155","#585858","#b8b8b8","#a3a3a3","#e8e8e8","#f8f8f8","#f2241f","#ffa500","#b1951d","#67b11d","#2d9574","#4f97d7","#a31db1","#b03060"],"summerfruit-dark":["#151515","#202020","#303030","#505050","#b0b0b0","#d0d0d0","#e0e0e0","#ffffff","#ff0086","#fd8900","#aba800","#00c918","#1faaaa","#3777e6","#ad00a1","#cc6633"],"summerfruit-light":["#ffffff","#e0e0e0","#d0d0d0","#b0b0b0","#000000","#101010","#151515","#202020","#ff0086","#fd8900","#aba800","#00c918","#1faaaa","#3777e6","#ad00a1","#cc6633"],"tomorrow-night":["#1d1f21","#282a2e","#373b41","#969896","#b4b7b4","#c5c8c6","#e0e0e0","#ffffff","#cc6666","#de935f","#f0c674","#b5bd68","#8abeb7","#81a2be","#b294bb","#a3685a"],tomorrow:["#ffffff","#e0e0e0","#d6d6d6","#8e908c","#969896","#4d4d4c","#282a2e","#1d1f21","#c82829","#f5871f","#eab700","#718c00","#3e999f","#4271ae","#8959a8","#a3685a"],tube:["#231f20","#1c3f95","#5a5758","#737171","#959ca1","#d9d8d8","#e7e7e8","#ffffff","#ee2e24","#f386a1","#ffd204","#00853e","#85cebc","#009ddc","#98005d","#b06110"],twilight:["#1e1e1e","#323537","#464b50","#5f5a60","#838184","#a7a7a7","#c3c3c3","#ffffff","#cf6a4c","#cda869","#f9ee98","#8f9d6a","#afc4db","#7587a6","#9b859d","#9b703f"],woodland:["#231e18","#302b25","#48413a","#9d8b70","#b4a490","#cabcb1","#d7c8bc","#e4d4c8","#d35c5c","#ca7f32","#e0ac16","#b7ba53","#6eb958","#88a4d3","#bb90e2","#b49368"],zenburn:["#383838","#404040","#606060","#6f6f6f","#808080","#dcdccc","#c0c0c0","#ffffff","#dca3a3","#dfaf8f","#e0cf9f","#5f7f5f","#93e0e3","#7cb8bb","#dc8cc3","#000000"]},Yd=n=>{let t;if(typeof n=="string"){if(Ca[n]===void 0)throw new Error(`${n} not found`);t=Ca[n].reduce((e,s,i)=>{let r=`base0${i.toString(16).toUpperCase()}`;return e[r]=s,e},{})}else t=n;return`.container{${Object.keys(t).map(e=>`--${e}: ${t[e]};`).join("")}}`},Hd=n=>{try{return!!new URL(n)}catch{return!1}},Wd=n=>{if(Array.isArray(n))return"array";if(n===null)return"null";if(n instanceof RegExp)return"regexp";let t=typeof n;return t==="number"?isNaN(n)?"NaN":isFinite(n)?Number.isInteger(n)?"int":"float":"Infinity":t==="boolean"?"bool":t==="object"&&n instanceof Date?"date":t},fn=n=>{if(typeof n=="boolean")return n;if(n==="true")return!0;if(n==="false")return!1;throw new Error("should be a boolean!")},jd=n=>{if(typeof n=="string")return n;throw new Error("should be a string!")},qd=n=>{if(typeof n=="number"&&n>=0)return n;if(typeof n=="string"&&(n=parseFloat(n)),isNaN(n)||n<0)throw new Error("should be a positive number!");return n},Zd=n=>{if(typeof n=="boolean"||typeof n=="number")return n;if(n==="true")return!0;if(n==="false")return!1;if(typeof n=="string"&&(n=parseFloat(n),!isNaN(n)&&n>=0))return n;throw new Error("should be a boolean or a positive number!")},ga=n=>{if(typeof n=="object")return n;if(typeof n=="string")try{return JSON.parse(n)}catch{return n}throw new Error("should be a string or JSON!")},To=function({key:n,value:t,expanded:e,indent:s,onToggleExpand:i,level:r=0,parentRow:a}){let o=document.createElement("div");this.maxLevel=r;let h=Wd(t),l=h==="array"||h==="object",d=e===!0||e>r,u,p,f,m;o.className=`data-row ${d?"expanded":""}`,o.dataset.key=n,o.dataset.level=r,r>0&&(o.style.paddingLeft=`${s*5}px`);let b=document.createElement("span");b.className="key-value-wrapper",o.appendChild(b);let I=()=>{o.classList.toggle("expanded"),i&&(o.classList.contains("expanded")?i(r+1):i(r))};if(l){let g=document.createElement("span");g.className="icon-wrapper",b.appendChild(g),u=document.createElement("span"),u.className="expand icon clickable",u.setAttribute("title",d?"Collapse":"Expand"),g.appendChild(u),g.addEventListener("click",()=>I())}if(n!==null&&n!==""){let g=typeof n;f=document.createElement("span"),f.className=`key clickable ${g==="number"?"number":""}`,f.textContent=g==="number"?n:`"${n}"`,f.addEventListener("click",()=>I()),b.appendChild(f);let w=document.createElement("span");w.classList.add("colon"),w.textContent=":",b.appendChild(w)}if(l){let g=document.createElement("span");g.className="opening-parenthesis",g.textContent=h==="array"?"[":"{",b.appendChild(g);let w=document.createElement("span");w.className="ellipsis clickable",w.textContent="...",w.addEventListener("click",()=>I()),b.appendChild(w);let A=document.createElement("span");A.className="closing-parenthesis",A.textContent=h==="array"?"]":"}",b.appendChild(A);let y=document.createElement("span"),F=h==="array"?t.length:Object.keys(t).length;y.className="items-size",y.textContent=`${F} item${F===1?"":"s"}`,b.appendChild(y),p=[],(h==="array"?t.map((x,v)=>v):Object.keys(t)).forEach(x=>{let v=new To({key:x,value:t[x],expanded:e,indent:s,onToggleExpand:i,level:r+1,parentRow:o});p.push(v),o.appendChild(v.element),this.maxLevel=Math.max(this.maxLevel,v.maxLevel)});let S=document.createElement("span");S.className="closing-parenthesis",S.textContent=h==="array"?"]":"}",o.appendChild(S)}else{let g=null;["nan","NaN","undefined","null"].includes(h)||(g=document.createElement("span"),g.className="type",g.textContent=h.toLowerCase());let w=document.createElement("span");w.className=`value ${h.toLowerCase()}`,m=document.createElement("span"),m.className="value-data",m.textContent=h==="string"?`"${t}"`:t,g&&w.appendChild(g),w.appendChild(m),b.appendChild(w)}let C=document.createElement("span");C.className="copy icon",C.setAttribute("title","Copy to clipboard");let R=document.createElement("span");R.className="icon-wrapper",R.addEventListener("click",()=>{navigator.clipboard.writeText(JSON.stringify(t,null,s))}),R.appendChild(C),b.appendChild(R);let E=g=>{let w=new RegExp(g,"gi"),A=[];f&&A.push(f),m&&A.push(m);let y=!1;A.forEach(F=>{let S=F.textContent;if(F.innerHTML=S,!g||g==="")return;let x=[...S.matchAll(w)].map(V=>V.index),v=[],M=0;x.forEach(V=>{y=!0,v.push(S.slice(M,V)),v.push(`<span class="match">${g}</span>`),M=V+g.length}),v.push(S.slice(M)),F.innerHTML=v.join("")}),y&&!o.classList.contains("expanded")&&(I(),a&&a.classList.add("expanded"))};this.update=({expanded:g,indent:w,searchTerm:A})=>{w!==void 0&&r>0&&(o.style.paddingLeft=`${w*5}px`),g!==void 0&&(d=g===!0||g>r,o.classList.toggle("expanded",d),u&&(u.title=d?"Collapse":"Expand")),A!=null&&E(A),p&&p.forEach(y=>y.update({expanded:g,indent:w,searchTerm:A}))},this.element=o},Xd=To,$d=function({expanded:n,indent:t,onChange:e,onSearch:s,showDetails:i}){this.indent=t||2,this.expanded=typeof n=="number"?n:2,this.showDetails=i!==!1,this.maxExpandLevel=0;let r,a=document.createElement("div");a.className="toolbar";let o=document.createElement("div");o.className="options",a.appendChild(o);let h=document.createElement("div");h.className="search-wrapper",a.appendChild(h);let l=document.createElement("div");l.className="icon-wrapper clickable",o.appendChild(l);let d=document.createElement("span");d.className="icon refresh",l.onclick=()=>this.refresh(),l.appendChild(d);let u=document.createElement("div");u.className="icon-wrapper clickable",o.appendChild(u);let p=document.createElement("span");p.className="icon plus",u.appendChild(p),u.onclick=()=>{this.expanded<this.maxExpandLevel&&(this.expanded+=1),e({expanded:this.expanded})};let f=document.createElement("div");f.className="icon-wrapper clickable",o.appendChild(f);let m=document.createElement("span");m.className="icon minus",f.appendChild(m),f.onclick=()=>{this.expanded>this.maxExpandLevel&&(this.expanded=this.maxExpandLevel),this.expanded>0&&(this.expanded-=1),e({expanded:this.expanded})};let b=document.createElement("div");b.className="icon-wrapper clickable",o.appendChild(b);let I=document.createElement("span");I.className="icon indent",b.onclick=()=>{this.indent+=1,e({indent:this.indent})},b.appendChild(I);let C=document.createElement("div");C.className="icon-wrapper clickable",o.appendChild(C);let R=document.createElement("span");R.className="icon outdent",C.onclick=()=>{this.indent-=1,e({indent:this.indent})},C.appendChild(R);let E=document.createElement("div");E.className="icon-wrapper clickable",o.appendChild(E);let g=document.createElement("span");g.className=`icon info ${this.showDetails?"active":""}`,E.onclick=()=>{g.classList.toggle("active"),this.showDetails=!this.showDetails,e({showDetails:this.showDetails})},E.appendChild(g);let w=document.createElement("span");w.className="icon search",h.appendChild(w),r=document.createElement("input"),r.className="search-input",r.placeholder="Search",r.oninput=A=>{s(A.target.value)},h.appendChild(r),this.refresh=()=>{this.expanded=1,this.indent=2,r&&(r.value=""),e({indent:2,expanded:1}),s("")},this.updateShowDetails=A=>{this.showDetails=A,this.showDetails?g.classList.add("active"):g.classList.remove("active")},this.element=a},Qd=$d;function Kd(n,t={}){let e=document.createElement("div");e.className="container",n.appendChild(e);let s=null,i=null,r={};this.update=({data:a,expanded:o,indent:h,expandIconType:l,showDataTypes:d,showToolbar:u,showSize:p,showCopy:f})=>{if(a){let b=JSON.stringify(a);r.dataComapreString!==b&&(r.dataComapreString=b,s=new Xd({key:"",value:a,expanded:o,indent:h,onToggleExpand:I=>{i&&(i.expanded=I),r.expanded=I}}),e.replaceChildren(s.element),r.showToolbar&&i&&(e.prepend(i.element),i.maxExpandLevel=s.maxLevel,i.refresh()))}if(u!==void 0&&r.showToolbar!==u)if(r.showToolbar=u,u)i||(i=new Qd({expanded:r.expanded,indent:r.indent,onChange:({expanded:b,indent:I,showDetails:C})=>{let R={expanded:b,indent:I};C!==void 0&&(R.showCopy=C,R.showSize=C,R.showDataTypes=C),this.update(R)},onSearch:b=>{s&&s.update({searchTerm:b})}})),s&&(i.maxExpandLevel=s.maxLevel),e.prepend(i.element);else{let b=e.querySelector(".toolbar");b&&b.remove()}let m={};o!==void 0&&r.expanded!==o&&(r.expanded=o,m.expanded=o),h!==void 0&&r.indent!==h&&(r.indent=h,m.indent=h),Object.keys(m).length>0&&s&&s.update(m),f!==void 0&&r.showCopy!==f&&(r.showCopy=f,e.classList.toggle("show-copy",f)),p!==void 0&&r.showSize!==p&&(r.showSize=p,e.classList.toggle("show-size",p),i&&i.updateShowDetails(r.showSize||r.showDataTypes)),d!==void 0&&r.showDataTypes!==d&&(r.showDataTypes=d,e.classList.toggle("show-data-types",d),i&&i.updateShowDetails(r.showSize||r.showDataTypes)),l!==void 0&&r.expandIconType!==l&&(e.classList.add(`expand-icon-${l}`),e.classList.remove(`expand-icon-${r.expandIconType}`),r.expandIconType=l)},this.update(t)}var Jd=Kd,Ta={indent:2,expanded:1,theme:"default-light",showDataTypes:!0,showToolbar:!1,expandIconType:"arrow",showCopy:!0,showSize:!0,data:null},ks,gt,_i,Ln,Ys,Ke,Ei,la=class extends HTMLElement{constructor(){super(),ws(this,ks,void 0),ws(this,gt,void 0),ws(this,_i,void 0),ws(this,Ln,void 0),ws(this,Ys,(...s)=>{console.warn(`JsonViewer${this.id?` (${this.id})`:""}:`,...s)}),ws(this,Ke,(s,i,r,a)=>{try{if(i=r(i),a&&!a.includes(i))throw new Error(`should be one of ${a.join(", ")}`);if(j(this,gt)[s]===i)return;j(this,gt)[s]=i,j(this,Ei).call(this)}catch(o){j(this,Ys).call(this,`Attribute ${s}: ${o.message}`)}}),ws(this,Ei,()=>{j(this,Ln).update({data:j(this,_i),expanded:j(this,gt).expanded,expandIconType:j(this,gt).expandIconType,indent:j(this,gt).indent,showDataTypes:j(this,gt).showDataTypes,showToolbar:j(this,gt).showToolbar,showSize:j(this,gt).showSize,showCopy:j(this,gt).showCopy})}),pi(this,gt,{...Ta}),pi(this,ks,document.createElement("style"));let t=this.attachShadow({mode:"open"}),e=document.createElement("style");e.textContent=`${kd}`,t.appendChild(e),t.appendChild(j(this,ks)),this.theme=j(this,gt).theme,pi(this,Ln,new Jd(t,j(this,gt)))}static get observedAttributes(){return Object.keys(Ta).map(t=>t.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase())}set showDataTypes(t){j(this,Ke).call(this,"showDataTypes",t,fn)}set showToolbar(t){j(this,Ke).call(this,"showToolbar",t,fn)}set indent(t){j(this,Ke).call(this,"indent",t,qd)}set expandIconType(t){j(this,Ke).call(this,"expandIconType",t,jd,["arrow","square","circle"])}set expanded(t){j(this,Ke).call(this,"expanded",t,Zd)}set showSize(t){j(this,Ke).call(this,"showSize",t,fn)}set showCopy(t){j(this,Ke).call(this,"showCopy",t,fn)}set theme(t){try{if(t=ga(t),j(this,gt).theme===t&&j(this,ks).textContent!=="")return;j(this,ks).textContent=Yd(t),j(this,gt).theme=t}catch(e){j(this,Ys).call(this,`Attribute theme: ${e.message}`)}}set data(t){try{t=ga(t);let e=JSON.stringify(t);if(j(this,gt).data===e)return;j(this,gt).data=e,Hd(t)?fetch(t).then(s=>s.json()).then(s=>{pi(this,_i,s),j(this,Ei).call(this)}):(pi(this,_i,t),j(this,Ei).call(this))}catch(e){j(this,Ys).call(this,`Attribute data: ${e.message}`)}}get options(){return j(this,gt)}connectedCallback(){window.addEventListener("DOMContentLoaded",()=>{let t=this.textContent;this.textContent="",t&&(this.data=t)})}attributeChangedCallback(t,e,s){if(la.allowedAttributes.indexOf(t)>-1){let i=t.replace(/-([a-z])/g,r=>r[1].toUpperCase());this[i]=s}else j(this,Ys).call(this,`Attribute ${t} is not supported and will be ignored!`),this.removeAttribute(t)}},Ro=la;ks=new WeakMap,gt=new WeakMap,_i=new WeakMap,Ln=new WeakMap,Ys=new WeakMap,Ke=new WeakMap,Ei=new WeakMap,Gd(Ro,"allowedAttributes",["id"].concat(la.observedAttributes));customElements.get("andypf-json-viewer")||customElements.define("andypf-json-viewer",Ro);var Ra,Oi,Aa,wa,De,ue,Ue,Hs,Pe,vi,mi,St,fe,At,ht,z,Jt,pe,Gt,Pt,Ge,Mt,Ve,Be,be,ze,vs,te,Ci,N,Br,qs,ds,jn,Ie,Ao,Zs,Li,qn,ls,us,cr,Zn,Nn,at,dr,gi,_s,zr,tu=Object.defineProperty,wo=n=>{throw TypeError(n)},c=(n,t,e)=>((s,i,r)=>i in s?tu(s,i,{enumerable:!0,configurable:!0,writable:!0,value:r}):s[i]=r)(n,typeof t!="symbol"?t+"":t,e),ha=(n,t,e)=>t.has(n)||wo("Cannot "+e),_=(n,t,e)=>(ha(n,t,"read from private field"),e?e.call(n):t.get(n)),X=(n,t,e)=>t.has(n)?wo("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(n):t.set(n,e),B=(n,t,e,s)=>(ha(n,t,"write to private field"),t.set(n,e),e),D=(n,t,e)=>(ha(n,t,"access private method"),e),Gr=(n,t,e,s)=>({set _(i){B(n,t,i)},get _(){return _(n,t,s)}});function kr(n,t){const e=Object.getPrototypeOf(n),s=Object.getOwnPropertyNames(e);for(const i of s){if(i==="constructor"||i==="__init"||i.includes("mutate_")||i.match(/.*Array$/))continue;const r=e[i];if(typeof r=="function"){const a=n[`${i}Length`]!==void 0&&n[`${i}Array`]!==void 0;if(r.length===2||a){const h=n[`${i}Length`](),l=[];t[i]=l;for(let d=0;d<h;d++){const u=n[i](d);if(typeof u=="object"&&u!==null&&"bb"in u){const p={};kr(u,p),l.push(p)}else l.push(u)}continue}const o=n[i]();if(typeof o!="object"||o===null){t[i]=o;continue}t[i]={},kr(o,t[i])}else t[i]=r}}const Ni={950732822:"IFCURIREFERENCE",4075327185:"IFCTIME",1209108979:"IFCTEMPERATURERATEOFCHANGEMEASURE",3457685358:"IFCSOUNDPRESSURELEVELMEASURE",4157543285:"IFCSOUNDPOWERLEVELMEASURE",2798247006:"IFCPROPERTYSETDEFINITIONSET",1790229001:"IFCPOSITIVEINTEGER",525895558:"IFCNONNEGATIVELENGTHMEASURE",1774176899:"IFCLINEINDEX",1275358634:"IFCLANGUAGEID",2541165894:"IFCDURATION",3701338814:"IFCDAYINWEEKNUMBER",2195413836:"IFCDATETIME",937566702:"IFCDATE",1683019596:"IFCCARDINALPOINTREFERENCE",2314439260:"IFCBINARY",1500781891:"IFCAREADENSITYMEASURE",3683503648:"IFCARCINDEX",4065007721:"IFCYEARNUMBER",1718600412:"IFCWARPINGMOMENTMEASURE",51269191:"IFCWARPINGCONSTANTMEASURE",2593997549:"IFCVOLUMETRICFLOWRATEMEASURE",3458127941:"IFCVOLUMEMEASURE",3345633955:"IFCVAPORPERMEABILITYMEASURE",1278329552:"IFCTORQUEMEASURE",2591213694:"IFCTIMESTAMP",2726807636:"IFCTIMEMEASURE",743184107:"IFCTHERMODYNAMICTEMPERATUREMEASURE",2016195849:"IFCTHERMALTRANSMITTANCEMEASURE",857959152:"IFCTHERMALRESISTANCEMEASURE",2281867870:"IFCTHERMALEXPANSIONCOEFFICIENTMEASURE",2645777649:"IFCTHERMALCONDUCTIVITYMEASURE",232962298:"IFCTHERMALADMITTANCEMEASURE",296282323:"IFCTEXTTRANSFORMATION",603696268:"IFCTEXTFONTNAME",3490877962:"IFCTEXTDECORATION",1460886941:"IFCTEXTALIGNMENT",2801250643:"IFCTEXT",58845555:"IFCTEMPERATUREGRADIENTMEASURE",361837227:"IFCSPECULARROUGHNESS",2757832317:"IFCSPECULAREXPONENT",3477203348:"IFCSPECIFICHEATCAPACITYMEASURE",993287707:"IFCSOUNDPRESSUREMEASURE",846465480:"IFCSOUNDPOWERMEASURE",3471399674:"IFCSOLIDANGLEMEASURE",408310005:"IFCSHEARMODULUSMEASURE",2190458107:"IFCSECTIONALAREAINTEGRALMEASURE",3467162246:"IFCSECTIONMODULUSMEASURE",2766185779:"IFCSECONDINMINUTE",3211557302:"IFCROTATIONALSTIFFNESSMEASURE",1755127002:"IFCROTATIONALMASSMEASURE",2133746277:"IFCROTATIONALFREQUENCYMEASURE",200335297:"IFCREAL",96294661:"IFCRATIOMEASURE",3972513137:"IFCRADIOACTIVITYMEASURE",3665567075:"IFCPRESSUREMEASURE",2169031380:"IFCPRESENTABLETEXT",1364037233:"IFCPOWERMEASURE",1245737093:"IFCPOSITIVERATIOMEASURE",3054510233:"IFCPOSITIVEPLANEANGLEMEASURE",2815919920:"IFCPOSITIVELENGTHMEASURE",4042175685:"IFCPLANEANGLEMEASURE",2642773653:"IFCPLANARFORCEMEASURE",2260317790:"IFCPARAMETERVALUE",929793134:"IFCPHMEASURE",2395907400:"IFCNUMERICMEASURE",2095195183:"IFCNORMALISEDRATIOMEASURE",765770214:"IFCMONTHINYEARNUMBER",2615040989:"IFCMONETARYMEASURE",3114022597:"IFCMOMENTOFINERTIAMEASURE",1648970520:"IFCMOLECULARWEIGHTMEASURE",3177669450:"IFCMOISTUREDIFFUSIVITYMEASURE",1753493141:"IFCMODULUSOFSUBGRADEREACTIONMEASURE",1052454078:"IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE",2173214787:"IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE",3341486342:"IFCMODULUSOFELASTICITYMEASURE",102610177:"IFCMINUTEINHOUR",3531705166:"IFCMASSPERLENGTHMEASURE",3124614049:"IFCMASSMEASURE",4017473158:"IFCMASSFLOWRATEMEASURE",1477762836:"IFCMASSDENSITYMEASURE",2486716878:"IFCMAGNETICFLUXMEASURE",286949696:"IFCMAGNETICFLUXDENSITYMEASURE",151039812:"IFCLUMINOUSINTENSITYMEASURE",2755797622:"IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE",2095003142:"IFCLUMINOUSFLUXMEASURE",503418787:"IFCLOGICAL",3086160713:"IFCLINEARVELOCITYMEASURE",1307019551:"IFCLINEARSTIFFNESSMEASURE",2128979029:"IFCLINEARMOMENTMEASURE",191860431:"IFCLINEARFORCEMEASURE",1243674935:"IFCLENGTHMEASURE",3258342251:"IFCLABEL",2054016361:"IFCKINEMATICVISCOSITYMEASURE",3192672207:"IFCISOTHERMALMOISTURECAPACITYMEASURE",3686016028:"IFCIONCONCENTRATIONMEASURE",3809634241:"IFCINTEGERCOUNTRATEMEASURE",1939436016:"IFCINTEGER",2679005408:"IFCINDUCTANCEMEASURE",3358199106:"IFCILLUMINANCEMEASURE",983778844:"IFCIDENTIFIER",2589826445:"IFCHOURINDAY",1158859006:"IFCHEATINGVALUEMEASURE",3113092358:"IFCHEATFLUXDENSITYMEASURE",3064340077:"IFCGLOBALLYUNIQUEID",3044325142:"IFCFREQUENCYMEASURE",1361398929:"IFCFORCEMEASURE",2590844177:"IFCFONTWEIGHT",2715512545:"IFCFONTVARIANT",1102727119:"IFCFONTSTYLE",2078135608:"IFCENERGYMEASURE",2506197118:"IFCELECTRICVOLTAGEMEASURE",2951915441:"IFCELECTRICRESISTANCEMEASURE",3790457270:"IFCELECTRICCURRENTMEASURE",2093906313:"IFCELECTRICCONDUCTANCEMEASURE",3818826038:"IFCELECTRICCHARGEMEASURE",1827137117:"IFCELECTRICCAPACITANCEMEASURE",69416015:"IFCDYNAMICVISCOSITYMEASURE",524656162:"IFCDOSEEQUIVALENTMEASURE",4134073009:"IFCDIMENSIONCOUNT",1514641115:"IFCDESCRIPTIVEMEASURE",300323983:"IFCDAYLIGHTSAVINGHOUR",86635668:"IFCDAYINMONTHNUMBER",94842927:"IFCCURVATUREMEASURE",1778710042:"IFCCOUNTMEASURE",3238673880:"IFCCONTEXTDEPENDENTMEASURE",3812528620:"IFCCOMPOUNDPLANEANGLEMEASURE",2991860651:"IFCCOMPLEXNUMBER",1867003952:"IFCBOXALIGNMENT",2735952531:"IFCBOOLEAN",2650437152:"IFCAREAMEASURE",632304761:"IFCANGULARVELOCITYMEASURE",360377573:"IFCAMOUNTOFSUBSTANCEMEASURE",4182062534:"IFCACCELERATIONMEASURE",3699917729:"IFCABSORBEDDOSEMEASURE",1971632696:"IFCGEOSLICE",2680139844:"IFCGEOMODEL",24726584:"IFCELECTRICFLOWTREATMENTDEVICE",3693000487:"IFCDISTRIBUTIONBOARD",3460952963:"IFCCONVEYORSEGMENT",3999819293:"IFCCAISSONFOUNDATION",3314249567:"IFCBOREHOLE",4196446775:"IFCBEARING",325726236:"IFCALIGNMENT",3425753595:"IFCTRACKELEMENT",991950508:"IFCSIGNAL",3798194928:"IFCREINFORCEDSOIL",3290496277:"IFCRAIL",1383356374:"IFCPAVEMENT",2182337498:"IFCNAVIGATIONELEMENT",234836483:"IFCMOORINGDEVICE",2078563270:"IFCMOBILETELECOMMUNICATIONSAPPLIANCE",1638804497:"IFCLIQUIDTERMINAL",1154579445:"IFCLINEARPOSITIONINGELEMENT",2696325953:"IFCKERB",2713699986:"IFCGEOTECHNICALASSEMBLY",2142170206:"IFCELECTRICFLOWTREATMENTDEVICETYPE",3376911765:"IFCEARTHWORKSFILL",1077100507:"IFCEARTHWORKSELEMENT",3071239417:"IFCEARTHWORKSCUT",479945903:"IFCDISTRIBUTIONBOARDTYPE",3426335179:"IFCDEEPFOUNDATION",1502416096:"IFCCOURSE",2940368186:"IFCCONVEYORSEGMENTTYPE",3203706013:"IFCCAISSONFOUNDATIONTYPE",3862327254:"IFCBUILTSYSTEM",1876633798:"IFCBUILTELEMENT",963979645:"IFCBRIDGEPART",644574406:"IFCBRIDGE",3649138523:"IFCBEARINGTYPE",1662888072:"IFCALIGNMENTVERTICAL",317615605:"IFCALIGNMENTSEGMENT",1545765605:"IFCALIGNMENTHORIZONTAL",4266260250:"IFCALIGNMENTCANT",3956297820:"IFCVIBRATIONDAMPERTYPE",1530820697:"IFCVIBRATIONDAMPER",840318589:"IFCVEHICLE",1953115116:"IFCTRANSPORTATIONDEVICE",618700268:"IFCTRACKELEMENTTYPE",2281632017:"IFCTENDONCONDUITTYPE",3663046924:"IFCTENDONCONDUIT",42703149:"IFCSINESPIRAL",1894708472:"IFCSIGNALTYPE",3599934289:"IFCSIGNTYPE",33720170:"IFCSIGN",1027922057:"IFCSEVENTHORDERPOLYNOMIALSPIRAL",544395925:"IFCSEGMENTEDREFERENCECURVE",3649235739:"IFCSECONDORDERPOLYNOMIALSPIRAL",550521510:"IFCROADPART",146592293:"IFCROAD",3818125796:"IFCRELADHERESTOELEMENT",4021432810:"IFCREFERENT",1891881377:"IFCRAILWAYPART",3992365140:"IFCRAILWAY",1763565496:"IFCRAILTYPE",1946335990:"IFCPOSITIONINGELEMENT",514975943:"IFCPAVEMENTTYPE",506776471:"IFCNAVIGATIONELEMENTTYPE",710110818:"IFCMOORINGDEVICETYPE",1950438474:"IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE",976884017:"IFCMARINEPART",525669439:"IFCMARINEFACILITY",1770583370:"IFCLIQUIDTERMINALTYPE",2176059722:"IFCLINEARELEMENT",679976338:"IFCKERBTYPE",3948183225:"IFCIMPACTPROTECTIONDEVICETYPE",2568555532:"IFCIMPACTPROTECTIONDEVICE",2898700619:"IFCGRADIENTCURVE",1594536857:"IFCGEOTECHNICALSTRATUM",4230923436:"IFCGEOTECHNICALELEMENT",4228831410:"IFCFACILITYPARTCOMMON",1310830890:"IFCFACILITYPART",24185140:"IFCFACILITY",4234616927:"IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID",1306400036:"IFCDEEPFOUNDATIONTYPE",4189326743:"IFCCOURSETYPE",2000195564:"IFCCOSINESPIRAL",3497074424:"IFCCLOTHOID",1626504194:"IFCBUILTELEMENTTYPE",3651464721:"IFCVEHICLETYPE",1229763772:"IFCTRIANGULATEDIRREGULARNETWORK",3665877780:"IFCTRANSPORTATIONDEVICETYPE",782932809:"IFCTHIRDORDERPOLYNOMIALSPIRAL",2735484536:"IFCSPIRAL",1356537516:"IFCSECTIONEDSURFACE",1290935644:"IFCSECTIONEDSOLIDHORIZONTAL",1862484736:"IFCSECTIONEDSOLID",1441486842:"IFCRELPOSITIONS",1033248425:"IFCRELASSOCIATESPROFILEDEF",3381221214:"IFCPOLYNOMIALCURVE",2485787929:"IFCOFFSETCURVEBYDISTANCES",590820931:"IFCOFFSETCURVE",3465909080:"IFCINDEXEDPOLYGONALTEXTUREMAP",593015953:"IFCDIRECTRIXCURVESWEPTAREASOLID",4212018352:"IFCCURVESEGMENT",3425423356:"IFCAXIS2PLACEMENTLINEAR",823603102:"IFCSEGMENT",2165702409:"IFCPOINTBYDISTANCEEXPRESSION",182550632:"IFCOPENCROSSPROFILEDEF",388784114:"IFCLINEARPLACEMENT",536804194:"IFCALIGNMENTHORIZONTALSEGMENT",3752311538:"IFCALIGNMENTCANTSEGMENT",1010789467:"IFCTEXTURECOORDINATEINDICESWITHVOIDS",222769930:"IFCTEXTURECOORDINATEINDICES",2691318326:"IFCQUANTITYNUMBER",3633395639:"IFCALIGNMENTVERTICALSEGMENT",2879124712:"IFCALIGNMENTPARAMETERSEGMENT",25142252:"IFCCONTROLLER",3087945054:"IFCALARM",4288193352:"IFCACTUATOR",630975310:"IFCUNITARYCONTROLELEMENT",4086658281:"IFCSENSOR",2295281155:"IFCPROTECTIVEDEVICETRIPPINGUNIT",182646315:"IFCFLOWINSTRUMENT",1426591983:"IFCFIRESUPPRESSIONTERMINAL",819412036:"IFCFILTER",3415622556:"IFCFAN",1003880860:"IFCELECTRICTIMECONTROL",402227799:"IFCELECTRICMOTOR",264262732:"IFCELECTRICGENERATOR",3310460725:"IFCELECTRICFLOWSTORAGEDEVICE",862014818:"IFCELECTRICDISTRIBUTIONBOARD",1904799276:"IFCELECTRICAPPLIANCE",1360408905:"IFCDUCTSILENCER",3518393246:"IFCDUCTSEGMENT",342316401:"IFCDUCTFITTING",562808652:"IFCDISTRIBUTIONCIRCUIT",4074379575:"IFCDAMPER",3640358203:"IFCCOOLINGTOWER",4136498852:"IFCCOOLEDBEAM",2272882330:"IFCCONDENSER",3571504051:"IFCCOMPRESSOR",3221913625:"IFCCOMMUNICATIONSAPPLIANCE",639361253:"IFCCOIL",3902619387:"IFCCHILLER",4217484030:"IFCCABLESEGMENT",1051757585:"IFCCABLEFITTING",3758799889:"IFCCABLECARRIERSEGMENT",635142910:"IFCCABLECARRIERFITTING",2938176219:"IFCBURNER",32344328:"IFCBOILER",2906023776:"IFCBEAMSTANDARDCASE",277319702:"IFCAUDIOVISUALAPPLIANCE",2056796094:"IFCAIRTOAIRHEATRECOVERY",177149247:"IFCAIRTERMINALBOX",1634111441:"IFCAIRTERMINAL",486154966:"IFCWINDOWSTANDARDCASE",4237592921:"IFCWASTETERMINAL",4156078855:"IFCWALLELEMENTEDCASE",4207607924:"IFCVALVE",4292641817:"IFCUNITARYEQUIPMENT",3179687236:"IFCUNITARYCONTROLELEMENTTYPE",3026737570:"IFCTUBEBUNDLE",3825984169:"IFCTRANSFORMER",812556717:"IFCTANK",1162798199:"IFCSWITCHINGDEVICE",385403989:"IFCSTRUCTURALLOADCASE",1404847402:"IFCSTACKTERMINAL",1999602285:"IFCSPACEHEATER",3420628829:"IFCSOLARDEVICE",3027962421:"IFCSLABSTANDARDCASE",3127900445:"IFCSLABELEMENTEDCASE",1329646415:"IFCSHADINGDEVICE",3053780830:"IFCSANITARYTERMINAL",2572171363:"IFCREINFORCINGBARTYPE",1232101972:"IFCRATIONALBSPLINECURVEWITHKNOTS",90941305:"IFCPUMP",655969474:"IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",738039164:"IFCPROTECTIVEDEVICE",1156407060:"IFCPLATESTANDARDCASE",3612865200:"IFCPIPESEGMENT",310824031:"IFCPIPEFITTING",3694346114:"IFCOUTLET",144952367:"IFCOUTERBOUNDARYCURVE",2474470126:"IFCMOTORCONNECTION",1911478936:"IFCMEMBERSTANDARDCASE",1437502449:"IFCMEDICALDEVICE",629592764:"IFCLIGHTFIXTURE",76236018:"IFCLAMP",2176052936:"IFCJUNCTIONBOX",4175244083:"IFCINTERCEPTOR",2068733104:"IFCHUMIDIFIER",3319311131:"IFCHEATEXCHANGER",2188021234:"IFCFLOWMETER",1209101575:"IFCEXTERNALSPATIALELEMENT",484807127:"IFCEVAPORATOR",3747195512:"IFCEVAPORATIVECOOLER",2814081492:"IFCENGINE",2417008758:"IFCELECTRICDISTRIBUTIONBOARDTYPE",3242481149:"IFCDOORSTANDARDCASE",3205830791:"IFCDISTRIBUTIONSYSTEM",400855858:"IFCCOMMUNICATIONSAPPLIANCETYPE",905975707:"IFCCOLUMNSTANDARDCASE",1677625105:"IFCCIVILELEMENT",3296154744:"IFCCHIMNEY",2674252688:"IFCCABLEFITTINGTYPE",2188180465:"IFCBURNERTYPE",1177604601:"IFCBUILDINGSYSTEM",39481116:"IFCBUILDINGELEMENTPARTTYPE",1136057603:"IFCBOUNDARYCURVE",2461110595:"IFCBSPLINECURVEWITHKNOTS",1532957894:"IFCAUDIOVISUALAPPLIANCETYPE",4088093105:"IFCWORKCALENDAR",4009809668:"IFCWINDOWTYPE",926996030:"IFCVOIDINGFEATURE",2391383451:"IFCVIBRATIONISOLATOR",2415094496:"IFCTENDONTYPE",3081323446:"IFCTENDONANCHORTYPE",413509423:"IFCSYSTEMFURNITUREELEMENT",3101698114:"IFCSURFACEFEATURE",3657597509:"IFCSTRUCTURALSURFACEACTION",2757150158:"IFCSTRUCTURALCURVEREACTION",1004757350:"IFCSTRUCTURALCURVEACTION",338393293:"IFCSTAIRTYPE",1072016465:"IFCSOLARDEVICETYPE",4074543187:"IFCSHADINGDEVICETYPE",2157484638:"IFCSEAMCURVE",2781568857:"IFCROOFTYPE",2310774935:"IFCREINFORCINGMESHTYPE",964333572:"IFCREINFORCINGELEMENTTYPE",683857671:"IFCRATIONALBSPLINESURFACEWITHKNOTS",1469900589:"IFCRAMPTYPE",2839578677:"IFCPOLYGONALFACESET",1158309216:"IFCPILETYPE",3079942009:"IFCOPENINGSTANDARDCASE",1114901282:"IFCMEDICALDEVICETYPE",3113134337:"IFCINTERSECTIONCURVE",3946677679:"IFCINTERCEPTORTYPE",2571569899:"IFCINDEXEDPOLYCURVE",3493046030:"IFCGEOGRAPHICELEMENT",1509553395:"IFCFURNITURE",1893162501:"IFCFOOTINGTYPE",2853485674:"IFCEXTERNALSPATIALSTRUCTUREELEMENT",4148101412:"IFCEVENT",132023988:"IFCENGINETYPE",2397081782:"IFCELEMENTASSEMBLYTYPE",2323601079:"IFCDOORTYPE",1213902940:"IFCCYLINDRICALSURFACE",1525564444:"IFCCONSTRUCTIONPRODUCTRESOURCETYPE",4105962743:"IFCCONSTRUCTIONMATERIALRESOURCETYPE",2185764099:"IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",15328376:"IFCCOMPOSITECURVEONSURFACE",3875453745:"IFCCOMPLEXPROPERTYTEMPLATE",3893394355:"IFCCIVILELEMENTTYPE",2197970202:"IFCCHIMNEYTYPE",167062518:"IFCBSPLINESURFACEWITHKNOTS",2887950389:"IFCBSPLINESURFACE",2603310189:"IFCADVANCEDBREPWITHVOIDS",1635779807:"IFCADVANCEDBREP",2916149573:"IFCTRIANGULATEDFACESET",1935646853:"IFCTOROIDALSURFACE",2387106220:"IFCTESSELLATEDFACESET",3206491090:"IFCTASKTYPE",699246055:"IFCSURFACECURVE",4095615324:"IFCSUBCONTRACTRESOURCETYPE",603775116:"IFCSTRUCTURALSURFACEREACTION",4015995234:"IFCSPHERICALSURFACE",2481509218:"IFCSPATIALZONETYPE",463610769:"IFCSPATIALZONE",710998568:"IFCSPATIALELEMENTTYPE",1412071761:"IFCSPATIALELEMENT",3663146110:"IFCSIMPLEPROPERTYTEMPLATE",3243963512:"IFCREVOLVEDAREASOLIDTAPERED",816062949:"IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",1521410863:"IFCRELSPACEBOUNDARY2NDLEVEL",3523091289:"IFCRELSPACEBOUNDARY1STLEVEL",427948657:"IFCRELINTERFERESELEMENTS",307848117:"IFCRELDEFINESBYTEMPLATE",1462361463:"IFCRELDEFINESBYOBJECT",2565941209:"IFCRELDECLARES",1027710054:"IFCRELASSIGNSTOGROUPBYFACTOR",3521284610:"IFCPROPERTYTEMPLATE",492091185:"IFCPROPERTYSETTEMPLATE",653396225:"IFCPROJECTLIBRARY",569719735:"IFCPROCEDURETYPE",3967405729:"IFCPREDEFINEDPROPERTYSET",1682466193:"IFCPCURVE",428585644:"IFCLABORRESOURCETYPE",2294589976:"IFCINDEXEDPOLYGONALFACEWITHVOIDS",178912537:"IFCINDEXEDPOLYGONALFACE",4095422895:"IFCGEOGRAPHICELEMENTTYPE",2652556860:"IFCFIXEDREFERENCESWEPTAREASOLID",2804161546:"IFCEXTRUDEDAREASOLIDTAPERED",4024345920:"IFCEVENTTYPE",2629017746:"IFCCURVEBOUNDEDSURFACE",1815067380:"IFCCREWRESOURCETYPE",3419103109:"IFCCONTEXT",2574617495:"IFCCONSTRUCTIONRESOURCETYPE",2059837836:"IFCCARTESIANPOINTLIST3D",1675464909:"IFCCARTESIANPOINTLIST2D",574549367:"IFCCARTESIANPOINTLIST",3406155212:"IFCADVANCEDFACE",3698973494:"IFCTYPERESOURCE",3736923433:"IFCTYPEPROCESS",901063453:"IFCTESSELLATEDITEM",1096409881:"IFCSWEPTDISKSOLIDPOLYGONAL",1042787934:"IFCRESOURCETIME",1608871552:"IFCRESOURCECONSTRAINTRELATIONSHIP",2943643501:"IFCRESOURCEAPPROVALRELATIONSHIP",2090586900:"IFCQUANTITYSET",1482703590:"IFCPROPERTYTEMPLATEDEFINITION",3778827333:"IFCPREDEFINEDPROPERTIES",2998442950:"IFCMIRROREDPROFILEDEF",853536259:"IFCMATERIALRELATIONSHIP",3404854881:"IFCMATERIALPROFILESETUSAGETAPERING",3079605661:"IFCMATERIALPROFILESETUSAGE",2852063980:"IFCMATERIALCONSTITUENTSET",3708119e3:"IFCMATERIALCONSTITUENT",1585845231:"IFCLAGTIME",2133299955:"IFCINDEXEDTRIANGLETEXTUREMAP",1437953363:"IFCINDEXEDTEXTUREMAP",3570813810:"IFCINDEXEDCOLOURMAP",1437805879:"IFCEXTERNALREFERENCERELATIONSHIP",297599258:"IFCEXTENDEDPROPERTIES",211053100:"IFCEVENTTIME",2713554722:"IFCCONVERSIONBASEDUNITWITHOFFSET",3285139300:"IFCCOLOURRGBLIST",1236880293:"IFCWORKTIME",1199560280:"IFCTIMEPERIOD",3611470254:"IFCTEXTUREVERTEXLIST",2771591690:"IFCTASKTIMERECURRING",1549132990:"IFCTASKTIME",2043862942:"IFCTABLECOLUMN",2934153892:"IFCSURFACEREINFORCEMENTAREA",609421318:"IFCSTRUCTURALLOADORRESULT",3478079324:"IFCSTRUCTURALLOADCONFIGURATION",1054537805:"IFCSCHEDULINGTIME",2439245199:"IFCRESOURCELEVELRELATIONSHIP",2433181523:"IFCREFERENCE",3915482550:"IFCRECURRENCEPATTERN",986844984:"IFCPROPERTYABSTRACTION",3843373140:"IFCPROJECTEDCRS",677532197:"IFCPRESENTATIONITEM",1507914824:"IFCMATERIALUSAGEDEFINITION",552965576:"IFCMATERIALPROFILEWITHOFFSETS",164193824:"IFCMATERIALPROFILESET",2235152071:"IFCMATERIALPROFILE",1847252529:"IFCMATERIALLAYERWITHOFFSETS",760658860:"IFCMATERIALDEFINITION",3057273783:"IFCMAPCONVERSION",4294318154:"IFCEXTERNALINFORMATION",1466758467:"IFCCOORDINATEREFERENCESYSTEM",1785450214:"IFCCOORDINATEOPERATION",775493141:"IFCCONNECTIONVOLUMEGEOMETRY",979691226:"IFCREINFORCINGBAR",3700593921:"IFCELECTRICDISTRIBUTIONPOINT",1062813311:"IFCDISTRIBUTIONCONTROLELEMENT",1052013943:"IFCDISTRIBUTIONCHAMBERELEMENT",578613899:"IFCCONTROLLERTYPE",2454782716:"IFCCHAMFEREDGEFEATURE",753842376:"IFCBEAM",3001207471:"IFCALARMTYPE",2874132201:"IFCACTUATORTYPE",3304561284:"IFCWINDOW",3512223829:"IFCWALLSTANDARDCASE",2391406946:"IFCWALL",3313531582:"IFCVIBRATIONISOLATORTYPE",2347447852:"IFCTENDONANCHOR",3824725483:"IFCTENDON",2515109513:"IFCSTRUCTURALANALYSISMODEL",4252922144:"IFCSTAIRFLIGHT",331165859:"IFCSTAIR",1529196076:"IFCSLAB",1783015770:"IFCSENSORTYPE",1376911519:"IFCROUNDEDEDGEFEATURE",2016517767:"IFCROOF",2320036040:"IFCREINFORCINGMESH",3027567501:"IFCREINFORCINGELEMENT",3055160366:"IFCRATIONALBEZIERCURVE",3283111854:"IFCRAMPFLIGHT",3024970846:"IFCRAMP",2262370178:"IFCRAILING",3171933400:"IFCPLATE",1687234759:"IFCPILE",1073191201:"IFCMEMBER",900683007:"IFCFOOTING",3508470533:"IFCFLOWTREATMENTDEVICE",2223149337:"IFCFLOWTERMINAL",707683696:"IFCFLOWSTORAGEDEVICE",987401354:"IFCFLOWSEGMENT",3132237377:"IFCFLOWMOVINGDEVICE",4037862832:"IFCFLOWINSTRUMENTTYPE",4278956645:"IFCFLOWFITTING",2058353004:"IFCFLOWCONTROLLER",4222183408:"IFCFIRESUPPRESSIONTERMINALTYPE",1810631287:"IFCFILTERTYPE",346874300:"IFCFANTYPE",1658829314:"IFCENERGYCONVERSIONDEVICE",857184966:"IFCELECTRICALELEMENT",1634875225:"IFCELECTRICALCIRCUIT",712377611:"IFCELECTRICTIMECONTROLTYPE",1217240411:"IFCELECTRICMOTORTYPE",1365060375:"IFCELECTRICHEATERTYPE",1534661035:"IFCELECTRICGENERATORTYPE",3277789161:"IFCELECTRICFLOWSTORAGEDEVICETYPE",663422040:"IFCELECTRICAPPLIANCETYPE",855621170:"IFCEDGEFEATURE",2030761528:"IFCDUCTSILENCERTYPE",3760055223:"IFCDUCTSEGMENTTYPE",869906466:"IFCDUCTFITTINGTYPE",395920057:"IFCDOOR",3041715199:"IFCDISTRIBUTIONPORT",3040386961:"IFCDISTRIBUTIONFLOWELEMENT",1945004755:"IFCDISTRIBUTIONELEMENT",2063403501:"IFCDISTRIBUTIONCONTROLELEMENTTYPE",1599208980:"IFCDISTRIBUTIONCHAMBERELEMENTTYPE",2635815018:"IFCDISCRETEACCESSORYTYPE",1335981549:"IFCDISCRETEACCESSORY",4147604152:"IFCDIAMETERDIMENSION",3961806047:"IFCDAMPERTYPE",3495092785:"IFCCURTAINWALL",1973544240:"IFCCOVERING",2954562838:"IFCCOOLINGTOWERTYPE",335055490:"IFCCOOLEDBEAMTYPE",488727124:"IFCCONSTRUCTIONPRODUCTRESOURCE",1060000209:"IFCCONSTRUCTIONMATERIALRESOURCE",3898045240:"IFCCONSTRUCTIONEQUIPMENTRESOURCE",1163958913:"IFCCONDITIONCRITERION",2188551683:"IFCCONDITION",2816379211:"IFCCONDENSERTYPE",3850581409:"IFCCOMPRESSORTYPE",843113511:"IFCCOLUMN",2301859152:"IFCCOILTYPE",2611217952:"IFCCIRCLE",2951183804:"IFCCHILLERTYPE",1285652485:"IFCCABLESEGMENTTYPE",3293546465:"IFCCABLECARRIERSEGMENTTYPE",395041908:"IFCCABLECARRIERFITTINGTYPE",1909888760:"IFCBUILDINGELEMENTPROXYTYPE",1095909175:"IFCBUILDINGELEMENTPROXY",2979338954:"IFCBUILDINGELEMENTPART",52481810:"IFCBUILDINGELEMENTCOMPONENT",3299480353:"IFCBUILDINGELEMENT",231477066:"IFCBOILERTYPE",1916977116:"IFCBEZIERCURVE",819618141:"IFCBEAMTYPE",1967976161:"IFCBSPLINECURVE",3460190687:"IFCASSET",2470393545:"IFCANGULARDIMENSION",1871374353:"IFCAIRTOAIRHEATRECOVERYTYPE",3352864051:"IFCAIRTERMINALTYPE",1411407467:"IFCAIRTERMINALBOXTYPE",3821786052:"IFCACTIONREQUEST",1213861670:"IFC2DCOMPOSITECURVE",1033361043:"IFCZONE",3342526732:"IFCWORKSCHEDULE",4218914973:"IFCWORKPLAN",1028945134:"IFCWORKCONTROL",1133259667:"IFCWASTETERMINALTYPE",1898987631:"IFCWALLTYPE",2769231204:"IFCVIRTUALELEMENT",728799441:"IFCVALVETYPE",1911125066:"IFCUNITARYEQUIPMENTTYPE",1600972822:"IFCTUBEBUNDLETYPE",3593883385:"IFCTRIMMEDCURVE",1620046519:"IFCTRANSPORTELEMENT",1692211062:"IFCTRANSFORMERTYPE",1637806684:"IFCTIMESERIESSCHEDULE",5716631:"IFCTANKTYPE",2254336722:"IFCSYSTEM",2315554128:"IFCSWITCHINGDEVICETYPE",148013059:"IFCSUBCONTRACTRESOURCE",1975003073:"IFCSTRUCTURALSURFACECONNECTION",2986769608:"IFCSTRUCTURALRESULTGROUP",1235345126:"IFCSTRUCTURALPOINTREACTION",734778138:"IFCSTRUCTURALPOINTCONNECTION",2082059205:"IFCSTRUCTURALPOINTACTION",3987759626:"IFCSTRUCTURALPLANARACTIONVARYING",1621171031:"IFCSTRUCTURALPLANARACTION",1252848954:"IFCSTRUCTURALLOADGROUP",1721250024:"IFCSTRUCTURALLINEARACTIONVARYING",1807405624:"IFCSTRUCTURALLINEARACTION",2445595289:"IFCSTRUCTURALCURVEMEMBERVARYING",214636428:"IFCSTRUCTURALCURVEMEMBER",4243806635:"IFCSTRUCTURALCURVECONNECTION",1179482911:"IFCSTRUCTURALCONNECTION",682877961:"IFCSTRUCTURALACTION",1039846685:"IFCSTAIRFLIGHTTYPE",3112655638:"IFCSTACKTERMINALTYPE",3812236995:"IFCSPACETYPE",652456506:"IFCSPACEPROGRAM",1305183839:"IFCSPACEHEATERTYPE",3856911033:"IFCSPACE",2533589738:"IFCSLABTYPE",4097777520:"IFCSITE",4105383287:"IFCSERVICELIFE",3517283431:"IFCSCHEDULETIMECONTROL",1768891740:"IFCSANITARYTERMINALTYPE",2863920197:"IFCRELASSIGNSTASKS",160246688:"IFCRELAGGREGATES",2324767716:"IFCRAMPFLIGHTTYPE",2893384427:"IFCRAILINGTYPE",3248260540:"IFCRADIUSDIMENSION",2250791053:"IFCPUMPTYPE",1842657554:"IFCPROTECTIVEDEVICETYPE",3651124850:"IFCPROJECTIONELEMENT",3642467123:"IFCPROJECTORDERRECORD",2904328755:"IFCPROJECTORDER",2744685151:"IFCPROCEDURE",3740093272:"IFCPORT",3724593414:"IFCPOLYLINE",4017108033:"IFCPLATETYPE",4231323485:"IFCPIPESEGMENTTYPE",804291784:"IFCPIPEFITTINGTYPE",3327091369:"IFCPERMIT",2382730787:"IFCPERFORMANCEHISTORY",2837617999:"IFCOUTLETTYPE",3425660407:"IFCORDERACTION",3588315303:"IFCOPENINGELEMENT",4143007308:"IFCOCCUPANT",1916936684:"IFCMOVE",977012517:"IFCMOTORCONNECTIONTYPE",3181161470:"IFCMEMBERTYPE",2108223431:"IFCMECHANICALFASTENERTYPE",377706215:"IFCMECHANICALFASTENER",2506943328:"IFCLINEARDIMENSION",1161773419:"IFCLIGHTFIXTURETYPE",1051575348:"IFCLAMPTYPE",3827777499:"IFCLABORRESOURCE",4288270099:"IFCJUNCTIONBOXTYPE",2391368822:"IFCINVENTORY",1806887404:"IFCHUMIDIFIERTYPE",1251058090:"IFCHEATEXCHANGERTYPE",2706460486:"IFCGROUP",3009204131:"IFCGRID",200128114:"IFCGASTERMINALTYPE",814719939:"IFCFURNITURESTANDARD",263784265:"IFCFURNISHINGELEMENT",3009222698:"IFCFLOWTREATMENTDEVICETYPE",2297155007:"IFCFLOWTERMINALTYPE",1339347760:"IFCFLOWSTORAGEDEVICETYPE",1834744321:"IFCFLOWSEGMENTTYPE",1482959167:"IFCFLOWMOVINGDEVICETYPE",3815607619:"IFCFLOWMETERTYPE",3198132628:"IFCFLOWFITTINGTYPE",3907093117:"IFCFLOWCONTROLLERTYPE",1287392070:"IFCFEATUREELEMENTSUBTRACTION",2143335405:"IFCFEATUREELEMENTADDITION",2827207264:"IFCFEATUREELEMENT",2489546625:"IFCFASTENERTYPE",647756555:"IFCFASTENER",3737207727:"IFCFACETEDBREPWITHVOIDS",807026263:"IFCFACETEDBREP",3390157468:"IFCEVAPORATORTYPE",3174744832:"IFCEVAPORATIVECOOLERTYPE",3272907226:"IFCEQUIPMENTSTANDARD",1962604670:"IFCEQUIPMENTELEMENT",2107101300:"IFCENERGYCONVERSIONDEVICETYPE",1704287377:"IFCELLIPSE",2590856083:"IFCELEMENTCOMPONENTTYPE",1623761950:"IFCELEMENTCOMPONENT",4123344466:"IFCELEMENTASSEMBLY",1758889154:"IFCELEMENT",360485395:"IFCELECTRICALBASEPROPERTIES",3849074793:"IFCDISTRIBUTIONFLOWELEMENTTYPE",3256556792:"IFCDISTRIBUTIONELEMENTTYPE",681481545:"IFCDIMENSIONCURVEDIRECTEDCALLOUT",1457835157:"IFCCURTAINWALLTYPE",3295246426:"IFCCREWRESOURCE",1916426348:"IFCCOVERINGTYPE",1419761937:"IFCCOSTSCHEDULE",3895139033:"IFCCOSTITEM",3293443760:"IFCCONTROL",2559216714:"IFCCONSTRUCTIONRESOURCE",2510884976:"IFCCONIC",3732776249:"IFCCOMPOSITECURVE",300633059:"IFCCOLUMNTYPE",2937912522:"IFCCIRCLEHOLLOWPROFILEDEF",3124254112:"IFCBUILDINGSTOREY",1950629157:"IFCBUILDINGELEMENTTYPE",4031249490:"IFCBUILDING",1260505505:"IFCBOUNDEDCURVE",3649129432:"IFCBOOLEANCLIPPINGRESULT",1334484129:"IFCBLOCK",3207858831:"IFCASYMMETRICISHAPEPROFILEDEF",1674181508:"IFCANNOTATION",2296667514:"IFCACTOR",2097647324:"IFCTRANSPORTELEMENTTYPE",3473067441:"IFCTASK",1580310250:"IFCSYSTEMFURNITUREELEMENTTYPE",4124788165:"IFCSURFACEOFREVOLUTION",2809605785:"IFCSURFACEOFLINEAREXTRUSION",2028607225:"IFCSURFACECURVESWEPTAREASOLID",4070609034:"IFCSTRUCTUREDDIMENSIONCALLOUT",2218152070:"IFCSTRUCTURALSURFACEMEMBERVARYING",3979015343:"IFCSTRUCTURALSURFACEMEMBER",3689010777:"IFCSTRUCTURALREACTION",530289379:"IFCSTRUCTURALMEMBER",3136571912:"IFCSTRUCTURALITEM",3544373492:"IFCSTRUCTURALACTIVITY",451544542:"IFCSPHERE",3893378262:"IFCSPATIALSTRUCTUREELEMENTTYPE",2706606064:"IFCSPATIALSTRUCTUREELEMENT",3626867408:"IFCRIGHTCIRCULARCYLINDER",4158566097:"IFCRIGHTCIRCULARCONE",1856042241:"IFCREVOLVEDAREASOLID",2914609552:"IFCRESOURCE",1401173127:"IFCRELVOIDSELEMENT",3451746338:"IFCRELSPACEBOUNDARY",366585022:"IFCRELSERVICESBUILDINGS",4122056220:"IFCRELSEQUENCE",1058617721:"IFCRELSCHEDULESCOSTITEMS",1245217292:"IFCRELREFERENCEDINSPATIALSTRUCTURE",750771296:"IFCRELPROJECTSELEMENT",202636808:"IFCRELOVERRIDESPROPERTIES",2051452291:"IFCRELOCCUPIESSPACES",3268803585:"IFCRELNESTS",4189434867:"IFCRELINTERACTIONREQUIREMENTS",279856033:"IFCRELFLOWCONTROLELEMENTS",3940055652:"IFCRELFILLSELEMENT",781010003:"IFCRELDEFINESBYTYPE",4186316022:"IFCRELDEFINESBYPROPERTIES",693640335:"IFCRELDEFINES",2551354335:"IFCRELDECOMPOSES",2802773753:"IFCRELCOVERSSPACES",886880790:"IFCRELCOVERSBLDGELEMENTS",3242617779:"IFCRELCONTAINEDINSPATIALSTRUCTURE",3678494232:"IFCRELCONNECTSWITHREALIZINGELEMENTS",504942748:"IFCRELCONNECTSWITHECCENTRICITY",1638771189:"IFCRELCONNECTSSTRUCTURALMEMBER",3912681535:"IFCRELCONNECTSSTRUCTURALELEMENT",2127690289:"IFCRELCONNECTSSTRUCTURALACTIVITY",3190031847:"IFCRELCONNECTSPORTS",4201705270:"IFCRELCONNECTSPORTTOELEMENT",3945020480:"IFCRELCONNECTSPATHELEMENTS",1204542856:"IFCRELCONNECTSELEMENTS",826625072:"IFCRELCONNECTS",2851387026:"IFCRELASSOCIATESPROFILEPROPERTIES",2655215786:"IFCRELASSOCIATESMATERIAL",3840914261:"IFCRELASSOCIATESLIBRARY",982818633:"IFCRELASSOCIATESDOCUMENT",2728634034:"IFCRELASSOCIATESCONSTRAINT",919958153:"IFCRELASSOCIATESCLASSIFICATION",4095574036:"IFCRELASSOCIATESAPPROVAL",1327628568:"IFCRELASSOCIATESAPPLIEDVALUE",1865459582:"IFCRELASSOCIATES",205026976:"IFCRELASSIGNSTORESOURCE",3372526763:"IFCRELASSIGNSTOPROJECTORDER",2857406711:"IFCRELASSIGNSTOPRODUCT",4278684876:"IFCRELASSIGNSTOPROCESS",1307041759:"IFCRELASSIGNSTOGROUP",2495723537:"IFCRELASSIGNSTOCONTROL",1683148259:"IFCRELASSIGNSTOACTOR",3939117080:"IFCRELASSIGNS",3454111270:"IFCRECTANGULARTRIMMEDSURFACE",2798486643:"IFCRECTANGULARPYRAMID",2770003689:"IFCRECTANGLEHOLLOWPROFILEDEF",3219374653:"IFCPROXY",1451395588:"IFCPROPERTYSET",4194566429:"IFCPROJECTIONCURVE",103090709:"IFCPROJECT",4208778838:"IFCPRODUCT",2945172077:"IFCPROCESS",220341763:"IFCPLANE",603570806:"IFCPLANARBOX",3566463478:"IFCPERMEABLECOVERINGPROPERTIES",3505215534:"IFCOFFSETCURVE3D",3388369263:"IFCOFFSETCURVE2D",3888040117:"IFCOBJECT",1425443689:"IFCMANIFOLDSOLIDBREP",1281925730:"IFCLINE",572779678:"IFCLSHAPEPROFILEDEF",1484403080:"IFCISHAPEPROFILEDEF",987898635:"IFCGEOMETRICCURVESET",1268542332:"IFCFURNITURETYPE",4238390223:"IFCFURNISHINGELEMENTTYPE",3455213021:"IFCFLUIDFLOWPROPERTIES",315944413:"IFCFILLAREASTYLETILES",4203026998:"IFCFILLAREASTYLETILESYMBOLWITHSTYLE",374418227:"IFCFILLAREASTYLEHATCHING",2047409740:"IFCFACEBASEDSURFACEMODEL",477187591:"IFCEXTRUDEDAREASOLID",80994333:"IFCENERGYPROPERTIES",2835456948:"IFCELLIPSEPROFILEDEF",2777663545:"IFCELEMENTARYSURFACE",339256511:"IFCELEMENTTYPE",1883228015:"IFCELEMENTQUANTITY",1472233963:"IFCEDGELOOP",4006246654:"IFCDRAUGHTINGPREDEFINEDCURVEFONT",445594917:"IFCDRAUGHTINGPREDEFINEDCOLOUR",3073041342:"IFCDRAUGHTINGCALLOUT",526551008:"IFCDOORSTYLE",1714330368:"IFCDOORPANELPROPERTIES",2963535650:"IFCDOORLININGPROPERTIES",32440307:"IFCDIRECTION",4054601972:"IFCDIMENSIONCURVETERMINATOR",606661476:"IFCDIMENSIONCURVE",693772133:"IFCDEFINEDSYMBOL",2827736869:"IFCCURVEBOUNDEDPLANE",2601014836:"IFCCURVE",2147822146:"IFCCSGSOLID",2506170314:"IFCCSGPRIMITIVE3D",194851669:"IFCCRANERAILFSHAPEPROFILEDEF",4133800736:"IFCCRANERAILASHAPEPROFILEDEF",2485617015:"IFCCOMPOSITECURVESEGMENT",2205249479:"IFCCLOSEDSHELL",1383045692:"IFCCIRCLEPROFILEDEF",1416205885:"IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",3331915920:"IFCCARTESIANTRANSFORMATIONOPERATOR3D",3486308946:"IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",3749851601:"IFCCARTESIANTRANSFORMATIONOPERATOR2D",59481748:"IFCCARTESIANTRANSFORMATIONOPERATOR",1123145078:"IFCCARTESIANPOINT",2898889636:"IFCCSHAPEPROFILEDEF",2713105998:"IFCBOXEDHALFSPACE",2581212453:"IFCBOUNDINGBOX",4182860854:"IFCBOUNDEDSURFACE",2736907675:"IFCBOOLEANRESULT",2740243338:"IFCAXIS2PLACEMENT3D",3125803723:"IFCAXIS2PLACEMENT2D",4261334040:"IFCAXIS1PLACEMENT",1302238472:"IFCANNOTATIONSURFACE",2265737646:"IFCANNOTATIONFILLAREAOCCURRENCE",669184980:"IFCANNOTATIONFILLAREA",3288037868:"IFCANNOTATIONCURVEOCCURRENCE",2543172580:"IFCZSHAPEPROFILEDEF",1299126871:"IFCWINDOWSTYLE",512836454:"IFCWINDOWPANELPROPERTIES",336235671:"IFCWINDOWLININGPROPERTIES",2759199220:"IFCVERTEXLOOP",1417489154:"IFCVECTOR",427810014:"IFCUSHAPEPROFILEDEF",2347495698:"IFCTYPEPRODUCT",1628702193:"IFCTYPEOBJECT",1345879162:"IFCTWODIRECTIONREPEATFACTOR",2715220739:"IFCTRAPEZIUMPROFILEDEF",3124975700:"IFCTEXTLITERALWITHEXTENT",4282788508:"IFCTEXTLITERAL",3028897424:"IFCTERMINATORSYMBOL",3071757647:"IFCTSHAPEPROFILEDEF",230924584:"IFCSWEPTSURFACE",1260650574:"IFCSWEPTDISKSOLID",2247615214:"IFCSWEPTAREASOLID",1878645084:"IFCSURFACESTYLERENDERING",2513912981:"IFCSURFACE",2233826070:"IFCSUBEDGE",3653947884:"IFCSTRUCTURALSTEELPROFILEPROPERTIES",3843319758:"IFCSTRUCTURALPROFILEPROPERTIES",1190533807:"IFCSTRUCTURALLOADSINGLEFORCEWARPING",1597423693:"IFCSTRUCTURALLOADSINGLEFORCE",1973038258:"IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",2473145415:"IFCSTRUCTURALLOADSINGLEDISPLACEMENT",2668620305:"IFCSTRUCTURALLOADPLANARFORCE",1595516126:"IFCSTRUCTURALLOADLINEARFORCE",390701378:"IFCSPACETHERMALLOADPROPERTIES",1202362311:"IFCSOUNDVALUE",2485662743:"IFCSOUNDPROPERTIES",723233188:"IFCSOLIDMODEL",2609359061:"IFCSLIPPAGECONNECTIONCONDITION",4124623270:"IFCSHELLBASEDSURFACEMODEL",2411513650:"IFCSERVICELIFEFACTOR",1509187699:"IFCSECTIONEDSPINE",2778083089:"IFCROUNDEDRECTANGLEPROFILEDEF",478536968:"IFCRELATIONSHIP",3765753017:"IFCREINFORCEMENTDEFINITIONPROPERTIES",3413951693:"IFCREGULARTIMESERIES",3615266464:"IFCRECTANGLEPROFILEDEF",110355661:"IFCPROPERTYTABLEVALUE",3650150729:"IFCPROPERTYSINGLEVALUE",3357820518:"IFCPROPERTYSETDEFINITION",941946838:"IFCPROPERTYREFERENCEVALUE",2752243245:"IFCPROPERTYLISTVALUE",4166981789:"IFCPROPERTYENUMERATEDVALUE",1680319473:"IFCPROPERTYDEFINITION",871118103:"IFCPROPERTYBOUNDEDVALUE",673634403:"IFCPRODUCTDEFINITIONSHAPE",179317114:"IFCPREDEFINEDPOINTMARKERSYMBOL",433424934:"IFCPREDEFINEDDIMENSIONSYMBOL",2559016684:"IFCPREDEFINEDCURVEFONT",759155922:"IFCPREDEFINEDCOLOUR",2775532180:"IFCPOLYGONALBOUNDEDHALFSPACE",2924175390:"IFCPOLYLOOP",1423911732:"IFCPOINTONSURFACE",4022376103:"IFCPOINTONCURVE",2067069095:"IFCPOINT",1663979128:"IFCPLANAREXTENT",2004835150:"IFCPLACEMENT",597895409:"IFCPIXELTEXTURE",3021840470:"IFCPHYSICALCOMPLEXQUANTITY",2519244187:"IFCPATH",2529465313:"IFCPARAMETERIZEDPROFILEDEF",1029017970:"IFCORIENTEDEDGE",2665983363:"IFCOPENSHELL",2833995503:"IFCONEDIRECTIONREPEATFACTOR",219451334:"IFCOBJECTDEFINITION",1430189142:"IFCMECHANICALCONCRETEMATERIALPROPERTIES",2022407955:"IFCMATERIALDEFINITIONREPRESENTATION",2347385850:"IFCMAPPEDITEM",1008929658:"IFCLOOP",2624227202:"IFCLOCALPLACEMENT",3422422726:"IFCLIGHTSOURCESPOT",1520743889:"IFCLIGHTSOURCEPOSITIONAL",4266656042:"IFCLIGHTSOURCEGONIOMETRIC",2604431987:"IFCLIGHTSOURCEDIRECTIONAL",125510826:"IFCLIGHTSOURCEAMBIENT",1402838566:"IFCLIGHTSOURCE",3741457305:"IFCIRREGULARTIMESERIES",3905492369:"IFCIMAGETEXTURE",2445078500:"IFCHYGROSCOPICMATERIALPROPERTIES",812098782:"IFCHALFSPACESOLID",178086475:"IFCGRIDPLACEMENT",3590301190:"IFCGEOMETRICSET",4142052618:"IFCGEOMETRICREPRESENTATIONSUBCONTEXT",2453401579:"IFCGEOMETRICREPRESENTATIONITEM",3448662350:"IFCGEOMETRICREPRESENTATIONCONTEXT",1446786286:"IFCGENERALPROFILEPROPERTIES",803998398:"IFCGENERALMATERIALPROPERTIES",3857492461:"IFCFUELPROPERTIES",738692330:"IFCFILLAREASTYLE",4219587988:"IFCFAILURECONNECTIONCONDITION",3008276851:"IFCFACESURFACE",803316827:"IFCFACEOUTERBOUND",1809719519:"IFCFACEBOUND",2556980723:"IFCFACE",1860660968:"IFCEXTENDEDMATERIALPROPERTIES",476780140:"IFCEDGECURVE",3900360178:"IFCEDGE",4170525392:"IFCDRAUGHTINGPREDEFINEDTEXTFONT",3732053477:"IFCDOCUMENTREFERENCE",1694125774:"IFCDIMENSIONPAIR",2273265877:"IFCDIMENSIONCALLOUTRELATIONSHIP",3632507154:"IFCDERIVEDPROFILEDEF",3800577675:"IFCCURVESTYLE",2889183280:"IFCCONVERSIONBASEDUNIT",3050246964:"IFCCONTEXTDEPENDENTUNIT",45288368:"IFCCONNECTIONPOINTECCENTRICITY",1981873012:"IFCCONNECTIONCURVEGEOMETRY",370225590:"IFCCONNECTEDFACESET",1485152156:"IFCCOMPOSITEPROFILEDEF",2542286263:"IFCCOMPLEXPROPERTY",776857604:"IFCCOLOURRGB",647927063:"IFCCLASSIFICATIONREFERENCE",3150382593:"IFCCENTERLINEPROFILEDEF",616511568:"IFCBLOBTEXTURE",2705031697:"IFCARBITRARYPROFILEDEFWITHVOIDS",1310608509:"IFCARBITRARYOPENPROFILEDEF",3798115385:"IFCARBITRARYCLOSEDPROFILEDEF",2297822566:"IFCANNOTATIONTEXTOCCURRENCE",3612888222:"IFCANNOTATIONSYMBOLOCCURRENCE",962685235:"IFCANNOTATIONSURFACEOCCURRENCE",2442683028:"IFCANNOTATIONOCCURRENCE",1065908215:"IFCWATERPROPERTIES",891718957:"IFCVIRTUALGRIDINTERSECTION",1907098498:"IFCVERTEXPOINT",3304826586:"IFCVERTEXBASEDTEXTUREMAP",2799835756:"IFCVERTEX",180925521:"IFCUNITASSIGNMENT",1735638870:"IFCTOPOLOGYREPRESENTATION",1377556343:"IFCTOPOLOGICALREPRESENTATIONITEM",581633288:"IFCTIMESERIESVALUE",1718945513:"IFCTIMESERIESREFERENCERELATIONSHIP",3101149627:"IFCTIMESERIES",3317419933:"IFCTHERMALMATERIALPROPERTIES",1210645708:"IFCTEXTUREVERTEX",2552916305:"IFCTEXTUREMAP",1742049831:"IFCTEXTURECOORDINATEGENERATOR",280115917:"IFCTEXTURECOORDINATE",1484833681:"IFCTEXTSTYLEWITHBOXCHARACTERISTICS",1640371178:"IFCTEXTSTYLETEXTMODEL",2636378356:"IFCTEXTSTYLEFORDEFINEDFONT",1983826977:"IFCTEXTSTYLEFONTMODEL",1447204868:"IFCTEXTSTYLE",912023232:"IFCTELECOMADDRESS",531007025:"IFCTABLEROW",985171141:"IFCTABLE",1290481447:"IFCSYMBOLSTYLE",626085974:"IFCSURFACETEXTURE",1351298697:"IFCSURFACESTYLEWITHTEXTURES",846575682:"IFCSURFACESTYLESHADING",1607154358:"IFCSURFACESTYLEREFRACTION",3303107099:"IFCSURFACESTYLELIGHTING",1300840506:"IFCSURFACESTYLE",3049322572:"IFCSTYLEDREPRESENTATION",3958052878:"IFCSTYLEDITEM",2830218821:"IFCSTYLEMODEL",3408363356:"IFCSTRUCTURALLOADTEMPERATURE",2525727697:"IFCSTRUCTURALLOADSTATIC",2162789131:"IFCSTRUCTURALLOAD",2273995522:"IFCSTRUCTURALCONNECTIONCONDITION",3692461612:"IFCSIMPLEPROPERTY",4240577450:"IFCSHAPEREPRESENTATION",3982875396:"IFCSHAPEMODEL",867548509:"IFCSHAPEASPECT",4165799628:"IFCSECTIONREINFORCEMENTPROPERTIES",2042790032:"IFCSECTIONPROPERTIES",448429030:"IFCSIUNIT",2341007311:"IFCROOT",3679540991:"IFCRIBPLATEPROFILEPROPERTIES",1660063152:"IFCREPRESENTATIONMAP",3008791417:"IFCREPRESENTATIONITEM",3377609919:"IFCREPRESENTATIONCONTEXT",1076942058:"IFCREPRESENTATION",1222501353:"IFCRELAXATION",1580146022:"IFCREINFORCEMENTBARPROPERTIES",2692823254:"IFCREFERENCESVALUEDOCUMENT",825690147:"IFCQUANTITYWEIGHT",2405470396:"IFCQUANTITYVOLUME",3252649465:"IFCQUANTITYTIME",931644368:"IFCQUANTITYLENGTH",2093928680:"IFCQUANTITYCOUNT",2044713172:"IFCQUANTITYAREA",3710013099:"IFCPROPERTYENUMERATION",148025276:"IFCPROPERTYDEPENDENCYRELATIONSHIP",3896028662:"IFCPROPERTYCONSTRAINTRELATIONSHIP",2598011224:"IFCPROPERTY",2802850158:"IFCPROFILEPROPERTIES",3958567839:"IFCPROFILEDEF",2267347899:"IFCPRODUCTSOFCOMBUSTIONPROPERTIES",2095639259:"IFCPRODUCTREPRESENTATION",2417041796:"IFCPRESENTATIONSTYLEASSIGNMENT",3119450353:"IFCPRESENTATIONSTYLE",1304840413:"IFCPRESENTATIONLAYERWITHSTYLE",2022622350:"IFCPRESENTATIONLAYERASSIGNMENT",1775413392:"IFCPREDEFINEDTEXTFONT",3213052703:"IFCPREDEFINEDTERMINATORSYMBOL",990879717:"IFCPREDEFINEDSYMBOL",3727388367:"IFCPREDEFINEDITEM",3355820592:"IFCPOSTALADDRESS",2226359599:"IFCPHYSICALSIMPLEQUANTITY",2483315170:"IFCPHYSICALQUANTITY",101040310:"IFCPERSONANDORGANIZATION",2077209135:"IFCPERSON",1207048766:"IFCOWNERHISTORY",1411181986:"IFCORGANIZATIONRELATIONSHIP",4251960020:"IFCORGANIZATION",1227763645:"IFCOPTICALMATERIALPROPERTIES",2251480897:"IFCOBJECTIVE",3701648758:"IFCOBJECTPLACEMENT",1918398963:"IFCNAMEDUNIT",2706619895:"IFCMONETARYUNIT",3368373690:"IFCMETRIC",677618848:"IFCMECHANICALSTEELMATERIALPROPERTIES",4256014907:"IFCMECHANICALMATERIALPROPERTIES",2597039031:"IFCMEASUREWITHUNIT",3265635763:"IFCMATERIALPROPERTIES",2199411900:"IFCMATERIALLIST",1303795690:"IFCMATERIALLAYERSETUSAGE",3303938423:"IFCMATERIALLAYERSET",248100487:"IFCMATERIALLAYER",1847130766:"IFCMATERIALCLASSIFICATIONRELATIONSHIP",1838606355:"IFCMATERIAL",30780891:"IFCLOCALTIME",1566485204:"IFCLIGHTINTENSITYDISTRIBUTION",4162380809:"IFCLIGHTDISTRIBUTIONDATA",3452421091:"IFCLIBRARYREFERENCE",2655187982:"IFCLIBRARYINFORMATION",3020489413:"IFCIRREGULARTIMESERIESVALUE",852622518:"IFCGRIDAXIS",3548104201:"IFCEXTERNALLYDEFINEDTEXTFONT",3207319532:"IFCEXTERNALLYDEFINEDSYMBOL",1040185647:"IFCEXTERNALLYDEFINEDSURFACESTYLE",2242383968:"IFCEXTERNALLYDEFINEDHATCHSTYLE",3200245327:"IFCEXTERNALREFERENCE",1648886627:"IFCENVIRONMENTALIMPACTVALUE",3796139169:"IFCDRAUGHTINGCALLOUTRELATIONSHIP",770865208:"IFCDOCUMENTINFORMATIONRELATIONSHIP",1154170062:"IFCDOCUMENTINFORMATION",1376555844:"IFCDOCUMENTELECTRONICFORMAT",2949456006:"IFCDIMENSIONALEXPONENTS",1045800335:"IFCDERIVEDUNITELEMENT",1765591967:"IFCDERIVEDUNIT",1072939445:"IFCDATEANDTIME",3510044353:"IFCCURVESTYLEFONTPATTERN",2367409068:"IFCCURVESTYLEFONTANDSCALING",1105321065:"IFCCURVESTYLEFONT",539742890:"IFCCURRENCYRELATIONSHIP",602808272:"IFCCOSTVALUE",1065062679:"IFCCOORDINATEDUNIVERSALTIMEOFFSET",347226245:"IFCCONSTRAINTRELATIONSHIP",613356794:"IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP",1658513725:"IFCCONSTRAINTAGGREGATIONRELATIONSHIP",1959218052:"IFCCONSTRAINT",2732653382:"IFCCONNECTIONSURFACEGEOMETRY",4257277454:"IFCCONNECTIONPORTGEOMETRY",2614616156:"IFCCONNECTIONPOINTGEOMETRY",2859738748:"IFCCONNECTIONGEOMETRY",3264961684:"IFCCOLOURSPECIFICATION",3639012971:"IFCCLASSIFICATIONNOTATIONFACET",938368621:"IFCCLASSIFICATIONNOTATION",1098599126:"IFCCLASSIFICATIONITEMRELATIONSHIP",1767535486:"IFCCLASSIFICATIONITEM",747523909:"IFCCLASSIFICATION",622194075:"IFCCALENDARDATE",2069777674:"IFCBOUNDARYNODECONDITIONWARPING",1387855156:"IFCBOUNDARYNODECONDITION",3367102660:"IFCBOUNDARYFACECONDITION",1560379544:"IFCBOUNDARYEDGECONDITION",4037036970:"IFCBOUNDARYCONDITION",3869604511:"IFCAPPROVALRELATIONSHIP",390851274:"IFCAPPROVALPROPERTYRELATIONSHIP",2080292479:"IFCAPPROVALACTORRELATIONSHIP",130549933:"IFCAPPROVAL",1110488051:"IFCAPPLIEDVALUERELATIONSHIP",411424972:"IFCAPPLIEDVALUE",639542469:"IFCAPPLICATION",618182010:"IFCADDRESS",3630933823:"IFCACTORROLE",599546466:"FILE_DESCRIPTION",1390159747:"FILE_NAME",1109904537:"FILE_SCHEMA"};class kt{constructor(){c(this,"enabled",!0),c(this,"trigger",t=>{if(!this.enabled)return;const e=this.handlers.slice(0);for(const s of e)s(t)}),c(this,"handlers",[])}add(t){this.handlers.push(t)}remove(t){this.handlers=this.handlers.filter(e=>e!==t)}reset(){this.handlers.length=0}}class ca extends Map{constructor(t){super(t),c(this,"onItemSet",new kt),c(this,"onItemUpdated",new kt),c(this,"onItemDeleted",new kt),c(this,"onBeforeDelete",new kt),c(this,"onCleared",new kt),c(this,"guard",()=>!0)}set eventsEnabled(t){this.onItemSet.enabled=t,this.onItemUpdated.enabled=t,this.onItemDeleted.enabled=t,this.onBeforeDelete.enabled=t,this.onCleared.enabled=t}clear(){for(const[t,e]of this)this.onBeforeDelete.trigger({key:t,value:e});super.clear(),this.onCleared.trigger()}set(t,e){const s=this.has(t);if(!(this.guard??(()=>!0))(t,e))return this;const i=super.set(t,e);return s?(this.onItemUpdated||(this.onItemUpdated=new kt),this.onItemUpdated.trigger({key:t,value:e})):(this.onItemSet||(this.onItemSet=new kt),this.onItemSet.trigger({key:t,value:e})),i}delete(t){const e=this.get(t);if(!e)return!1;this.onBeforeDelete.trigger({key:t,value:e});const s=super.delete(t);return s&&this.onItemDeleted.trigger(t),s}getKey(t){for(const[e,s]of this)if(s===t)return e}update(t){const e=this.getKey(t);e&&this.set(e,t)}deleteIf(t){for(const[e,s]of this)t(s,e)&&this.delete(e)}replaceKey(t,e,s=!1){const i=this.get(t);return i?!(this.get(e)&&!s)&&(this.eventsEnabled=!1,this.delete(t),this.eventsEnabled=!0,this.set(e,i),!0):!1}dispose(){this.clear(),this.onItemSet.reset(),this.onItemDeleted.reset(),this.onItemUpdated.reset(),this.onCleared.reset(),this.onBeforeDelete.reset()}}class Fa extends Set{constructor(t){super(t),c(this,"onUpdated",new kt),c(this,"onItemAdded",new kt),c(this,"onBeforeDelete",new kt),c(this,"onItemDeleted",new kt),c(this,"onCleared",new kt),c(this,"guard",()=>!0)}set eventsEnabled(t){this.onUpdated.enabled=t,this.onItemAdded.enabled=t,this.onItemDeleted.enabled=t,this.onBeforeDelete.enabled=t,this.onCleared.enabled=t}clear(){for(const t of this)this.onBeforeDelete.trigger(t);super.clear(),this.onCleared.trigger(),this.onUpdated.trigger()}add(...t){for(const e of t)this.has(e)||(this.guard??(()=>!0))(e)&&(super.add(e),this.onItemAdded||(this.onItemAdded=new kt),this.onItemAdded.trigger(e));return this.onUpdated||(this.onUpdated=new kt),this.onUpdated.trigger(),this}delete(t){if(!this.has(t))return!1;this.onBeforeDelete.trigger(t);const e=super.delete(t);return e&&(this.onItemDeleted.trigger(),this.onUpdated.trigger()),e}deleteIf(t){for(const e of this)t(e)&&this.delete(e)}getIndex(t){let e=0;for(const s of this){if(s===t)return e;e++}return-1}dispose(){this.clear(),this.onItemAdded.reset(),this.onItemDeleted.reset(),this.onCleared.reset(),this.onBeforeDelete.reset(),this.onUpdated.reset()}}const fs=new Int32Array(2),Sa=new Float32Array(fs.buffer),ya=new Float64Array(fs.buffer),pn=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1;var Yr,bn;(bn=Yr||(Yr={}))[bn.UTF8_BYTES=1]="UTF8_BYTES",bn[bn.UTF16_STRING=2]="UTF16_STRING";class Xn{constructor(t){this.bytes_=t,this.position_=0,this.text_decoder_=new TextDecoder}static allocate(t){return new Xn(new Uint8Array(t))}clear(){this.position_=0}bytes(){return this.bytes_}position(){return this.position_}setPosition(t){this.position_=t}capacity(){return this.bytes_.length}readInt8(t){return this.readUint8(t)<<24>>24}readUint8(t){return this.bytes_[t]}readInt16(t){return this.readUint16(t)<<16>>16}readUint16(t){return this.bytes_[t]|this.bytes_[t+1]<<8}readInt32(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24}readUint32(t){return this.readInt32(t)>>>0}readInt64(t){return BigInt.asIntN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readUint64(t){return BigInt.asUintN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readFloat32(t){return fs[0]=this.readInt32(t),Sa[0]}readFloat64(t){return fs[pn?0:1]=this.readInt32(t),fs[pn?1:0]=this.readInt32(t+4),ya[0]}writeInt8(t,e){this.bytes_[t]=e}writeUint8(t,e){this.bytes_[t]=e}writeInt16(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8}writeUint16(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8}writeInt32(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24}writeUint32(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24}writeInt64(t,e){this.writeInt32(t,Number(BigInt.asIntN(32,e))),this.writeInt32(t+4,Number(BigInt.asIntN(32,e>>BigInt(32))))}writeUint64(t,e){this.writeUint32(t,Number(BigInt.asUintN(32,e))),this.writeUint32(t+4,Number(BigInt.asUintN(32,e>>BigInt(32))))}writeFloat32(t,e){Sa[0]=e,this.writeInt32(t,fs[0])}writeFloat64(t,e){ya[0]=e,this.writeInt32(t,fs[pn?0:1]),this.writeInt32(t+4,fs[pn?1:0])}getBufferIdentifier(){if(this.bytes_.length<this.position_+4+4)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");let t="";for(let e=0;e<4;e++)t+=String.fromCharCode(this.readInt8(this.position_+4+e));return t}__offset(t,e){const s=t-this.readInt32(t);return e<this.readInt16(s)?this.readInt16(s+e):0}__union(t,e){return t.bb_pos=e+this.readInt32(e),t.bb=this,t}__string(t,e){t+=this.readInt32(t);const s=this.readInt32(t);t+=4;const i=this.bytes_.subarray(t,t+s);return e===Yr.UTF8_BYTES?i:this.text_decoder_.decode(i)}__union_with_string(t,e){return typeof t=="string"?this.__string(e):this.__union(t,e)}__indirect(t){return t+this.readInt32(t)}__vector(t){return t+this.readInt32(t)+4}__vector_len(t){return this.readInt32(t+this.readInt32(t))}__has_identifier(t){if(t.length!=4)throw new Error("FlatBuffers: file identifier must be length 4");for(let e=0;e<4;e++)if(t.charCodeAt(e)!=this.readInt8(this.position()+4+e))return!1;return!0}createScalarList(t,e){const s=[];for(let i=0;i<e;++i){const r=t(i);r!==null&&s.push(r)}return s}createObjList(t,e){const s=[];for(let i=0;i<e;++i){const r=t(i);r!==null&&s.push(r.unpack())}return s}}class da{constructor(t){let e;this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null,this.text_encoder=new TextEncoder,e=t||1024,this.bb=Xn.allocate(e),this.space=e}clear(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null}forceDefaults(t){this.force_defaults=t}dataBuffer(){return this.bb}asUint8Array(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())}prep(t,e){t>this.minalign&&(this.minalign=t);const s=1+~(this.bb.capacity()-this.space+e)&t-1;for(;this.space<s+t+e;){const i=this.bb.capacity();this.bb=da.growByteBuffer(this.bb),this.space+=this.bb.capacity()-i}this.pad(s)}pad(t){for(let e=0;e<t;e++)this.bb.writeInt8(--this.space,0)}writeInt8(t){this.bb.writeInt8(this.space-=1,t)}writeInt16(t){this.bb.writeInt16(this.space-=2,t)}writeInt32(t){this.bb.writeInt32(this.space-=4,t)}writeInt64(t){this.bb.writeInt64(this.space-=8,t)}writeFloat32(t){this.bb.writeFloat32(this.space-=4,t)}writeFloat64(t){this.bb.writeFloat64(this.space-=8,t)}addInt8(t){this.prep(1,0),this.writeInt8(t)}addInt16(t){this.prep(2,0),this.writeInt16(t)}addInt32(t){this.prep(4,0),this.writeInt32(t)}addInt64(t){this.prep(8,0),this.writeInt64(t)}addFloat32(t){this.prep(4,0),this.writeFloat32(t)}addFloat64(t){this.prep(8,0),this.writeFloat64(t)}addFieldInt8(t,e,s){(this.force_defaults||e!=s)&&(this.addInt8(e),this.slot(t))}addFieldInt16(t,e,s){(this.force_defaults||e!=s)&&(this.addInt16(e),this.slot(t))}addFieldInt32(t,e,s){(this.force_defaults||e!=s)&&(this.addInt32(e),this.slot(t))}addFieldInt64(t,e,s){(this.force_defaults||e!==s)&&(this.addInt64(e),this.slot(t))}addFieldFloat32(t,e,s){(this.force_defaults||e!=s)&&(this.addFloat32(e),this.slot(t))}addFieldFloat64(t,e,s){(this.force_defaults||e!=s)&&(this.addFloat64(e),this.slot(t))}addFieldOffset(t,e,s){(this.force_defaults||e!=s)&&(this.addOffset(e),this.slot(t))}addFieldStruct(t,e,s){e!=s&&(this.nested(e),this.slot(t))}nested(t){if(t!=this.offset())throw new TypeError("FlatBuffers: struct must be serialized inline.")}notNested(){if(this.isNested)throw new TypeError("FlatBuffers: object serialization must not be nested.")}slot(t){this.vtable!==null&&(this.vtable[t]=this.offset())}offset(){return this.bb.capacity()-this.space}static growByteBuffer(t){const e=t.capacity();if(3221225472&e)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");const s=e<<1,i=Xn.allocate(s);return i.setPosition(s-e),i.bytes().set(t.bytes(),s-e),i}addOffset(t){this.prep(4,0),this.writeInt32(this.offset()-t+4)}startObject(t){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=t;for(let e=0;e<t;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()}endObject(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);const t=this.offset();let e=this.vtable_in_use-1;for(;e>=0&&this.vtable[e]==0;e--);const s=e+1;for(;e>=0;e--)this.addInt16(this.vtable[e]!=0?t-this.vtable[e]:0);this.addInt16(t-this.object_start);const i=2*(s+2);this.addInt16(i);let r=0;const a=this.space;t:for(e=0;e<this.vtables.length;e++){const o=this.bb.capacity()-this.vtables[e];if(i==this.bb.readInt16(o)){for(let h=2;h<i;h+=2)if(this.bb.readInt16(a+h)!=this.bb.readInt16(o+h))continue t;r=this.vtables[e];break}}return r?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,r-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t}finish(t,e,s){const i=s?4:0;if(e){const r=e;if(this.prep(this.minalign,8+i),r.length!=4)throw new TypeError("FlatBuffers: file identifier must be length 4");for(let a=3;a>=0;a--)this.writeInt8(r.charCodeAt(a))}this.prep(this.minalign,4+i),this.addOffset(t),i&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)}finishSizePrefixed(t,e){this.finish(t,e,!0)}requiredField(t,e){const s=this.bb.capacity()-t,i=s-this.bb.readInt32(s);if(!(e<this.bb.readInt16(i)&&this.bb.readInt16(i+e)!=0))throw new TypeError("FlatBuffers: field "+e+" must be set")}startVector(t,e,s){this.notNested(),this.vector_num_elems=e,this.prep(4,t*e),this.prep(s,t*e)}endVector(){return this.writeInt32(this.vector_num_elems),this.offset()}createSharedString(t){if(!t)return 0;if(this.string_maps||(this.string_maps=new Map),this.string_maps.has(t))return this.string_maps.get(t);const e=this.createString(t);return this.string_maps.set(t,e),e}createString(t){if(t==null)return 0;let e;return e=t instanceof Uint8Array?t:this.text_encoder.encode(t),this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length),this.bb.bytes().set(e,this.space),this.endVector()}createByteVector(t){return t==null?0:(this.startVector(1,t.length,1),this.bb.setPosition(this.space-=t.length),this.bb.bytes().set(t,this.space),this.endVector())}createObjectOffset(t){return t===null?0:typeof t=="string"?this.createString(t):t.pack(this)}createObjectOffsetList(t){const e=[];for(let s=0;s<t.length;++s){const i=t[s];if(i===null)throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");e.push(this.createObjectOffset(i))}return e}createStructOffsetList(t,e){return e(this,t.length),this.createObjectOffsetList(t.slice().reverse()),this.endVector()}}class re{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAlignment(t,e){return(e||new re).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAlignment(t,e){return t.setPosition(t.position()+4),(e||new re).__init(t.readInt32(t.position())+t.position(),t)}absolute(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}absoluteLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}absoluteArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}horizontal(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}vertical(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}verticalLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}verticalArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startAlignment(t){t.startObject(3)}static addAbsolute(t,e){t.addFieldOffset(0,e,0)}static createAbsoluteVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startAbsoluteVector(t,e){t.startVector(4,e,4)}static addHorizontal(t,e){t.addFieldOffset(1,e,0)}static createHorizontalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startHorizontalVector(t,e){t.startVector(4,e,4)}static addVertical(t,e){t.addFieldOffset(2,e,0)}static createVerticalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startVerticalVector(t,e){t.startVector(4,e,4)}static endAlignment(t){return t.endObject()}static createAlignment(t,e,s,i){return re.startAlignment(t),re.addAbsolute(t,e),re.addHorizontal(t,s),re.addVertical(t,i),re.endAlignment(t)}}class ss{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAttribute(t,e){return(e||new ss).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAttribute(t,e){return t.setPosition(t.position()+4),(e||new ss).__init(t.readInt32(t.position())+t.position(),t)}data(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}dataLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startAttribute(t){t.startObject(1)}static addData(t,e){t.addFieldOffset(0,e,0)}static createDataVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startDataVector(t,e){t.startVector(4,e,4)}static endAttribute(t){const e=t.endObject();return t.requiredField(e,4),e}static createAttribute(t,e){return ss.startAttribute(t),ss.addData(t,e),ss.endAttribute(t)}}class xt{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}x(){return this.bb.readFloat32(this.bb_pos)}mutate_x(t){return this.bb.writeFloat32(this.bb_pos+0,t),!0}y(){return this.bb.readFloat32(this.bb_pos+4)}mutate_y(t){return this.bb.writeFloat32(this.bb_pos+4,t),!0}z(){return this.bb.readFloat32(this.bb_pos+8)}mutate_z(t){return this.bb.writeFloat32(this.bb_pos+8,t),!0}static sizeOf(){return 12}static createFloatVector(t,e,s,i){return t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class sr{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}aperture(){return this.bb.readFloat32(this.bb_pos)}mutate_aperture(t){return this.bb.writeFloat32(this.bb_pos+0,t),!0}position(t){return(t||new xt).__init(this.bb_pos+4,this.bb)}radius(){return this.bb.readFloat32(this.bb_pos+16)}mutate_radius(t){return this.bb.writeFloat32(this.bb_pos+16,t),!0}xDirection(t){return(t||new xt).__init(this.bb_pos+20,this.bb)}yDirection(t){return(t||new xt).__init(this.bb_pos+32,this.bb)}static sizeOf(){return 44}static createCircleCurve(t,e,s,i,r,a,o,h,l,d,u,p){return t.prep(4,44),t.prep(4,12),t.writeFloat32(p),t.writeFloat32(u),t.writeFloat32(d),t.prep(4,12),t.writeFloat32(l),t.writeFloat32(h),t.writeFloat32(o),t.writeFloat32(a),t.prep(4,12),t.writeFloat32(r),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class ua{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}p1(t){return(t||new xt).__init(this.bb_pos,this.bb)}p2(t){return(t||new xt).__init(this.bb_pos+12,this.bb)}static sizeOf(){return 24}static createWire(t,e,s,i,r,a,o){return t.prep(4,24),t.prep(4,12),t.writeFloat32(o),t.writeFloat32(a),t.writeFloat32(r),t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class is{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsWireSet(t,e){return(e||new is).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsWireSet(t,e){return t.setPosition(t.position()+4),(e||new is).__init(t.readInt32(t.position())+t.position(),t)}ps(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new xt).__init(this.bb.__vector(this.bb_pos+s)+12*t,this.bb):null}psLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startWireSet(t){t.startObject(1)}static addPs(t,e){t.addFieldOffset(0,e,0)}static startPsVector(t,e){t.startVector(12,e,4)}static endWireSet(t){return t.endObject()}static createWireSet(t,e){return is.startWireSet(t),is.addPs(t,e),is.endWireSet(t)}}class it{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAxis(t,e){return(e||new it).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAxis(t,e){return t.setPosition(t.position()+4),(e||new it).__init(t.readInt32(t.position())+t.position(),t)}wires(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new ua).__init(this.bb.__vector(this.bb_pos+s)+24*t,this.bb):null}wiresLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}order(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}orderLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}orderArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}parts(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt8(this.bb.__vector(this.bb_pos+e)+t):0}partsLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}partsArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Int8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}wireSets(t,e){const s=this.bb.__offset(this.bb_pos,10);return s?(e||new is).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}wireSetsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}circleCurves(t,e){const s=this.bb.__offset(this.bb_pos,12);return s?(e||new sr).__init(this.bb.__vector(this.bb_pos+s)+44*t,this.bb):null}circleCurvesLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}static startAxis(t){t.startObject(5)}static addWires(t,e){t.addFieldOffset(0,e,0)}static startWiresVector(t,e){t.startVector(24,e,4)}static addOrder(t,e){t.addFieldOffset(1,e,0)}static createOrderVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startOrderVector(t,e){t.startVector(4,e,4)}static addParts(t,e){t.addFieldOffset(2,e,0)}static createPartsVector(t,e){t.startVector(1,e.length,1);for(let s=e.length-1;s>=0;s--)t.addInt8(e[s]);return t.endVector()}static startPartsVector(t,e){t.startVector(1,e,1)}static addWireSets(t,e){t.addFieldOffset(3,e,0)}static createWireSetsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startWireSetsVector(t,e){t.startVector(4,e,4)}static addCircleCurves(t,e){t.addFieldOffset(4,e,0)}static startCircleCurvesVector(t,e){t.startVector(44,e,4)}static endAxis(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,10),t.requiredField(e,12),e}static createAxis(t,e,s,i,r,a){return it.startAxis(t),it.addWires(t,e),it.addOrder(t,s),it.addParts(t,i),it.addWireSets(t,r),it.addCircleCurves(t,a),it.endAxis(t)}}var bt=(n=>(n[n.NONE=0]="NONE",n[n.WIRE=1]="WIRE",n[n.WIRE_SET=2]="WIRE_SET",n[n.CIRCLE_CURVE=3]="CIRCLE_CURVE",n))(bt||{});class ae{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsBigShellHole(t,e){return(e||new ae).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsBigShellHole(t,e){return t.setPosition(t.position()+4),(e||new ae).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}profileId(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint16(this.bb_pos+t):0}mutate_profile_id(t){const e=this.bb.__offset(this.bb_pos,6);return e!==0&&(this.bb.writeUint16(this.bb_pos+e,t),!0)}static startBigShellHole(t){t.startObject(2)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(4,e,4)}static addProfileId(t,e){t.addFieldInt16(1,e,0)}static endBigShellHole(t){const e=t.endObject();return t.requiredField(e,4),e}static createBigShellHole(t,e,s){return ae.startBigShellHole(t),ae.addIndices(t,e),ae.addProfileId(t,s),ae.endBigShellHole(t)}}class he{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsBigShellProfile(t,e){return(e||new he).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsBigShellProfile(t,e){return t.setPosition(t.position()+4),(e||new he).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startBigShellProfile(t){t.startObject(1)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(4,e,4)}static endBigShellProfile(t){const e=t.endObject();return t.requiredField(e,4),e}static createBigShellProfile(t,e){return he.startBigShellProfile(t),he.addIndices(t,e),he.endBigShellProfile(t)}}class Fo{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}min(t){return(t||new xt).__init(this.bb_pos,this.bb)}max(t){return(t||new xt).__init(this.bb_pos+12,this.bb)}static sizeOf(){return 24}static createBoundingBox(t,e,s,i,r,a,o){return t.prep(4,24),t.prep(4,12),t.writeFloat32(o),t.writeFloat32(a),t.writeFloat32(r),t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class yt{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCircleExtrusion(t,e){return(e||new yt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCircleExtrusion(t,e){return t.setPosition(t.position()+4),(e||new yt).__init(t.readInt32(t.position())+t.position(),t)}radius(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat64(this.bb.__vector(this.bb_pos+e)+8*t):0}radiusLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}radiusArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float64Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}axes(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new it).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}axesLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startCircleExtrusion(t){t.startObject(2)}static addRadius(t,e){t.addFieldOffset(0,e,0)}static createRadiusVector(t,e){t.startVector(8,e.length,8);for(let s=e.length-1;s>=0;s--)t.addFloat64(e[s]);return t.endVector()}static startRadiusVector(t,e){t.startVector(8,e,8)}static addAxes(t,e){t.addFieldOffset(1,e,0)}static createAxesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAxesVector(t,e){t.startVector(4,e,4)}static endCircleExtrusion(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),e}static createCircleExtrusion(t,e,s){return yt.startCircleExtrusion(t),yt.addRadius(t,e),yt.addAxes(t,s),yt.endCircleExtrusion(t)}}class So{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}x(){return this.bb.readFloat64(this.bb_pos)}mutate_x(t){return this.bb.writeFloat64(this.bb_pos+0,t),!0}y(){return this.bb.readFloat64(this.bb_pos+8)}mutate_y(t){return this.bb.writeFloat64(this.bb_pos+8,t),!0}z(){return this.bb.readFloat64(this.bb_pos+16)}mutate_z(t){return this.bb.writeFloat64(this.bb_pos+16,t),!0}static sizeOf(){return 24}static createDoubleVector(t,e,s,i){return t.prep(8,24),t.writeFloat64(i),t.writeFloat64(s),t.writeFloat64(e),t.offset()}}class Rt{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsGeometryLines(t,e){return(e||new Rt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsGeometryLines(t,e){return t.setPosition(t.position()+4),(e||new Rt).__init(t.readInt32(t.position())+t.position(),t)}points(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startGeometryLines(t){t.startObject(1)}static addPoints(t,e){t.addFieldOffset(0,e,0)}static createPointsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPointsVector(t,e){t.startVector(4,e,4)}static endGeometryLines(t){const e=t.endObject();return t.requiredField(e,4),e}static createGeometryLines(t,e){return Rt.startGeometryLines(t),Rt.addPoints(t,e),Rt.endGeometryLines(t)}}class Pn{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}id(){return this.bb.readUint32(this.bb_pos)}mutate_id(t){return this.bb.writeUint32(this.bb_pos+0,t),!0}geometryClass(){return this.bb.readInt8(this.bb_pos+4)}mutate_geometry_class(t){return this.bb.writeInt8(this.bb_pos+4,t),!0}static sizeOf(){return 8}static createGeometryRepresentation(t,e,s){return t.prep(4,8),t.pad(3),t.writeInt8(s),t.writeInt32(e),t.offset()}}class Mn{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}id(){return this.bb.readUint32(this.bb_pos)}mutate_id(t){return this.bb.writeUint32(this.bb_pos+0,t),!0}transform(){return this.bb.readUint32(this.bb_pos+4)}mutate_transform(t){return this.bb.writeUint32(this.bb_pos+4,t),!0}static sizeOf(){return 8}static createGeometrySample(t,e,s){return t.prep(4,8),t.writeInt32(s),t.writeInt32(e),t.offset()}}class eu{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}start(t){return(t||new xt).__init(this.bb_pos,this.bb)}end(t){return(t||new xt).__init(this.bb_pos+12,this.bb)}height(){return this.bb.readFloat32(this.bb_pos+24)}mutate_height(t){return this.bb.writeFloat32(this.bb_pos+24,t),!0}width(){return this.bb.readFloat32(this.bb_pos+28)}mutate_width(t){return this.bb.writeFloat32(this.bb_pos+28,t),!0}offset(){return this.bb.readFloat32(this.bb_pos+32)}mutate_offset(t){return this.bb.writeFloat32(this.bb_pos+32,t),!0}static sizeOf(){return 36}static createGeometryWall(t,e,s,i,r,a,o,h,l,d){return t.prep(4,36),t.writeFloat32(d),t.writeFloat32(l),t.writeFloat32(h),t.prep(4,12),t.writeFloat32(o),t.writeFloat32(a),t.writeFloat32(r),t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class rs{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}position(t){return(t||new So).__init(this.bb_pos,this.bb)}xDirection(t){return(t||new xt).__init(this.bb_pos+24,this.bb)}yDirection(t){return(t||new xt).__init(this.bb_pos+36,this.bb)}static sizeOf(){return 48}static createTransform(t,e,s,i,r,a,o,h,l,d){return t.prep(8,48),t.prep(4,12),t.writeFloat32(d),t.writeFloat32(l),t.writeFloat32(h),t.prep(4,12),t.writeFloat32(o),t.writeFloat32(a),t.writeFloat32(r),t.prep(8,24),t.writeFloat64(i),t.writeFloat64(s),t.writeFloat64(e),t.offset()}}class q{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsGeometries(t,e){return(e||new q).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsGeometries(t,e){return t.setPosition(t.position()+4),(e||new q).__init(t.readInt32(t.position())+t.position(),t)}samples(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new Mn).__init(this.bb.__vector(this.bb_pos+s)+8*t,this.bb):null}samplesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}sampleIds(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}sampleIdsLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}sampleIdsArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}representations(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new Pn).__init(this.bb.__vector(this.bb_pos+s)+8*t,this.bb):null}representationsLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}representationIds(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}representationIdsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}representationIdsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transforms(t,e){const s=this.bb.__offset(this.bb_pos,12);return s?(e||new rs).__init(this.bb.__vector(this.bb_pos+s)+48*t,this.bb):null}transformsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}transformIds(t){const e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}transformIdsLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}transformIdsArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}representationsSamples(t){const e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}representationsSamplesLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}representationsSamplesArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}lines(t,e){const s=this.bb.__offset(this.bb_pos,18);return s?(e||new Rt).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}linesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}walls(t,e){const s=this.bb.__offset(this.bb_pos,20);return s?(e||new eu).__init(this.bb.__vector(this.bb_pos+s)+36*t,this.bb):null}wallsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}static startGeometries(t){t.startObject(9)}static addSamples(t,e){t.addFieldOffset(0,e,0)}static startSamplesVector(t,e){t.startVector(8,e,4)}static addSampleIds(t,e){t.addFieldOffset(1,e,0)}static createSampleIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startSampleIdsVector(t,e){t.startVector(4,e,4)}static addRepresentations(t,e){t.addFieldOffset(2,e,0)}static startRepresentationsVector(t,e){t.startVector(8,e,4)}static addRepresentationIds(t,e){t.addFieldOffset(3,e,0)}static createRepresentationIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startRepresentationIdsVector(t,e){t.startVector(4,e,4)}static addTransforms(t,e){t.addFieldOffset(4,e,0)}static startTransformsVector(t,e){t.startVector(48,e,8)}static addTransformIds(t,e){t.addFieldOffset(5,e,0)}static createTransformIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startTransformIdsVector(t,e){t.startVector(4,e,4)}static addRepresentationsSamples(t,e){t.addFieldOffset(6,e,0)}static createRepresentationsSamplesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startRepresentationsSamplesVector(t,e){t.startVector(4,e,4)}static addLines(t,e){t.addFieldOffset(7,e,0)}static createLinesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startLinesVector(t,e){t.startVector(4,e,4)}static addWalls(t,e){t.addFieldOffset(8,e,0)}static startWallsVector(t,e){t.startVector(36,e,4)}static endGeometries(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,8),t.requiredField(e,12),t.requiredField(e,18),e}static createGeometries(t,e,s,i,r,a,o,h,l,d){return q.startGeometries(t),q.addSamples(t,e),q.addSampleIds(t,s),q.addRepresentations(t,i),q.addRepresentationIds(t,r),q.addTransforms(t,a),q.addTransformIds(t,o),q.addRepresentationsSamples(t,h),q.addLines(t,l),q.addWalls(t,d),q.endGeometries(t)}}var ke=(n=>(n[n.NONE=0]="NONE",n[n.LINES=1]="LINES",n[n.ELLIPSE_ARC=2]="ELLIPSE_ARC",n[n.CLOTHOID=3]="CLOTHOID",n[n.PARABOLA=4]="PARABOLA",n[n.WALLS=5]="WALLS",n))(ke||{});class yo{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}r(){return this.bb.readUint8(this.bb_pos)}mutate_r(t){return this.bb.writeUint8(this.bb_pos+0,t),!0}g(){return this.bb.readUint8(this.bb_pos+1)}mutate_g(t){return this.bb.writeUint8(this.bb_pos+1,t),!0}b(){return this.bb.readUint8(this.bb_pos+2)}mutate_b(t){return this.bb.writeUint8(this.bb_pos+2,t),!0}a(){return this.bb.readUint8(this.bb_pos+3)}mutate_a(t){return this.bb.writeUint8(this.bb_pos+3,t),!0}renderedFaces(){return this.bb.readInt8(this.bb_pos+4)}mutate_rendered_faces(t){return this.bb.writeInt8(this.bb_pos+4,t),!0}stroke(){return this.bb.readInt8(this.bb_pos+5)}mutate_stroke(t){return this.bb.writeInt8(this.bb_pos+5,t),!0}static sizeOf(){return 6}static createMaterial(t,e,s,i,r,a,o){return t.prep(1,6),t.writeInt8(o),t.writeInt8(a),t.writeInt8(r),t.writeInt8(i),t.writeInt8(s),t.writeInt8(e),t.offset()}}class ir{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}id(){return this.bb.readUint32(this.bb_pos)}mutate_id(t){return this.bb.writeUint32(this.bb_pos+0,t),!0}bbox(t){return(t||new Fo).__init(this.bb_pos+4,this.bb)}representationClass(){return this.bb.readInt8(this.bb_pos+28)}mutate_representation_class(t){return this.bb.writeInt8(this.bb_pos+28,t),!0}static sizeOf(){return 32}static createRepresentation(t,e,s,i,r,a,o,h,l){return t.prep(4,32),t.pad(3),t.writeInt8(l),t.prep(4,24),t.prep(4,12),t.writeFloat32(h),t.writeFloat32(o),t.writeFloat32(a),t.prep(4,12),t.writeFloat32(r),t.writeFloat32(i),t.writeFloat32(s),t.writeInt32(e),t.offset()}}class nr{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}item(){return this.bb.readUint32(this.bb_pos)}mutate_item(t){return this.bb.writeUint32(this.bb_pos+0,t),!0}material(){return this.bb.readUint32(this.bb_pos+4)}mutate_material(t){return this.bb.writeUint32(this.bb_pos+4,t),!0}representation(){return this.bb.readUint32(this.bb_pos+8)}mutate_representation(t){return this.bb.writeUint32(this.bb_pos+8,t),!0}localTransform(){return this.bb.readUint32(this.bb_pos+12)}mutate_local_transform(t){return this.bb.writeUint32(this.bb_pos+12,t),!0}static sizeOf(){return 16}static createSample(t,e,s,i,r){return t.prep(4,16),t.writeInt32(r),t.writeInt32(i),t.writeInt32(s),t.writeInt32(e),t.offset()}}class oe{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShellHole(t,e){return(e||new oe).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShellHole(t,e){return t.setPosition(t.position()+4),(e||new oe).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint16(this.bb.__vector(this.bb_pos+e)+2*t):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint16Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}profileId(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint16(this.bb_pos+t):0}mutate_profile_id(t){const e=this.bb.__offset(this.bb_pos,6);return e!==0&&(this.bb.writeUint16(this.bb_pos+e,t),!0)}static startShellHole(t){t.startObject(2)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(2,e.length,2);for(let s=e.length-1;s>=0;s--)t.addInt16(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(2,e,2)}static addProfileId(t,e){t.addFieldInt16(1,e,0)}static endShellHole(t){const e=t.endObject();return t.requiredField(e,4),e}static createShellHole(t,e,s){return oe.startShellHole(t),oe.addIndices(t,e),oe.addProfileId(t,s),oe.endShellHole(t)}}class ce{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShellProfile(t,e){return(e||new ce).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShellProfile(t,e){return t.setPosition(t.position()+4),(e||new ce).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint16(this.bb.__vector(this.bb_pos+e)+2*t):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint16Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startShellProfile(t){t.startObject(1)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(2,e.length,2);for(let s=e.length-1;s>=0;s--)t.addInt16(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(2,e,2)}static endShellProfile(t){const e=t.endObject();return t.requiredField(e,4),e}static createShellProfile(t,e){return ce.startShellProfile(t),ce.addIndices(t,e),ce.endShellProfile(t)}}var Dt=(n=>(n[n.NONE=0]="NONE",n[n.BIG=1]="BIG",n))(Dt||{});class It{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShell(t,e){return(e||new It).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShell(t,e){return t.setPosition(t.position()+4),(e||new It).__init(t.readInt32(t.position())+t.position(),t)}profiles(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new ce).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}profilesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}holes(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new oe).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}holesLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}points(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new xt).__init(this.bb.__vector(this.bb_pos+s)+12*t,this.bb):null}pointsLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}bigProfiles(t,e){const s=this.bb.__offset(this.bb_pos,10);return s?(e||new he).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}bigProfilesLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}bigHoles(t,e){const s=this.bb.__offset(this.bb_pos,12);return s?(e||new ae).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}bigHolesLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}type(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.readInt8(this.bb_pos+t):Dt.NONE}mutate_type(t){const e=this.bb.__offset(this.bb_pos,14);return e!==0&&(this.bb.writeInt8(this.bb_pos+e,t),!0)}static startShell(t){t.startObject(6)}static addProfiles(t,e){t.addFieldOffset(0,e,0)}static createProfilesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startProfilesVector(t,e){t.startVector(4,e,4)}static addHoles(t,e){t.addFieldOffset(1,e,0)}static createHolesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startHolesVector(t,e){t.startVector(4,e,4)}static addPoints(t,e){t.addFieldOffset(2,e,0)}static startPointsVector(t,e){t.startVector(12,e,4)}static addBigProfiles(t,e){t.addFieldOffset(3,e,0)}static createBigProfilesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startBigProfilesVector(t,e){t.startVector(4,e,4)}static addBigHoles(t,e){t.addFieldOffset(4,e,0)}static createBigHolesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startBigHolesVector(t,e){t.startVector(4,e,4)}static addType(t,e){t.addFieldInt8(5,e,Dt.NONE)}static endShell(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,10),t.requiredField(e,12),e}static createShell(t,e,s,i,r,a,o){return It.startShell(t),It.addProfiles(t,e),It.addHoles(t,s),It.addPoints(t,i),It.addBigProfiles(t,r),It.addBigHoles(t,a),It.addType(t,o),It.endShell(t)}}class ${constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsMeshes(t,e){return(e||new $).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsMeshes(t,e){return t.setPosition(t.position()+4),(e||new $).__init(t.readInt32(t.position())+t.position(),t)}coordinates(t){const e=this.bb.__offset(this.bb_pos,4);return e?(t||new rs).__init(this.bb_pos+e,this.bb):null}meshesItems(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}meshesItemsLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}meshesItemsArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}samples(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new nr).__init(this.bb.__vector(this.bb_pos+s)+16*t,this.bb):null}samplesLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}representations(t,e){const s=this.bb.__offset(this.bb_pos,10);return s?(e||new ir).__init(this.bb.__vector(this.bb_pos+s)+32*t,this.bb):null}representationsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}materials(t,e){const s=this.bb.__offset(this.bb_pos,12);return s?(e||new yo).__init(this.bb.__vector(this.bb_pos+s)+6*t,this.bb):null}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}circleExtrusions(t,e){const s=this.bb.__offset(this.bb_pos,14);return s?(e||new yt).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}circleExtrusionsLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}shells(t,e){const s=this.bb.__offset(this.bb_pos,16);return s?(e||new It).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}shellsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}localTransforms(t,e){const s=this.bb.__offset(this.bb_pos,18);return s?(e||new rs).__init(this.bb.__vector(this.bb_pos+s)+48*t,this.bb):null}localTransformsLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}globalTransforms(t,e){const s=this.bb.__offset(this.bb_pos,20);return s?(e||new rs).__init(this.bb.__vector(this.bb_pos+s)+48*t,this.bb):null}globalTransformsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}static startMeshes(t){t.startObject(9)}static addCoordinates(t,e){t.addFieldStruct(0,e,0)}static addMeshesItems(t,e){t.addFieldOffset(1,e,0)}static createMeshesItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startMeshesItemsVector(t,e){t.startVector(4,e,4)}static addSamples(t,e){t.addFieldOffset(2,e,0)}static startSamplesVector(t,e){t.startVector(16,e,4)}static addRepresentations(t,e){t.addFieldOffset(3,e,0)}static startRepresentationsVector(t,e){t.startVector(32,e,4)}static addMaterials(t,e){t.addFieldOffset(4,e,0)}static startMaterialsVector(t,e){t.startVector(6,e,1)}static addCircleExtrusions(t,e){t.addFieldOffset(5,e,0)}static createCircleExtrusionsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startCircleExtrusionsVector(t,e){t.startVector(4,e,4)}static addShells(t,e){t.addFieldOffset(6,e,0)}static createShellsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startShellsVector(t,e){t.startVector(4,e,4)}static addLocalTransforms(t,e){t.addFieldOffset(7,e,0)}static startLocalTransformsVector(t,e){t.startVector(48,e,8)}static addGlobalTransforms(t,e){t.addFieldOffset(8,e,0)}static startGlobalTransformsVector(t,e){t.startVector(48,e,8)}static endMeshes(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,10),t.requiredField(e,12),t.requiredField(e,14),t.requiredField(e,16),t.requiredField(e,18),t.requiredField(e,20),e}static createMeshes(t,e,s,i,r,a,o,h,l,d){return $.startMeshes(t),$.addCoordinates(t,e),$.addMeshesItems(t,s),$.addSamples(t,i),$.addRepresentations(t,r),$.addMaterials(t,a),$.addCircleExtrusions(t,o),$.addShells(t,h),$.addLocalTransforms(t,l),$.addGlobalTransforms(t,d),$.endMeshes(t)}}class ns{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsRelation(t,e){return(e||new ns).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsRelation(t,e){return t.setPosition(t.position()+4),(e||new ns).__init(t.readInt32(t.position())+t.position(),t)}data(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}dataLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startRelation(t){t.startObject(1)}static addData(t,e){t.addFieldOffset(0,e,0)}static createDataVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startDataVector(t,e){t.startVector(4,e,4)}static endRelation(t){const e=t.endObject();return t.requiredField(e,4),e}static createRelation(t,e){return ns.startRelation(t),ns.addData(t,e),ns.endRelation(t)}}class ot{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSpatialStructure(t,e){return(e||new ot).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSpatialStructure(t,e){return t.setPosition(t.position()+4),(e||new ot).__init(t.readInt32(t.position())+t.position(),t)}localId(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):null}mutate_local_id(t){const e=this.bb.__offset(this.bb_pos,4);return e!==0&&(this.bb.writeUint32(this.bb_pos+e,t),!0)}category(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}children(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new ot).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}childrenLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startSpatialStructure(t){t.startObject(3)}static addLocalId(t,e){t.addFieldInt32(0,e,null)}static addCategory(t,e){t.addFieldOffset(1,e,0)}static addChildren(t,e){t.addFieldOffset(2,e,0)}static createChildrenVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startChildrenVector(t,e){t.startVector(4,e,4)}static endSpatialStructure(t){return t.endObject()}static createSpatialStructure(t,e,s,i){return ot.startSpatialStructure(t),e!==null&&ot.addLocalId(t,e),ot.addCategory(t,s),ot.addChildren(t,i),ot.endSpatialStructure(t)}}class K{constructor(){c(this,"bb",null),c(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsModel(t,e){return(e||new K).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsModel(t,e){return t.setPosition(t.position()+4),(e||new K).__init(t.readInt32(t.position())+t.position(),t)}static bufferHasIdentifier(t){return t.__has_identifier("0001")}metadata(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}guids(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}guidsLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}guidsItems(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}guidsItemsLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}guidsItemsArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}maxLocalId(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readUint32(this.bb_pos+t):0}mutate_max_local_id(t){const e=this.bb.__offset(this.bb_pos,10);return e!==0&&(this.bb.writeUint32(this.bb_pos+e,t),!0)}localIds(t){const e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}localIdsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}localIdsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}categories(t,e){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}categoriesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}meshes(t){const e=this.bb.__offset(this.bb_pos,16);return e?(t||new $).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}attributes(t,e){const s=this.bb.__offset(this.bb_pos,18);return s?(e||new ss).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}attributesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}relations(t,e){const s=this.bb.__offset(this.bb_pos,20);return s?(e||new ns).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}relationsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}relationsItems(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}relationsItemsLength(){const t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}relationsItemsArray(){const t=this.bb.__offset(this.bb_pos,22);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}guid(t){const e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__string(this.bb_pos+e,t):null}spatialStructure(t){const e=this.bb.__offset(this.bb_pos,26);return e?(t||new ot).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}alignments(t,e){const s=this.bb.__offset(this.bb_pos,28);return s?(e||new re).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}geometries(t){const e=this.bb.__offset(this.bb_pos,30);return e?(t||new q).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}uniqueAttributes(t,e){const s=this.bb.__offset(this.bb_pos,32);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}uniqueAttributesLength(){const t=this.bb.__offset(this.bb_pos,32);return t?this.bb.__vector_len(this.bb_pos+t):0}relationNames(t,e){const s=this.bb.__offset(this.bb_pos,34);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}relationNamesLength(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.__vector_len(this.bb_pos+t):0}static startModel(t){t.startObject(16)}static addMetadata(t,e){t.addFieldOffset(0,e,0)}static addGuids(t,e){t.addFieldOffset(1,e,0)}static createGuidsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startGuidsVector(t,e){t.startVector(4,e,4)}static addGuidsItems(t,e){t.addFieldOffset(2,e,0)}static createGuidsItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startGuidsItemsVector(t,e){t.startVector(4,e,4)}static addMaxLocalId(t,e){t.addFieldInt32(3,e,0)}static addLocalIds(t,e){t.addFieldOffset(4,e,0)}static createLocalIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startLocalIdsVector(t,e){t.startVector(4,e,4)}static addCategories(t,e){t.addFieldOffset(5,e,0)}static createCategoriesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startCategoriesVector(t,e){t.startVector(4,e,4)}static addMeshes(t,e){t.addFieldOffset(6,e,0)}static addAttributes(t,e){t.addFieldOffset(7,e,0)}static createAttributesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAttributesVector(t,e){t.startVector(4,e,4)}static addRelations(t,e){t.addFieldOffset(8,e,0)}static createRelationsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startRelationsVector(t,e){t.startVector(4,e,4)}static addRelationsItems(t,e){t.addFieldOffset(9,e,0)}static createRelationsItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startRelationsItemsVector(t,e){t.startVector(4,e,4)}static addGuid(t,e){t.addFieldOffset(10,e,0)}static addSpatialStructure(t,e){t.addFieldOffset(11,e,0)}static addAlignments(t,e){t.addFieldOffset(12,e,0)}static createAlignmentsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAlignmentsVector(t,e){t.startVector(4,e,4)}static addGeometries(t,e){t.addFieldOffset(13,e,0)}static addUniqueAttributes(t,e){t.addFieldOffset(14,e,0)}static createUniqueAttributesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startUniqueAttributesVector(t,e){t.startVector(4,e,4)}static addRelationNames(t,e){t.addFieldOffset(15,e,0)}static createRelationNamesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startRelationNamesVector(t,e){t.startVector(4,e,4)}static endModel(t){const e=t.endObject();return t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,12),t.requiredField(e,14),t.requiredField(e,16),t.requiredField(e,24),e}static finishModelBuffer(t,e){t.finish(e,"0001")}static finishSizePrefixedModelBuffer(t,e){t.finish(e,"0001",!0)}}var xo=(n=>(n[n.ONE=0]="ONE",n[n.TWO=1]="TWO",n))(xo||{}),gs=(n=>(n[n.NONE=0]="NONE",n[n.SHELL=1]="SHELL",n[n.CIRCLE_EXTRUSION=2]="CIRCLE_EXTRUSION",n))(gs||{}),su=(n=>(n[n.DEFAULT=0]="DEFAULT",n))(su||{});const ni=65536;var Wt=(n=>(n[n.LINE=0]="LINE",n[n.SHELL=1]="SHELL",n))(Wt||{}),_t=(n=>(n[n.UPDATE=0]="UPDATE",n[n.CREATE=1]="CREATE",n[n.DELETE=2]="DELETE",n[n.FINISH=3]="FINISH",n))(_t||{}),Y=(n=>(n[n.GEOMETRY=0]="GEOMETRY",n[n.WIRES=1]="WIRES",n[n.INVISIBLE=2]="INVISIBLE",n))(Y||{}),Se=(n=>(n[n.CREATE_MODEL=0]="CREATE_MODEL",n[n.DELETE_MODEL=1]="DELETE_MODEL",n[n.EXECUTE=2]="EXECUTE",n[n.RAYCAST=3]="RAYCAST",n[n.FETCH_BOXES=4]="FETCH_BOXES",n[n.REFRESH_VIEW=5]="REFRESH_VIEW",n[n.RECOMPUTE_MESHES=6]="RECOMPUTE_MESHES",n[n.CREATE_MATERIAL=7]="CREATE_MATERIAL",n[n.THROW_ERROR=8]="THROW_ERROR",n))(Se||{}),Hr=(n=>(n[n.VISIBLE=0]="VISIBLE",n))(Hr||{}),hs=(n=>(n[n.POINT=0]="POINT",n[n.LINE=1]="LINE",n[n.FACE=2]="FACE",n))(hs||{});class qi{static containedInParallelPlanes(t,e){let s=!0;for(const i of t){const r=i.distanceToPoint(e);s=s&&r>=0}return s}static collides(t,e,s){for(const i of e)if(this.getPointDistance(i,s,t)<0)return!1;return!0}static getPointDistance(t,e,s){const i=t.normal;for(const r of this.dimensions){const a=i[r]>=0!==e;this.tempPoint[r]=a?s.max[r]:s.min[r]}return t.distanceToPoint(this.tempPoint)}}c(qi,"tempPoint",new T),c(qi,"dimensions",["x","y","z"]);class Ms{static transform(t,e,s=new ii){for(let i=0;i<s.planes.length;i++){const r=s.planes[i],a=t.planes[i];r.copy(a),r.applyMatrix4(e)}return s}static isIncluded(t,e){return qi.collides(t,e,!0)}static collides(t,e){return qi.collides(t,e,!1)}}function iu(n,t,e=2){const s=t&&t.length,i=s?t[0]*e:n.length;let r=xa(n,0,i,e,!0);const a=[];if(!r||r.next===r.prev)return a;let o,h,l;if(s&&(r=function(d,u,p,f){const m=[];for(let b=0,I=u.length;b<I;b++){const C=xa(d,u[b]*f,b<I-1?u[b+1]*f:d.length,f,!1);C===C.next&&(C.steiner=!0),m.push(du(C))}m.sort(lu);for(let b=0;b<m.length;b++)p=hu(m[b],p);return p}(n,t,r,e)),n.length>80*e){o=1/0,h=1/0;let d=-1/0,u=-1/0;for(let p=e;p<i;p+=e){const f=n[p],m=n[p+1];f<o&&(o=f),m<h&&(h=m),f>d&&(d=f),m>u&&(u=m)}l=Math.max(d-o,u-h),l=l!==0?32767/l:0}return Zi(r,a,e,o,h,l,0),a}function xa(n,t,e,s,i){let r;if(i===function(a,o,h,l){let d=0;for(let u=o,p=h-l;u<h;u+=l)d+=(a[p]-a[u])*(a[u+1]+a[p+1]),p=u;return d}(n,t,e,s)>0)for(let a=t;a<e;a+=s)r=Oa(a/s|0,n[a],n[a+1],r);else for(let a=e-s;a>=t;a-=s)r=Oa(a/s|0,n[a],n[a+1],r);return r&&ri(r,r.next)&&($i(r),r=r.next),r}function Ds(n,t){if(!n)return n;t||(t=n);let e,s=n;do if(e=!1,s.steiner||!ri(s,s.next)&&dt(s.prev,s,s.next)!==0)s=s.next;else{if($i(s),s=t=s.prev,s===s.next)break;e=!0}while(e||s!==t);return t}function Zi(n,t,e,s,i,r,a){if(!n)return;!a&&r&&function(h,l,d,u){let p=h;do p.z===0&&(p.z=Wr(p.x,p.y,l,d,u)),p.prevZ=p.prev,p.nextZ=p.next,p=p.next;while(p!==h);p.prevZ.nextZ=null,p.prevZ=null,function(f){let m,b=1;do{let I,C=f;f=null;let R=null;for(m=0;C;){m++;let E=C,g=0;for(let A=0;A<b&&(g++,E=E.nextZ,E);A++);let w=b;for(;g>0||w>0&&E;)g!==0&&(w===0||!E||C.z<=E.z)?(I=C,C=C.nextZ,g--):(I=E,E=E.nextZ,w--),R?R.nextZ=I:f=I,I.prevZ=R,R=I;C=E}R.nextZ=null,b*=2}while(m>1)}(p)}(n,s,i,r);let o=n;for(;n.prev!==n.next;){const h=n.prev,l=n.next;if(r?ru(n,s,i,r):nu(n))t.push(h.i,n.i,l.i),$i(n),n=l.next,o=l.next;else if((n=l)===o){a?a===1?Zi(n=au(Ds(n),t),t,e,s,i,r,2):a===2&&ou(n,t,e,s,i,r):Zi(Ds(n),t,e,s,i,r,1);break}}}function nu(n){const t=n.prev,e=n,s=n.next;if(dt(t,e,s)>=0)return!1;const i=t.x,r=e.x,a=s.x,o=t.y,h=e.y,l=s.y,d=Math.min(i,r,a),u=Math.min(o,h,l),p=Math.max(i,r,a),f=Math.max(o,h,l);let m=s.next;for(;m!==t;){if(m.x>=d&&m.x<=p&&m.y>=u&&m.y<=f&&Ti(i,o,r,h,a,l,m.x,m.y)&&dt(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function ru(n,t,e,s){const i=n.prev,r=n,a=n.next;if(dt(i,r,a)>=0)return!1;const o=i.x,h=r.x,l=a.x,d=i.y,u=r.y,p=a.y,f=Math.min(o,h,l),m=Math.min(d,u,p),b=Math.max(o,h,l),I=Math.max(d,u,p),C=Wr(f,m,t,e,s),R=Wr(b,I,t,e,s);let E=n.prevZ,g=n.nextZ;for(;E&&E.z>=C&&g&&g.z<=R;){if(E.x>=f&&E.x<=b&&E.y>=m&&E.y<=I&&E!==i&&E!==a&&Ti(o,d,h,u,l,p,E.x,E.y)&&dt(E.prev,E,E.next)>=0||(E=E.prevZ,g.x>=f&&g.x<=b&&g.y>=m&&g.y<=I&&g!==i&&g!==a&&Ti(o,d,h,u,l,p,g.x,g.y)&&dt(g.prev,g,g.next)>=0))return!1;g=g.nextZ}for(;E&&E.z>=C;){if(E.x>=f&&E.x<=b&&E.y>=m&&E.y<=I&&E!==i&&E!==a&&Ti(o,d,h,u,l,p,E.x,E.y)&&dt(E.prev,E,E.next)>=0)return!1;E=E.prevZ}for(;g&&g.z<=R;){if(g.x>=f&&g.x<=b&&g.y>=m&&g.y<=I&&g!==i&&g!==a&&Ti(o,d,h,u,l,p,g.x,g.y)&&dt(g.prev,g,g.next)>=0)return!1;g=g.nextZ}return!0}function au(n,t){let e=n;do{const s=e.prev,i=e.next.next;!ri(s,i)&&vo(s,e,e.next,i)&&Xi(s,i)&&Xi(i,s)&&(t.push(s.i,e.i,i.i),$i(e),$i(e.next),e=n=i),e=e.next}while(e!==n);return Ds(e)}function ou(n,t,e,s,i,r){let a=n;do{let o=a.next.next;for(;o!==a.prev;){if(a.i!==o.i&&uu(a,o)){let h=Lo(a,o);return a=Ds(a,a.next),h=Ds(h,h.next),Zi(a,t,e,s,i,r,0),void Zi(h,t,e,s,i,r,0)}o=o.next}a=a.next}while(a!==n)}function lu(n,t){let e=n.x-t.x;return e===0&&(e=n.y-t.y,e===0)&&(e=(n.next.y-n.y)/(n.next.x-n.x)-(t.next.y-t.y)/(t.next.x-t.x)),e}function hu(n,t){const e=function(i,r){let a=r;const o=i.x,h=i.y;let l,d=-1/0;if(ri(i,a))return a;do{if(ri(i,a.next))return a.next;if(h<=a.y&&h>=a.next.y&&a.next.y!==a.y){const b=a.x+(h-a.y)*(a.next.x-a.x)/(a.next.y-a.y);if(b<=o&&b>d&&(d=b,l=a.x<a.next.x?a:a.next,b===o))return l}a=a.next}while(a!==r);if(!l)return null;const u=l,p=l.x,f=l.y;let m=1/0;a=l;do{if(o>=a.x&&a.x>=p&&o!==a.x&&Oo(h<f?o:d,h,p,f,h<f?d:o,h,a.x,a.y)){const b=Math.abs(h-a.y)/(o-a.x);Xi(a,i)&&(b<m||b===m&&(a.x>l.x||a.x===l.x&&cu(l,a)))&&(l=a,m=b)}a=a.next}while(a!==u);return l}(n,t);if(!e)return t;const s=Lo(e,n);return Ds(s,s.next),Ds(e,e.next)}function cu(n,t){return dt(n.prev,n,t.prev)<0&&dt(t.next,n,n.next)<0}function Wr(n,t,e,s,i){return(n=1431655765&((n=858993459&((n=252645135&((n=16711935&((n=(n-e)*i|0)|n<<8))|n<<4))|n<<2))|n<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-s)*i|0)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function du(n){let t=n,e=n;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==n);return e}function Oo(n,t,e,s,i,r,a,o){return(i-a)*(t-o)>=(n-a)*(r-o)&&(n-a)*(s-o)>=(e-a)*(t-o)&&(e-a)*(r-o)>=(i-a)*(s-o)}function Ti(n,t,e,s,i,r,a,o){return!(n===a&&t===o)&&Oo(n,t,e,s,i,r,a,o)}function uu(n,t){return n.next.i!==t.i&&n.prev.i!==t.i&&!function(e,s){let i=e;do{if(i.i!==e.i&&i.next.i!==e.i&&i.i!==s.i&&i.next.i!==s.i&&vo(i,i.next,e,s))return!0;i=i.next}while(i!==e);return!1}(n,t)&&(Xi(n,t)&&Xi(t,n)&&function(e,s){let i=e,r=!1;const a=(e.x+s.x)/2,o=(e.y+s.y)/2;do i.y>o!=i.next.y>o&&i.next.y!==i.y&&a<(i.next.x-i.x)*(o-i.y)/(i.next.y-i.y)+i.x&&(r=!r),i=i.next;while(i!==e);return r}(n,t)&&(dt(n.prev,n,t.prev)||dt(n,t.prev,t))||ri(n,t)&&dt(n.prev,n,n.next)>0&&dt(t.prev,t,t.next)>0)}function dt(n,t,e){return(t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y)}function ri(n,t){return n.x===t.x&&n.y===t.y}function vo(n,t,e,s){const i=_n(dt(n,t,e)),r=_n(dt(n,t,s)),a=_n(dt(e,s,n)),o=_n(dt(e,s,t));return i!==r&&a!==o||!(i!==0||!In(n,e,t))||!(r!==0||!In(n,s,t))||!(a!==0||!In(e,n,s))||!(o!==0||!In(e,t,s))}function In(n,t,e){return t.x<=Math.max(n.x,e.x)&&t.x>=Math.min(n.x,e.x)&&t.y<=Math.max(n.y,e.y)&&t.y>=Math.min(n.y,e.y)}function _n(n){return n>0?1:n<0?-1:0}function Xi(n,t){return dt(n.prev,n,n.next)<0?dt(n,t,n.next)>=0&&dt(n,n.prev,t)>=0:dt(n,t,n.prev)<0||dt(n,n.next,t)<0}function Lo(n,t){const e=jr(n.i,n.x,n.y),s=jr(t.i,t.x,t.y),i=n.next,r=t.prev;return n.next=t,t.prev=n,e.next=i,i.prev=e,s.next=e,e.prev=s,r.next=s,s.prev=r,s}function Oa(n,t,e,s){const i=jr(n,t,e);return s?(i.next=s.next,i.prev=s,s.next.prev=i,s.next=i):(i.prev=i,i.next=i),i}function $i(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function jr(n,t,e){return{i:n,x:t,y:e,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}class fu{constructor(){c(this,"int"),c(this,"float"),c(this,"buffer"),c(this,"s1",4),c(this,"s2",8);const{intBuffer:t,floatBuffer:e,buffer:s}=this.newBuffers();this.int=t,this.float=e,this.buffer=s}newBuffers(){const t=new Int32Array(1),e=t.buffer;return{intBuffer:t,floatBuffer:new Float32Array(e),buffer:new Uint8Array(e)}}}class qr{static check(t){const e=Number.isInteger(t),s=t<this._max,i=t>this._min;return e&&s&&i}}c(qr,"_max",2147483647),c(qr,"_min",-2147483648);const No=class Po{constructor(){c(this,"_core",new fu),c(this,"_handlers"),c(this,"_result",-1),c(this,"handleObject",t=>{const e=Object.keys(t);for(const s of e)t.hasOwnProperty(s)&&this.compute(t[s])}),c(this,"handleString",t=>{const e=t.length;for(let s=0;s<e;++s){const i=t.codePointAt(s);this._core.int[0]=i,this.update()}}),c(this,"handleBoolean",t=>{this._core.int[0]=t?1:0,this.update()}),c(this,"handleNumber",t=>{(qr.check(t)?this._core.int:this._core.float)[0]=t,this.update()}),this._handlers=this.newHandlers()}get value(){return~this._result}fromMaterialData(t){const{modelId:e,objectClass:s,currentLod:i,templateId:r,...a}=t;this.reset(),this.compute(e),this.compute(s),this.compute(a),this.compute(i),this.compute(r!==void 0)}generate(t){this.reset();for(const e of t)this.compute(e);return this.value}compute(t){return this.getHandler(t)(t),this}reset(){return this._result=-1,this}getHandler(t){const e=typeof t,s=this._handlers[e];if(!s)throw new Error("Fragments: Unsupported input type");return s}newHandlers(){return{number:this.handleNumber,boolean:this.handleBoolean,string:this.handleString,object:this.handleObject}}update(){for(let t=0;t<this._core.s1;++t){this._result^=this._core.buffer[t];for(let e=0;e<this._core.s2;++e)1&this._result?this._result=this._result>>1^Po._polynomial:this._result>>=1}}};c(No,"_polynomial",2197175160);let fa=No;const Dn=class Un{constructor(t,e){c(this,"_first"),this._first=this.newData(t,e)}static getComplementary(t,e){let s=0;const i=t.position.length;s=this.makeBufferComplementary(i,t,s,e),s!==1/0&&e(s,1/0)}static get(t,e,s,i){const{filtered:r,position:a,size:o}=this.getData(t,s);return this.setAllBufferData(r,e,a,o,i),{position:a,size:o}}fullOf(t){const e=this._first.following,s=this._first.data;return e===null&&s===t}update(t,e){const s=this.getBufferData(t);if(s.data!==e){const{a:i,c:r,b:a}=this.newBuffers(t,s,e);this.setupInputData(s,i,r),this.setupUpdateBuffers(i,a,r)}}size(t){let e=0,s=this._first;for(;s!==null;)this.doesFilterPass(t,s)&&e++,s=s.following;return e}static setAllBufferData(t,e,s,i,r){for(let a=0;a<t.length;++a){const o=t[a];this.transform(o,e),this.setBuffers(s,i,a),r&&r(a,o.data)}}static makeBufferComplementary(t,e,s,i){for(let r=0;r<t;++r){const a=this.getBuffers(e,r),{position:o,size:h}=a;o>s&&i(s,o-s),s=o+h}return s}static setBuffers(t,e,s){t[s]=this._tempData.position;const i=this._tempData.size===1/0;e[s]=i?this._inf:this._tempData.size}add(t,e,s){if(!Un._stash.length)return this.newData(e,s,t);const i=Un._stash.pop();if(!i)throw new Error("Fragments: No stash found");return i.position=t,i.size=e,i.data=s,i}remove(t){t&&(t.following=null,t.past=null,Un._stash.push(t))}static getData(t,e){const s=t.filter(e),i=s.length;return{filtered:s,position:new Uint32Array(i),size:new Uint32Array(i)}}filter(t){const e=[];let s=this._first;for(;s!==null;)this.doesFilterPass(t,s)&&e.push(s),s=s.following;return e}static transform(t,e){const s=this.getTempData(),i=t.position+t.size,r=i===e.length;if(s.position=e[t.position],r)s.size=1/0;else{const a=e[i];s.size=a-s.position}return s}static getBuffers(t,e){const s=t.position[e];let i;return i=t.size[e]===this._inf?1/0:t.size[e],{position:s,size:i}}static getTempData(){return this._tempData?this._tempData:{position:0,size:0}}doesFilterPass(t,e){return!t||t(e.data)}setupUpdateBuffers(t,e,s){this.chainBuffers(t,e,s),this.setupFirstBuffer(t,e),this.setupLastBuffer(s,e),this.setupMiddleBufferStart(e),this.setupMiddleBufferEnd(e)}setupMiddleBufferEnd(t){var e;if(((e=t.following)==null?void 0:e.data)===t.data){if(!t.following)return;const s=t.following.size+t.size,i=t.following.following;t.size=s,this.remove(t.following),t.following=i,t.following&&(t.following.past=t)}}setupFirstBuffer(t,e){t.size||(t.past?t.past.following=e:this._first=e,e.past=t.past,this.remove(t))}setupMiddleBufferStart(t){var e;if(((e=t.past)==null?void 0:e.data)===t.data){if(!t.past)return;t.size=t.past.size+t.size,t.position=t.past.position;const s=t.past.past;this.remove(t.past),t.past=s,t.past?t.past.following=t:this._first=t}}chainBuffers(t,e,s){t.following=e,e.past=t,e.following=s,s.past=e}setupLastBuffer(t,e){t.size||(t.following&&(t.following.past=e),e.following=t.following,this.remove(t))}newBuffers(t,e,s){const i=t-e.position,r=this.add(e.position,i,e.data),a=this.add(t,1,s),o=e.size-r.size-1;return{a:r,c:this.add(t+1,o,e.data),b:a}}setupInputData(t,e,s){t.past?(t.past.following=e,e.past=t.past):this._first=e,t.following&&(t.following.past=s,s.following=t.following),this.remove(t)}newData(t,e,s=0){return{position:s,size:t,past:null,following:null,data:e}}getBufferData(t){let e=this._first;for(;;){const s=e===null,i=e.position<=t,r=t<e.position+e.size;if(s||i&&r)return e;e=e.following}}};c(Dn,"_stash",[]),c(Dn,"_tempData",{position:0,size:0}),c(Dn,"_inf",4294967295);let Ri=Dn;class Ae{static fixNumber(t){return Number.isNaN(t)?0:Number.isFinite(t)?t:0}static forEach(t,e){if(Array.isArray(t)){let s=0;for(const i of t)e(i,s++)}else e(t,0)}}class Mo{static estimateCapacity(){const t=this.capacityFactor,e=window.screen.width,s=window.screen.height,i=window.devicePixelRatio;return Math.trunc(e*s*i*i*t)}}c(Mo,"capacityFactor",200);class ur{static check(t,e,s){const i=this.get(s);return!!(t[e]&i)}static apply(t,e,s,i){const r=this.get(s);i?t[e]|=r:t[e]&=~r}static checkMemory(t){if(t>ni)throw new Error("Fragments: Memory overflow!")}static get(t){return 1<<t}}class Js{static parseMaterial(t){const e=t.r()/255,s=t.g()/255,i=t.b()/255,r=t.a()/255,a=t.a()<255;return{color:new Wi(e,s,i),renderedFaces:t.renderedFaces(),opacity:r,transparent:a}}static parseBox(t,e){this.getBox(t,e,"min"),this.getBox(t,e,"max")}static parseTransform(t,e){return this.getVector(t,"position",this._doubleVector),this.getVector(t,"xDirection",this._floatVector),this.getVector(t,"yDirection",this._floatVector),this.computeZVector(),this.setTransform(e),e}static setTransform(t){const{x:e,y:s,z:i}=this._temp.xDirection,{x:r,y:a,z:o}=this._temp.yDirection,{x:h,y:l,z:d}=this._temp.zDirection,{x:u,y:p,z:f}=this._temp.position;t.set(e,r,h,u,s,a,l,p,i,o,d,f,0,0,0,1)}static getBox(t,e,s){t[s](this._floatVector);const i=this._floatVector.x(),r=this._floatVector.y(),a=this._floatVector.z();e[s].x=Ae.fixNumber(i),e[s].y=Ae.fixNumber(r),e[s].z=Ae.fixNumber(a)}static getVector(t,e,s){t[e](s);const i=this._temp[e],r=s.x(),a=s.y(),o=s.z();i.x=Ae.fixNumber(r),i.y=Ae.fixNumber(a),i.z=Ae.fixNumber(o)}static computeZVector(){this._temp.zDirection.crossVectors(this._temp.xDirection,this._temp.yDirection)}}c(Js,"_temp",{position:new T,xDirection:new T,yDirection:new T,zDirection:new T}),c(Js,"_doubleVector",new So),c(Js,"_floatVector",new xt);const Qt=class{static get(n,t,e){this.fetchSampleTransform(n,t),this.fetchItemTransform(n,t),e.multiplyMatrices(this._item,this._sample)}static getBox(n,t){n.bbox(this._box),Js.parseBox(this._box,t)}static getBoxData(n){this._min.copy(n.min),this._max.copy(n.max),this._center.addVectors(this._min,this._max),this._center.divideScalar(2),n.getSize(this._distance)}static boxSize(n){return this.getBoxData(n),this.applyTransformer(),this._edge.start=this._min.clone(),this._edge.end=this._max.clone(),this._edge}static applyTransformer(){const{x:n,y:t,z:e}=this._distance,s=Math.max(n,t,e);n===s?this._transformers.x():t===s?this._transformers.y():this._transformers.z()}static fetchItemTransform(n,t){const e=n.item();t.globalTransforms(e,this._transform),Js.parseTransform(this._transform,this._item)}static fetchSampleTransform(n,t){const e=n.localTransform();t.localTransforms(e,this._transform),Js.parseTransform(this._transform,this._sample)}static setBoxZ(){this._min.set(this._center.x,this._center.y,this._min.z),this._max.set(this._center.x,this._center.y,this._max.z)}static setBoxY(){this._min.set(this._center.x,this._min.y,this._center.z),this._max.set(this._center.x,this._max.y,this._center.z)}static setBoxX(){this._min.set(this._min.x,this._center.y,this._center.z),this._max.set(this._max.x,this._center.y,this._center.z)}};c(Qt,"_transform",new rs),c(Qt,"_min",new T),c(Qt,"_max",new T),c(Qt,"_center",new T),c(Qt,"_distance",new T),c(Qt,"_edge",new Ee),c(Qt,"_item",new rt),c(Qt,"_sample",new rt),c(Qt,"_box",new Fo),c(Qt,"_transformers",{x:()=>Qt.setBoxX(),y:()=>Qt.setBoxY(),z:()=>Qt.setBoxZ()});let Xs=Qt;class Do{static getWidth(t){return t.getSize(this._temp.vector),this._temp.vector.x>this._temp.vector.y&&this._temp.vector.set(this._temp.vector.y,this._temp.vector.x,this._temp.vector.z),this._temp.vector.y>this._temp.vector.z&&this._temp.vector.set(this._temp.vector.x,this._temp.vector.z,this._temp.vector.y),this._temp.vector.x>this._temp.vector.y&&this._temp.vector.set(this._temp.vector.y,this._temp.vector.x,this._temp.vector.z),this._temp.vector.y}}c(Do,"_temp",{vector:new T});class Uo{static getEarcutDimensions(t){const e=Math.abs(t.x),s=Math.abs(t.y),i=Math.abs(t.z);return i>e&&i>s?t.z>0?[0,1]:[1,0]:s>e&&s>i?t.y>0?[2,0]:[0,2]:t.x>0?[1,2]:[2,1]}}const va=new Et,En=new T;class Vo extends mo{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry",this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new Nr([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new Nr([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}applyMatrix4(t){const e=this.attributes.instanceStart,s=this.attributes.instanceEnd;return e!==void 0&&(e.applyMatrix4(t),s.applyMatrix4(t),e.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const s=new Wn(e,6,1);return this.setAttribute("instanceStart",new Is(s,3,0)),this.setAttribute("instanceEnd",new Is(s,3,3)),this.instanceCount=this.attributes.instanceStart.count,this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const s=new Wn(e,6,1);return this.setAttribute("instanceColorStart",new Is(s,3,0)),this.setAttribute("instanceColorEnd",new Is(s,3,3)),this}fromWireframeGeometry(t){return this.setPositions(t.attributes.position.array),this}fromEdgesGeometry(t){return this.setPositions(t.attributes.position.array),this}fromMesh(t){return this.fromWireframeGeometry(new Od(t.geometry)),this}fromLineSegments(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Et);const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;t!==void 0&&e!==void 0&&(this.boundingBox.setFromBufferAttribute(t),va.setFromBufferAttribute(e),this.boundingBox.union(va))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new rn),this.boundingBox===null&&this.computeBoundingBox();const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(t!==void 0&&e!==void 0){const s=this.boundingSphere.center;this.boundingBox.getCenter(s);let i=0;for(let r=0,a=t.count;r<a;r++)En.fromBufferAttribute(t,r),i=Math.max(i,s.distanceToSquared(En)),En.fromBufferAttribute(e,r),i=Math.max(i,s.distanceToSquared(En));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}}Ii.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new He(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}},vn.line={uniforms:aa.merge([Ii.common,Ii.fog,Ii.line]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};class Fs extends Eo{constructor(t){super({type:"LineMaterial",uniforms:aa.clone(vn.line.uniforms),vertexShader:vn.line.vertexShader,fragmentShader:vn.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,this.setValues(t)}get color(){return this.uniforms.diffuse.value}set color(t){this.uniforms.diffuse.value=t}get worldUnits(){return"WORLD_UNITS"in this.defines}set worldUnits(t){t===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}get linewidth(){return this.uniforms.linewidth.value}set linewidth(t){this.uniforms.linewidth&&(this.uniforms.linewidth.value=t)}get dashed(){return"USE_DASH"in this.defines}set dashed(t){t===!0!==this.dashed&&(this.needsUpdate=!0),t===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}get dashScale(){return this.uniforms.dashScale.value}set dashScale(t){this.uniforms.dashScale.value=t}get dashSize(){return this.uniforms.dashSize.value}set dashSize(t){this.uniforms.dashSize.value=t}get dashOffset(){return this.uniforms.dashOffset.value}set dashOffset(t){this.uniforms.dashOffset.value=t}get gapSize(){return this.uniforms.gapSize.value}set gapSize(t){this.uniforms.gapSize.value=t}get opacity(){return this.uniforms.opacity.value}set opacity(t){this.uniforms&&(this.uniforms.opacity.value=t)}get resolution(){return this.uniforms.resolution.value}set resolution(t){this.uniforms.resolution.value.copy(t)}get alphaToCoverage(){return"USE_ALPHA_TO_COVERAGE"in this.defines}set alphaToCoverage(t){this.defines&&(t===!0!==this.alphaToCoverage&&(this.needsUpdate=!0),t===!0?this.defines.USE_ALPHA_TO_COVERAGE="":delete this.defines.USE_ALPHA_TO_COVERAGE)}}const fr=new nn,La=new T,Na=new T,Ot=new nn,vt=new nn,xe=new nn,pr=new T,br=new rt,Lt=new Ee,Pa=new T,mn=new Et,Cn=new rn,Oe=new nn;let ve,Ss;function Ma(n,t,e){return Oe.set(0,0,-t,1).applyMatrix4(n.projectionMatrix),Oe.multiplyScalar(1/Oe.w),Oe.x=Ss/e.width,Oe.y=Ss/e.height,Oe.applyMatrix4(n.projectionMatrixInverse),Oe.multiplyScalar(1/Oe.w),Math.abs(Math.max(Oe.x,Oe.y))}class pu extends oa{constructor(t=new Vo,e=new Fs({color:16777215*Math.random()})){super(t,e),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const t=this.geometry,e=t.attributes.instanceStart,s=t.attributes.instanceEnd,i=new Float32Array(2*e.count);for(let a=0,o=0,h=e.count;a<h;a++,o+=2)La.fromBufferAttribute(e,a),Na.fromBufferAttribute(s,a),i[o]=o===0?0:i[o-1],i[o+1]=i[o]+La.distanceTo(Na);const r=new Wn(i,2,1);return t.setAttribute("instanceDistanceStart",new Is(r,1,0)),t.setAttribute("instanceDistanceEnd",new Is(r,1,1)),this}raycast(t,e){const s=this.material.worldUnits,i=t.camera;i!==null||s||console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const r=t.params.Line2!==void 0&&t.params.Line2.threshold||0;ve=t.ray;const a=this.matrixWorld,o=this.geometry,h=this.material;let l,d;Ss=h.linewidth+r,o.boundingSphere===null&&o.computeBoundingSphere(),Cn.copy(o.boundingSphere).applyMatrix4(a),s?l=.5*Ss:l=Ma(i,Math.max(i.near,Cn.distanceToPoint(ve.origin)),h.resolution),Cn.radius+=l,ve.intersectsSphere(Cn)!==!1&&(o.boundingBox===null&&o.computeBoundingBox(),mn.copy(o.boundingBox).applyMatrix4(a),s?d=.5*Ss:d=Ma(i,Math.max(i.near,mn.distanceToPoint(ve.origin)),h.resolution),mn.expandByScalar(d),ve.intersectsBox(mn)!==!1&&(s?function(u,p){const f=u.matrixWorld,m=u.geometry,b=m.attributes.instanceStart,I=m.attributes.instanceEnd;for(let C=0,R=Math.min(m.instanceCount,b.count);C<R;C++){Lt.start.fromBufferAttribute(b,C),Lt.end.fromBufferAttribute(I,C),Lt.applyMatrix4(f);const E=new T,g=new T;ve.distanceSqToSegment(Lt.start,Lt.end,g,E),g.distanceTo(E)<.5*Ss&&p.push({point:g,pointOnLine:E,distance:ve.origin.distanceTo(g),object:u,face:null,faceIndex:C,uv:null,uv1:null})}}(this,e):function(u,p,f){const m=p.projectionMatrix,b=u.material.resolution,I=u.matrixWorld,C=u.geometry,R=C.attributes.instanceStart,E=C.attributes.instanceEnd,g=Math.min(C.instanceCount,R.count),w=-p.near;ve.at(1,xe),xe.w=1,xe.applyMatrix4(p.matrixWorldInverse),xe.applyMatrix4(m),xe.multiplyScalar(1/xe.w),xe.x*=b.x/2,xe.y*=b.y/2,xe.z=0,pr.copy(xe),br.multiplyMatrices(p.matrixWorldInverse,I);for(let A=0,y=g;A<y;A++){if(Ot.fromBufferAttribute(R,A),vt.fromBufferAttribute(E,A),Ot.w=1,vt.w=1,Ot.applyMatrix4(br),vt.applyMatrix4(br),Ot.z>w&&vt.z>w)continue;if(Ot.z>w){const M=Ot.z-vt.z,V=(Ot.z-w)/M;Ot.lerp(vt,V)}else if(vt.z>w){const M=vt.z-Ot.z,V=(vt.z-w)/M;vt.lerp(Ot,V)}Ot.applyMatrix4(m),vt.applyMatrix4(m),Ot.multiplyScalar(1/Ot.w),vt.multiplyScalar(1/vt.w),Ot.x*=b.x/2,Ot.y*=b.y/2,vt.x*=b.x/2,vt.y*=b.y/2,Lt.start.copy(Ot),Lt.start.z=0,Lt.end.copy(vt),Lt.end.z=0;const F=Lt.closestPointToPointParameter(pr,!0);Lt.at(F,Pa);const S=fo.lerp(Ot.z,vt.z,F),x=S>=-1&&S<=1,v=pr.distanceTo(Pa)<.5*Ss;if(x&&v){Lt.start.fromBufferAttribute(R,A),Lt.end.fromBufferAttribute(E,A),Lt.start.applyMatrix4(I),Lt.end.applyMatrix4(I);const M=new T,V=new T;ve.distanceSqToSegment(Lt.start,Lt.end,V,M),f.push({point:V,pointOnLine:M,distance:ve.origin.distanceTo(V),object:u,face:null,faceIndex:A,uv:null,uv1:null})}}}(this,i,e)))}onBeforeRender(t){const e=this.material.uniforms;e&&e.resolution&&(t.getViewport(fr),this.material.uniforms.resolution.value.set(fr.z,fr.w))}}class Bo extends Vo{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(t){const e=t.length-3,s=new Float32Array(2*e);for(let i=0;i<e;i+=3)s[2*i]=t[i],s[2*i+1]=t[i+1],s[2*i+2]=t[i+2],s[2*i+3]=t[i+3],s[2*i+4]=t[i+4],s[2*i+5]=t[i+5];return super.setPositions(s),this}setColors(t){const e=t.length-3,s=new Float32Array(2*e);for(let i=0;i<e;i+=3)s[2*i]=t[i],s[2*i+1]=t[i+1],s[2*i+2]=t[i+2],s[2*i+3]=t[i+3],s[2*i+4]=t[i+4],s[2*i+5]=t[i+5];return super.setColors(s),this}setFromPoints(t){const e=t.length-1,s=new Float32Array(6*e);for(let i=0;i<e;i++)s[6*i]=t[i].x,s[6*i+1]=t[i].y,s[6*i+2]=t[i].z||0,s[6*i+3]=t[i+1].x,s[6*i+4]=t[i+1].y,s[6*i+5]=t[i+1].z||0;return super.setPositions(s),this}fromLine(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}}class bu extends pu{constructor(t=new Bo,e=new Fs({color:16777215*Math.random()})){super(t,e),this.isLine2=!0,this.type="Line2"}}class Iu{constructor(t){c(this,"model"),c(this,"_endpointsMaterials",{interior:new _a({color:15658734,size:8,sizeAttenuation:!1,depthTest:!1}),exterior:new _a({color:16777215,size:16,sizeAttenuation:!1,depthTest:!1})}),c(this,"_absoluteAlignments",new un),c(this,"_horizontalAlignments",new un),c(this,"_verticalAlignments",new un),c(this,"_alignmentMaterials",new Map([[ke.NONE,new Fs({color:16777215,linewidth:5,depthTest:!1})],[ke.LINES,new Fs({color:16711935,linewidth:5,depthTest:!1})],[ke.CLOTHOID,new Fs({color:16711680,linewidth:5,depthTest:!1})],[ke.ELLIPSE_ARC,new Fs({color:65535,linewidth:5,depthTest:!1})],[ke.PARABOLA,new Fs({color:255,linewidth:5,depthTest:!1})]])),this.model=t}async getAlignments(){return this._absoluteAlignments.children.length||await this.constructAlignments(),this._absoluteAlignments}async getHorizontalAlignments(){return this._horizontalAlignments.children.length||await this.constructAlignments(),this._horizontalAlignments}async getVerticalAlignments(){return this._verticalAlignments.children.length||await this.constructAlignments(),this._verticalAlignments}async getAlignmentStyles(){return{...this._alignmentMaterials,...this._endpointsMaterials}}async constructAlignments(){const t=await this.model.threads.invoke(this.model.modelId,"getAlignments");for(const e of t)this.constructLine(e.absolute,this._absoluteAlignments),this.constructLine(e.horizontal,this._horizontalAlignments),this.constructLine(e.vertical,this._verticalAlignments)}constructLine(t,e){if(!t.length)return;const s=[],i=[],r=new un;e.add(r);const a=t[0].points,o=t[t.length-1].points;i.push(o[0],o[1],o[2]),i.push(a[a.length-3],a[a.length-2],a[a.length-1]);for(const d of t){const u=d.points;s.push(u[0],u[1],u[2]),s.push(u[u.length-3],u[u.length-2],u[u.length-1]);const p=new Bo;p.setPositions(u);const f=this._alignmentMaterials.get(d.type),m=new bu(p,f);r.add(m),m.renderOrder=1,m.userData.points=u}const{interior:h,exterior:l}=this._endpointsMaterials;this.constructPoints(s,h,r),this.constructPoints(i,l,r)}constructPoints(t,e,s){const i=new Ll,r=new Pr,a=new Float32Array(t),o=new Gs(a,3);r.setAttribute("position",o),i.geometry=r,i.material=e,s.add(i),i.renderOrder=2}dispose(){this._absoluteAlignments.removeFromParent();for(const t of this._absoluteAlignments.children){const e=t;e.geometry.dispose(),e.geometry=void 0,e.material=void 0}for(const t of Object.values(this._alignmentMaterials))t.dispose();this._alignmentMaterials={}}}class _u{async setup(t,e,s,i,r){const a=this.getCreateModelMessage(t,s,i,r),o=this.formatModelData(s),h=await t.threads.fetch(a,o);this.updateBox(e,h)}formatModelData(t){if(t instanceof ArrayBuffer)return[t]}updateBox(t,e){t.min.copy(e.boundingBox.min),t.max.copy(e.boundingBox.max)}getCreateModelMessage(t,e,s,i){return{class:Se.CREATE_MODEL,modelId:t.modelId,modelData:e,raw:s,config:i}}}class Eu{async getBoxes(t,e){const s=this.getIndividualBoxesIds(e),i=this.getBoxRequest(t,s),r=await t.threads.fetch(i);return this.getAllBoxes(r,t)}async getMergedBox(t,e){const s=this.getBoxRequest(t,[e]),{boxes:i}=await t.threads.fetch(s),[r]=i;return this.getAbsoluteBox(r,t)}getAbsoluteBox(t,e){const s=new Et;return s.copy(t),s.applyMatrix4(e.object.matrixWorld),s}getIndividualBoxesIds(t){if(!t)return;const e=[];for(const s of t)e.push([s]);return e}getAllBoxes(t,e){const s=t.boxes,i=[];for(const r of s){const a=new Et;a.copy(r),a.applyMatrix4(e.object.matrixWorld),i.push(a)}return i}getBoxRequest(t,e){return{class:Se.FETCH_BOXES,modelId:t.modelId,localIds:e}}}class mu{constructor(){c(this,"_coordinationMatrices",new Map)}async getCoordinationMatrix(t){let e=this._coordinationMatrices.get(t.modelId);if(e)return e;e=new rt,this._coordinationMatrices.set(t.modelId,e);const[s,i,r,a,o,h,l,d,u]=await this.getCoordinates(t),p=new T(a,o,h),f=new T(l,d,u),m=new T().crossVectors(p,f);return e.set(a,l,m.x,s,o,d,m.y,i,h,u,m.z,r,0,0,0,1),e}async getCoordinates(t){const e=t.modelId;return t.threads.invoke(e,"getCoordinates")}async getPositions(t,e){const s=[e],i=await t.threads.invoke(t.modelId,"getPositions",s);return this.getAbsolutePositions(i,t)}getAbsolutePositions(t,e){const s=[];for(const i of t){const{x:r,y:a,z:o}=i,h=new T(r,a,o);h.applyMatrix4(e.object.matrixWorld),s.push(h)}return s}}class Cu extends Map{constructor(t,e){super(e),c(this,"tracker",null),c(this,"localId"),c(this,"guard",()=>!0),this.localId=t}get object(){const t={};for(const[e,s]of this.entries())t[e]=s.value;return t}set(t,e){if(!(this.guard??(()=>!0))(t,e))return this;const s=e.type!==void 0?e:{value:e.value,type:this.getType(t)};if(!this.tracker)return super.set(t,s);if(this.localId===null)return console.warn("Item attributes are missing a valid localId. Changes can't be tracked."),super.set(t,s);let i=this.tracker.get(this.localId);return i||(i={type:"modified",added:{},deleted:[],modified:{}},this.tracker.set(this.localId,i)),i.type==="added"?i.data[t]=s:i.type==="modified"&&(this.has(t)?i.modified[t]=s:i.deleted.includes(t)?(i.deleted=i.deleted.filter(r=>r!==t),i.modified[t]=s):i.added[t]=s),super.set(t,s)}setValue(t,e){return this.set(t,{value:e,type:this.getType(t)})}setType(t,e){const s=this.getValue(t);return s?this.set(t,{value:s,type:e}):this}delete(t){if(!this.tracker)return super.delete(t);const e=this.get("localId");if(e===void 0||typeof e!="number")return console.warn("Item attributes are missing a valid localId. Changes can't be tracked."),t!=="localId"&&super.delete(t);if(t==="localId"||!this.has(t))return!1;let s=this.tracker.get(e);return s||(s={type:"modified",added:{},deleted:[],modified:{}},this.tracker.set(e,s)),s.type==="added"?delete s.data[t]:s.type==="modified"&&(t in s.added?delete s.added[t]:(t in s.modified&&delete s.modified[t],s.deleted.push(t))),super.delete(t)}getValue(t){const e=this.get(t);return e?e.value:null}getType(t){var e;return(e=this.get(t))==null?void 0:e.type}}class gu extends Map{constructor(t,e){super(e),c(this,"tracker",null),c(this,"localId"),c(this,"guard",()=>!0),c(this,"onItemsRequested",null),this.localId=t}get itemChanges(){if(!this.tracker)return null;if(!this.localId)return console.warn("Item relations can't be tracked."),null;let t=this.tracker.get(this.localId);return t||(t={type:"modified",added:{},deleted:new Set,removed:{},modified:{}},this.tracker.set(this.localId,t)),t}set(t,e){const s=this.has(t);if(!(this.guard??(()=>!0))(t,e))return this;const i=this.itemChanges;return i?(s?i.modified[t]=e:i.added[t]=e,super.set(t,e)):super.set(t,e)}add(t,e){var s;const i=this.has(t);let r=this.get(t);if(!r)return r=new Set([e]),this.set(t,r),!0;if(!r||r.has(e))return!1;const a=this.itemChanges;if(!a)return r.add(e),!0;if(i)if((s=a.removed[t])!=null&&s.has(e))a.removed[t].delete(e),a.removed[t].size===0&&delete a.removed[t];else{let o=a.modified[t];o||(o=new Set,a.modified[t]=o),o.add(e)}else{let o=a.added[t];o||(o=new Set,a.added[t]=o),o.add(e)}return r.add(e),!0}remove(t,e){var s;const i=this.get(t);if(!i||!i.has(e))return!1;const r=this.itemChanges;if(!r)return i.delete(e);if((s=r.modified[t])!=null&&s.has(e))r.modified[t].delete(e),r.modified[t].size===0&&delete r.modified[t];else{let a=r.removed[t];a||(a=new Set,r.removed[t]=a),a.add(e)}return i.delete(e)}delete(t){if(!this.has(t))return!1;const e=this.itemChanges;return e?(e.deleted.add(t),super.delete(t)):super.delete(t)}async getItems(t){if(!this.onItemsRequested)return null;const e=this.get(t);return e?await this.onItemsRequested([...e]):null}}class Tu{constructor(t,e){c(this,"model"),c(this,"localId"),c(this,"_indices",null),c(this,"_transform",null),c(this,"_normals",null),c(this,"_positions",null),c(this,"_vertices",null),c(this,"_triangles",null),c(this,"_position",null),c(this,"_box",null),this.model=t,this.localId=e}async get(){const[t]=await this.model.threads.invoke(this.model.modelId,"getItemsGeometry",[[this.localId]]);for(const e of t){e.transform=new rt().fromArray(e.transform.elements);const{indices:s,normals:i,positions:r,transform:a}=e;this._indices||(this._indices=[]),this._normals||(this._normals=[]),this._positions||(this._positions=[]),this._transform||(this._transform=[]),this._indices.push(s),this._normals.push(i),this._positions.push(r),this._transform.push(a)}return t}async getIndices(){return this._indices!==null||await this.get(),this._indices}async getTransform(){return this._transform!==null||await this.get(),this._transform}async getNormals(){return this._normals!==null||await this.get(),this._normals}async getPositions(){return this._positions!==null||await this.get(),this._positions}async getVertices(){if(this._vertices)return this._vertices;const t=await this.getPositions(),e=await this.getTransform();if(!t||!e)return this._vertices;this._vertices=[];for(let s=0;s<t.length;s++){const i=t[s],r=e[s];if(!i||!r)continue;const a=[];this._vertices.push(a);const o=Object.keys(i).length/3,h=[];for(let l=0;l<o;l++){const d=i[3*l],u=i[3*l+1],p=i[3*l+2];if(typeof d!="number"||typeof u!="number"||typeof p!="number")continue;const f=`${d},${u},${p}`;if(h.includes(f))continue;h.push(f);const m=new T(d,u,p);m.applyMatrix4(r),a.push(m)}}return this._vertices}async getTriangles(){if(this._triangles)return this._triangles;const t=await this.getIndices(),e=await this.getPositions(),s=await this.getTransform();if(!t||!e||!s)return this._triangles;this._triangles=[];for(let i=0;i<t.length;i++){const r=t[i],a=e[i],o=s[i];if(!r||!a||!o)continue;const h=[];this._triangles.push(h);for(let l=0;l<r.length;l+=3){const d=r[l],u=r[l+1],p=r[l+2],f=new T(a[3*d],a[3*d+1],a[3*d+2]),m=new T(a[3*u],a[3*u+1],a[3*u+2]),b=new T(a[3*p],a[3*p+1],a[3*p+2]);f.applyMatrix4(o),m.applyMatrix4(o),b.applyMatrix4(o),h.push(new ji(f,m,b))}}return this._triangles}async getPosition(){if(!this._position){if(this.localId===null)return null;this._position=await this.model.getPositions([this.localId])}return this._position}async getBox(){if(!this._box){if(this.localId===null)return null;this._box=await this.model.getBoxes([this.localId])}return this._box}async setVisibility(t){await this.model.setVisible([this.localId],t)}async getVisibility(){const[t]=await this.model.getVisible([this.localId]);return t}}class Ru{constructor(t,e){c(this,"model"),c(this,"_localId",null),c(this,"_attributes",null),c(this,"_relations",null),c(this,"_guid",null),c(this,"_category",null),c(this,"_geometry",null),this.model=t,typeof e=="number"&&(this._localId=e),typeof e=="string"&&(this._guid=e)}async getLocalId(){if(!this._localId){if(!this._guid)throw new Error("Fragments: Item localId couldn't be get.");[this._localId]=await this.model.threads.invoke(this.model.modelId,"getLocalIdsByGuids",[[this._guid]])}return this._localId}async getAttributes(){if(this._attributes)return this._attributes;const t=await this.getLocalId();if(t===null)return null;const e=await this.model.threads.invoke(this.model.modelId,"getItemAttributes",[t]);if(this._attributes=new Cu(t),!e){const i=this.model.attrsChanges.get(t);if(!i||i.type!=="added")return null;this._attributes.localId=t;for(const[r,a]of Object.entries(i.data))this._attributes.set(r,a);return this._attributes}const s=this.model.attrsChanges.get(t);if(s&&s.type==="modified")for(const[i,r]of Object.entries(s.added))this._attributes.set(i,r);for(const i in e){const{value:r,type:a}=e[i];(s==null?void 0:s.type)==="modified"&&s.deleted.includes(i)||((s==null?void 0:s.type)==="modified"&&i in s.modified?this._attributes.set(i,s.modified[i]):this._attributes.set(i,{value:r,type:a}))}return this._attributes.tracker=this.model.attrsChanges,this._attributes}async getRelations(){if(this._relations)return this._relations;const t=await this.getLocalId();if(t===null)return null;const e=await this.model.threads.invoke(this.model.modelId,"getItemRelations",[t]);if(!e)return null;this._relations=new gu(t),this._relations.onItemsRequested=async i=>{const r=[];for(const a of i){const o=this.model.getItem(a);o&&r.push(o)}return r};const s=this.model.relsChanges.get(t);if(s&&s.type==="modified")for(const[i,r]of Object.entries(s.added))this._relations.set(i,r);for(const[i,r]of Object.entries(e))if((s==null?void 0:s.type)!=="modified"||!s.deleted.has(i))if((s==null?void 0:s.type)==="modified"&&i in s.modified){const a=new Set([...s.modified[i],...r]);this._relations.set(i,new Set(a))}else this._relations.set(i,new Set(r));return this._relations.tracker=this.model.relsChanges,this._relations}async getGuid(){if(!this._guid){const t=await this.getLocalId();if(t===null)return null;[this._guid]=await this.model.threads.invoke(this.model.modelId,"getGuidsByLocalIds",[[t]])}return this._guid}async getCategory(){if(!this._category){const t=await this.getLocalId();if(t===null)return null;this._category=await this.model.threads.invoke(this.model.modelId,"getItemCategory",[t])}return this._category}async getGeometry(){if(this._geometry)return this._geometry;const t=await this.getLocalId();return t===null?null:new Tu(this.model,t)}async getData(t=[]){var e;const s=await this.getLocalId();if(s==null)return{};t.push(s);const i=(e=await this.getAttributes())==null?void 0:e.object,r=await this.getRelations(),a={};if(r)for(const o of r.keys()){const h=[];a[o]=h;const l=await r.getItems(o);if(l)for(const d of l){const u=await d.getLocalId();if(!u||t.find(f=>f===u)!==void 0)continue;t.push(u);const p=await d.getData(t);p&&h.push(p)}}return{...i,...a}}}class Au{getItem(t,e){return new Ru(t,e)}async getItemsData(t,e,s){return t.threads.invoke(t.modelId,"getItemsData",[e,s])}async getItemsChildren(t,e){return t.threads.invoke(t.modelId,"getItemsChildren",[e])}}class wu{constructor(){c(this,"getClippingPlanesEvent",()=>[]),c(this,"_tempMatrix",new rt),c(this,"_tempVec",new T),c(this,"_tempFrustum",new ii),c(this,"_updateCameraPositionEvent",()=>{}),c(this,"_updateCameraFrustumEvent",()=>{}),c(this,"_updateFOVEvent",()=>{}),c(this,"_updateOrthoSizeEvent",()=>{})}async refreshView(t,e){const s=this.setup(e,t),i=Ms.transform(this._tempFrustum,this._tempMatrix),r=this.newViewRequest(i,s,t);await t.threads.fetch(r)}useCamera(t){const e=new rt;this.setCameraPosition(t),this.setCameraFrustum(t,e),this.setFov(t),this.setOrtho()}getOrthoSize(){let t=this._updateOrthoSizeEvent();return t&&(t*=this._tempMatrix.getMaxScaleOnAxis()),t}setup(t,e){return t.requests.clean(e.modelId),this._tempMatrix.copy(e.object.matrixWorld).invert(),this._updateCameraPositionEvent(this._tempVec),this._updateCameraFrustumEvent(this._tempFrustum),this._updateFOVEvent()}newViewRequest(t,e,s){const i=this.newView(t,e,s),r={};return r.class=Se.REFRESH_VIEW,r.modelId=s.modelId,r.cameraFrustum=t,r.view=i,r}newView(t,e,s){const i={};return i.cameraFrustum=t,i.cameraPosition=this._tempVec.applyMatrix4(this._tempMatrix),i.fov=e,i.orthogonalDimension=this.getOrthoSize(),i.viewSize=Math.max(window.innerWidth,window.innerHeight),i.graphicThreshold=Mo.estimateCapacity(),i.graphicQuality=-1.5*s.graphicsQuality+2,i.clippingPlanes=this.getPlanes(),i.modelPlacement=s.object.matrixWorld,i}setOrtho(){this._updateOrthoSizeEvent=()=>{}}setFov(t){this._updateFOVEvent=()=>{if(t instanceof Ol)return t.fov}}getPlanes(){const t=[],e=this.getClippingPlanesEvent();for(const s of e){const i=s.clone();i.applyMatrix4(this._tempMatrix),t.push(i)}return t}setCameraPosition(t){this._updateCameraPositionEvent=e=>{e.copy(t.position)}}setCameraFrustum(t,e){this._updateCameraFrustumEvent=s=>{t.updateProjectionMatrix(),t.updateWorldMatrix(!0,!0);const{projectionMatrix:i,matrixWorldInverse:r}=t;e.multiplyMatrices(i,r),s.setFromProjectionMatrix(e)}}}class Fu{constructor(){c(this,"_caster",new vl),c(this,"_ray",new si),c(this,"_frustum",new ii),c(this,"_inverseTransform",new rt),c(this,"_t",new Yt),c(this,"_r",new Yt),c(this,"_b",new Yt),c(this,"_l",new Yt),c(this,"_n",new Yt),c(this,"_f",new Yt),c(this,"_tl",new T),c(this,"_tr",new T),c(this,"_bl",new T),c(this,"_br",new T),c(this,"_tln",new T),c(this,"_brn",new T),c(this,"_tlp",new He),c(this,"_brp",new He),c(this,"distance",10)}async raycast(t,e){const{frustum:s,ray:i}=this.getRayAndFrustum(e),r=this.getRequest(t,s,i);if(!r)return null;const a=await t.threads.fetch(r);if(a.results&&a.results.length){const[o]=a.results;return this.getResult({hit:o,frustum:s,ray:i,model:t})}return null}async rectangleRaycast(t,e,s){const i=this.getFrustum(s),r=this.getRequest(t,i);if(!r)return null;r.fullyIncluded=s.fullyIncluded;const a=await t.threads.fetch(r);return a.localIds&&a.localIds.length?this.newRectangleCastResponse(a,e):null}async raycastWithSnapping(t,e){const{frustum:s,ray:i}=this.getRayAndFrustum(e),r=this.getRequest(t,s,i);if(!r)return null;r.snappingClass=e.snappingClasses;const a=await t.threads.fetch(r);return a.results?this.newRaycastSnapResult(a,s,i,t):null}screenRectToFrustum(t,e,s,i){return this.screenToCast(t,s,this._tlp),this.screenToCast(e,s,this._brp),this.setVectors(i),this.setPlanes(i),this.newFrustum()}screenToCasterPoint(t,e,s){const i=this.screenToCast(t,e);return this._caster.setFromCamera(i,s),this._caster.ray.clone()}setPlanes(t){this.setBasePoints(),t.getWorldDirection(this._n.normal),this.setEnds(t)}setVectors(t){this.setVector(this._tl,this._tlp,this._tlp,1,t),this.setVector(this._tr,this._brp,this._tlp,1,t),this.setVector(this._bl,this._tlp,this._brp,1,t),this.setVector(this._br,this._brp,this._brp,1,t),this.setVector(this._tln,this._tlp,this._tlp,0,t),this.setVector(this._brn,this._brp,this._brp,0,t)}newFrustum(){return new ii(this._t,this._b,this._l,this._r,this._f,this._n)}setEnds(t){this._n.constant=t.position.length(),this._f.normal=this._n.normal,this._f.constant=1/0}screenToCast(t,e,s=new He){const i=e.getBoundingClientRect(),r=i.width/e.clientWidth,a=i.height/e.clientHeight,o=(t.x-i.left)/r,h=(t.y-i.top)/a;return s.x=o/e.clientWidth*2-1,s.y=-h/e.clientHeight*2+1,s}setVector(t,e,s,i,r){t.set(e.x,s.y,i),t.unproject(r)}setPlane(t,e,s,i){t.setFromCoplanarPoints(e,s,i)}setBasePoints(){this.setPlane(this._t,this._tln,this._tl,this._tr),this.setPlane(this._r,this._brn,this._tr,this._br),this.setPlane(this._b,this._brn,this._br,this._bl),this.setPlane(this._l,this._tln,this._bl,this._tl)}setupRay(t,e){t&&(this._ray.copy(t),this._ray.applyMatrix4(this._inverseTransform),e.ray=this._ray)}setupMatrix(t){this._inverseTransform.copy(t.matrixWorld),this._inverseTransform.invert()}getRequest(t,e,s){const{object:i,box:r,modelId:a}=t;return e.intersectsBox(r)?this.newCastRequest(i,a,s,e):null}getRayAndFrustum(t){this.updateCamera(t.camera);const{bottomLeft:e,topRight:s}=this.getCorners(t.mouse);return{ray:this.screenToCasterPoint(t.mouse,t.dom,t.camera),frustum:this.screenRectToFrustum(e,s,t.dom,t.camera)}}getFrustum(t){return this.updateCamera(t.camera),this.screenRectToFrustum(t.topLeft,t.bottomRight,t.dom,t.camera)}getCorners(t){return{bottomLeft:t.clone().subScalar(this.distance),topRight:t.clone().addScalar(this.distance)}}getResult(t){const{hit:e,frustum:s,ray:i,model:r}=t,a={};return this.setPoint(r,e,a),this.setNormal(r,e,a),this.setDistance(r,e,a),this.setRayDistance(r,e,a),this.setBasicHitData(r,e,a,i,s),this.setSnapEdge(r,e,a,"snappedEdgeP1"),this.setSnapEdge(r,e,a,"snappedEdgeP2"),a.facePoints=e.facePoints,a.faceIndices=e.faceIndices,a}updateCamera(t){t.updateProjectionMatrix(),t.updateWorldMatrix(!0,!0)}newCastRequest(t,e,s,i){this.setupMatrix(t);const r={};return r.class=Se.RAYCAST,r.modelId=e,this.setupRay(s,r),Ms.transform(i,this._inverseTransform,this._frustum),r.frustum=this._frustum,r}setSnapEdge(t,e,s,i){if(e[i]){const r=new T;r.copy(e[i]),r.applyMatrix4(t.object.matrixWorld),s[i]=r}else s[i]=void 0}setNormal(t,e,s){if(e.normal){const i=new T;return i.copy(e.normal),i.transformDirection(t.object.matrixWorld),i.normalize(),void(s.normal=i)}s.normal=void 0}setDistance(t,e,s){const i=Math.sqrt(e.cameraSquaredDistance),r=t.object.matrixWorld.getMaxScaleOnAxis();s.distance=i*r}setPoint(t,e,s){const i=new T;i.copy(e.point),i.applyMatrix4(t.object.matrixWorld),s.point=i}newRaycastSnapResult(t,e,s,i){const r=[];for(const a of t.results){const o=this.getResult({hit:a,frustum:e,ray:s,model:i});r.push(o)}return r}newRectangleCastResponse(t,e){return{localIds:t.localIds,fragments:e.list.get(t.modelId)}}setRayDistance(t,e,s){if(e.raySquaredDistance===void 0)s.rayDistance=void 0;else{const i=t.object.matrixWorld.getMaxScaleOnAxis(),r=Math.sqrt(e.raySquaredDistance);s.rayDistance=r*i}}setBasicHitData(t,e,s,i,r){s.itemId=e.itemId,s.localId=e.localId,s.object=t.object,s.fragments=t,s.ray=i,s.frustum=r,s.representationClass=e.representationClass,s.snappingClass=e.snappingClass}}class Su{async resetVisible(t){await t.threads.invoke(t.modelId,"resetVisible")}async getItemsByVisibility(t,e){return t.threads.invoke(t.modelId,"getItemsByVisibility",[e])}async getVisible(t,e){return t.threads.invoke(t.modelId,"getVisible",[e])}}class $n{}c($n,"vertex",`
            #include <common>
            #include <clipping_planes_pars_vertex>

            attribute float itemFilter;
            uniform vec2 lodSize;
            attribute vec3 itemFirst;
            attribute vec3 itemLast;

            float lodWidth = 2.0;
            
            void cutLodLine(const in vec4 first, inout vec4 second ) {
                float projValue1 = projectionMatrix[2][2];
                float projValue2 = projectionMatrix[3][2];
                float approxResult = -(projValue2 / projValue1) / 2.0;
                float diff1 = approxResult - first.z;
                float diff2 = second.z - first.z;
                float cutFilter = diff1 / diff2;
                second.xyz = mix(first.xyz, second.xyz, cutFilter);
            }
                
            void main() {
                if (itemFilter == 0.0) {
                    gl_Position = vec4(0,0,0,0);
                    return;
                }

                vec4 rawFirst = vec4(itemFirst, 1.0);
                vec4 rawLast = vec4(itemLast, 1.0);
                vec4 first = modelViewMatrix * rawFirst;
                vec4 last = modelViewMatrix * rawLast;
                
                bool lodPerspective = projectionMatrix[2][3] == -1.0;
                if (lodPerspective) {
                    bool firstCut = first.z < 0.0 && last.z >= 0.0;
                    bool lastCut = last.z < 0.0 && first.z >= 0.0;
                    if (firstCut) {
                        cutLodLine( first, last );
                    } else if (lastCut) {
                        cutLodLine( last, first );
                    }
                }

                vec4 firstCut = projectionMatrix * first;
                vec4 lastCut = projectionMatrix * last;
                vec3 firstNdc = firstCut.xyz / firstCut.w;
                vec3 lastNdc = lastCut.xyz / lastCut.w;

                vec2 lodOrientation = lastNdc.xy - firstNdc.xy;

                float lodRatio = lodSize.x / lodSize.y;
                lodOrientation.x *= lodRatio;
                lodOrientation = normalize(lodOrientation);
                
                vec2 lodDistance = vec2(lodOrientation.y, - lodOrientation.x);
                lodOrientation.x /= lodRatio;
                lodDistance.x /= lodRatio;

                if (position.x < 0.0) { 
                    lodDistance *= - 1.0;
                }

                if (position.y < 0.0) {
                    lodDistance += -lodOrientation;
                } else if (position.y > 1.0) {
                    lodDistance += lodOrientation;
                }

                lodDistance *= lodWidth;
                lodDistance /= lodSize.y;

                bool isFirst = position.y < 0.5;
                vec4 lodPosition = isFirst ? firstCut : lastCut;
                lodDistance *= lodPosition.w;
                lodPosition.xy += lodDistance;
                gl_Position = lodPosition;

                vec4 mvPosition = isFirst ? first : last;
                #include <clipping_planes_vertex>
            }
    `),c($n,"fragment",`
            #include <common>
            #include <clipping_planes_pars_fragment>

            uniform vec3 lodColor;
            uniform float lodOpacity;

            void main() {
                #include <clipping_planes_fragment>
                gl_FragColor = vec4(lodColor, lodOpacity);
                #include <colorspace_fragment>
            }
    `);const Ai=class cs{static setupLodMeshResize(t){t.onBeforeRender=e=>{e.getSize(t.material[0].lodSize)}}static setupLodAttributes(t){t.setIndex(cs.indices),t.setAttribute("position",cs.vertices)}static setLodBuffer(t,e,s){let i=t.getItemFirst(),r=t.getItemLast(),a=this.setItemFirst(t,i,e,r);({itemFirst:i,dataBuffer:a,itemLast:r}=this.resetAttributes(i,a,e,r)),this.setupFinish(s,a),t.setAttribute("itemFirst",i),t.setAttribute("itemLast",r)}static setLodVisibility(t,e){const s=this.setupItemFilter(t);this.applyVisibilityState(t,e,s),s.needsUpdate=!0}static getInterAttribute(t,e){return t.getAttribute(e)}static computeLodSphere(t){if(!t.boundingSphere)return;const e=t.getItemFirst();if(e){const s=cs.getLodMidPoint(t,e),i=cs.getLodRadius(s,e);t.boundingSphere.radius=i}}static newLodMaterialParams(t){const e={lodColor:{value:new Wi(t.color)},lodSize:{value:new He(1,1)},lodOpacity:{value:t.opacity??1}};return{uniforms:aa.merge([Ii.common,e]),transparent:t.transparent??!1,vertexShader:$n.vertex,fragmentShader:$n.fragment}}static setLodFilter(t,e){const s=t.getItemFilter(),i=s.array;for(let r=0;r<e.position.length;++r){const a=e.position[r]/2,o=e.size[r]/2;o===4294967295?i.fill(1,a):i.fill(1,a,a+o)}s.needsUpdate=!0}static getInstancedAttribute(t,e){return t.getAttribute(e)}static computeLodBox(t){if(!t.boundingBox)return;const e=t.getItemFirst();if(e){const s=e.data.array;t.boundingBox.setFromArray(s)}else t.boundingBox.makeEmpty()}static setDataBuffer(t,e,s){return(t=e.data).array=s,t.needsUpdate=!0,t}static disposeAllData(t){delete t.attributes.itemFilter,delete t.attributes.position,t.index=null,t.dispose(),cs.setupLodAttributes(t)}static setItemFirst(t,e,s,i){let r=null;return e&&(s.length===e.data.array.length?r=this.setDataBuffer(r,e,s):(e=void 0,this.disposeAllData(t))),r}static setupFinish(t,e){t&&(e.onUploadCallback=t)}static resetAttributes(t,e,s,i){return t||(e=new Wn(s,6,1),t=new Is(e,3,0),i=new Is(e,3,3)),{itemFirst:t,dataBuffer:e,itemLast:i}}static setupItemFilter(t){const e=t.getItemFirst().count;let s=t.getItemFilter();return s?s.array.fill(0):(s=new Al(new Uint8Array(e),1),t.setAttribute("itemFilter",s)),s}static applyVisibilityState(t,e,s){e!==!0?e&&this.setLodFilter(t,e):s.array.fill(1)}static getLodMidPoint(t,e){const s=t.boundingSphere.center;return this.tempBox.setFromArray(e.data.array),this.tempBox.getCenter(s),s}static getLodRadius(t,e){let s=0;const i=e.data.array.length;for(let r=0;r<i;r+=3){const a=e.data.array;cs.tempVec.fromArray(a,r);const o=t.distanceToSquared(cs.tempVec);s=Math.max(s,o)}return Math.sqrt(s)}};c(Ai,"tempVec",new T),c(Ai,"tempBox",new Et),c(Ai,"vertices",new Nr([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),c(Ai,"indices",new Rl([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5],1));let we=Ai;class Da extends oa{constructor(t,e){super(t,e),c(this,"geometry"),c(this,"material"),this.geometry=t,this.material=e,we.setupLodMeshResize(this)}}class yu extends mo{constructor(){super(),c(this,"isLODGeometry",!0),we.setupLodAttributes(this)}isFiltered(){return!!this.getItemFilter()}computeBoundingBox(){this.boundingBox||(this.boundingBox=new Et),we.computeLodBox(this)}applyMatrix4(t){return this.applyTransformToBuffers(t),this.updateBounds(),this}computeBoundingSphere(){this.boundingSphere||(this.boundingSphere=new rn),we.computeLodSphere(this)}getItemFilter(){return we.getInstancedAttribute(this,"itemFilter")}getItemLast(){return we.getInterAttribute(this,"itemLast")}getItemFirst(){return we.getInterAttribute(this,"itemFirst")}applyTransformToBuffers(t){this.getItemFirst().applyMatrix4(t),this.getItemLast().applyMatrix4(t)}updateBounds(){this.boundingBox&&this.computeBoundingBox(),this.boundingSphere&&this.computeBoundingSphere()}}class xu extends Eo{constructor(t){super(we.newLodMaterialParams(t)),c(this,"isLodMaterial",!0),c(this,"isLineMaterial",!0),this.clipping=!0,this.lights=!1,this.needsUpdate=!0}get lodSize(){return this.uniforms.lodSize.value}set lodColor(t){this.uniforms.lodColor.value=t}set lodSize(t){this.uniforms.lodSize.value.copy(t)}get lodColor(){return this.uniforms.lodColor.value}}class pa{constructor(){c(this,"list",new ca),c(this,"_modelMaterialMapping",new Map),c(this,"_definitions",new Map),c(this,"_idGenerator",new fa),c(this,"white",4294967295)}static resetColors(t){for(const e of t){if(!e||!e.color)continue;const{color:s}=e;if(s.isColor)continue;const{r:i,g:r,b:a}=s;e.color=new Wi(i,r,a)}}dispose(t){this._definitions.delete(t);const e=this._modelMaterialMapping.get(t);if(e){for(const s of e){const i=this.list.get(s);i&&(i.dispose(),this.list.delete(s))}this._modelMaterialMapping.delete(t)}}get(t,e){const{modelId:s,objectClass:i,currentLod:r,templateId:a}=e;if(!s||i===void 0||r===void 0)throw new Error("Fragments: material definition information is missing to create the material.");this._idGenerator.fromMaterialData({modelId:s,objectClass:i,currentLod:r,templateId:a,...t});const{value:o}=this._idGenerator;return this.getUniqueMaterial(o,t,e)}addDefinitions(t,e){const s=this._definitions.get(t);s?s.push(...e):this._definitions.set(t,e)}createHighlights(t,e){const{tileData:{highlightData:s,highlightIds:i},modelId:r,material:a}=e,{geometry:o}=t,h=t.material.slice(0,2),l=new Map,d=this._definitions.get(r);if(!d)return h;for(let u=0;u<s.position.length;u++){const p=i[u];this.processHighlight(l,p,d,a,e,h);const f=s.position[u],m=s.size[u],b=m===this.white?1/0:m;o.addGroup(f,b,l.get(i[u]))}return h}getFromRequest(t){const{material:e,modelId:s}=t,i=this._definitions.get(s),r=i==null?void 0:i[e];if(!r)throw new Error(`Fragments: Missing mesh material for index ${e}`);return this.get(r,t)}newLODMaterial(t,e){const{data:s}=t,i=new Wi(s.color);e.currentLod===Y.WIRES&&i.multiplyScalar(.85);const r={color:i,...this.getParameters(s)},a=new xu(r);return a.userData={customId:s.customId},a}getParameters(t){const{opacity:e,transparent:s}=t;return{opacity:e,transparent:s||e<1,clipIntersection:!1}}new(t,e){const{objectClass:s,templateId:i}=e;let r;if(s===Wt.SHELL)r=new xl({color:t.color,transparent:t.opacity<1,opacity:t.opacity,userData:{customId:t.customId},depthTest:t.depthTest??!0});else{if(s!==Wt.LINE)throw new Error("Fragments: Unsupported object class");r=this.newLODMaterial({data:t,instancing:i!==void 0},e)}return r}addMaterialToModel(t,e){let s=this._modelMaterialMapping.get(t);s||(s=new Set,this._modelMaterialMapping.set(t,s)),s.add(e)}processHighlight(t,e,s,i,r,a){if(!t.has(e)){const o={...s[i],...s[e]},h=this.get(o,r);a.push(h),t.set(e,a.length-1)}}getUniqueMaterial(t,e,s){const i=s.modelId;let r=this.list.get(t);return r||(r=this.new(e,s),this.list.set(t,r),this.addMaterialToModel(i,t),r)}}class Ou{async getHighlight(t,e){const s=await t.threads.invoke(t.modelId,"getHighlight",[e]);return pa.resetColors(s),s}async highlight(t,e,s){await t.threads.invoke(t.modelId,"highlight",[e,s])}async getHighlightItemIds(t){return t.threads.invoke(t.modelId,"getHighlightItemIds")}async resetHighlight(t,e){await t.threads.invoke(t.modelId,"resetHighlight",[e])}}class vu{async getSection(t,e,s){const i=[e,s];return await t.threads.invoke(t.modelId,"getSection",i)}}class Lu{async dispose(t,e,s){e.list.delete(t.modelId),await this.requestModelDelete(t),t.threads.delete(t.modelId),this.deleteAllTiles(t),e.materials.dispose(t.modelId),s.dispose()}async getBuffer(t,e){return t.threads.invoke(t.modelId,"getBuffer",[e])}async getCategories(t){return t.threads.invoke(t.modelId,"getCategories")}async getMaxLocalId(t){return t.threads.invoke(t.modelId,"getMaxLocalId")}async getLocalIdsByGuids(t,e){return t.threads.invoke(t.modelId,"getLocalIdsByGuids",[e])}async getSpatialStructure(t){return t.threads.invoke(t.modelId,"getSpatialStructure")}async getItemsWithGeometry(t){return(await t.threads.invoke(t.modelId,"getItemsWithGeometry",[])).map(e=>t.getItem(e))}async getItemsWithGeometryCategories(t){return t.threads.invoke(t.modelId,"getItemsWithGeometryCategories",[])}async getItemsIdsWithGeometry(t){return t.threads.invoke(t.modelId,"getItemsWithGeometry",[])}async getItemsOfCategories(t,e){const s=[e];return await t.threads.invoke(t.modelId,"getItemsOfCategories",s)}async getItemsByQuery(t,e){const s=[e];return await t.threads.invoke(t.modelId,"getItemsByQuery",s)}async getMetadata(t){return t.threads.invoke(t.modelId,"getMetadata",[])}async getGuidsByLocalIds(t,e){return t.threads.invoke(t.modelId,"getGuidsByLocalIds",[e])}async requestModelDelete(t){await t.threads.fetch({class:Se.DELETE_MODEL,modelId:t.modelId})}deleteAllTiles(t){for(const[e]of t.tiles)t.tiles.delete(e)}}class Nu{async getSequenced(t,e,s,i){const r=[e,s,i];return await t.threads.invoke(t.modelId,"getSequenced",r)}}class Pu{constructor(t,e,s){c(this,"attrsChanges",new Map),c(this,"relsChanges",new Map),c(this,"threads"),c(this,"tiles",new ca),c(this,"object",new Mr),c(this,"graphicsQuality",0),c(this,"_boxManager",new Eu),c(this,"_itemsManager",new Au),c(this,"_coordinatesManager",new mu),c(this,"_setupManager",new _u),c(this,"_viewManager",new wu),c(this,"_raycastManager",new Fu),c(this,"_visibilityManager",new Su),c(this,"_highlightManager",new Ou),c(this,"_sectionManager",new vu),c(this,"_dataManager",new Lu),c(this,"_sequenceManager",new Nu),c(this,"_bbox",new Et),c(this,"_alignmentsManager"),c(this,"_meshManager"),c(this,"_isProcessing",!1),c(this,"_isLoaded",!1),c(this,"_frozen",!1),c(this,"_isSetup",!1),this.object.name=t,this.object.up.set(0,0,1),this._meshManager=e,this.threads=s,this._alignmentsManager=new Iu(this),this.tiles.onItemSet.add(({value:i})=>this.object.add(i)),this.tiles.onBeforeDelete.add(({value:i})=>{this.object.remove(i),i.geometry.dispose(),Ae.forEach(i.material,r=>r.dispose())})}get modelId(){return this.object.name}get box(){return this._bbox.clone().applyMatrix4(this.object.matrixWorld)}get isBusy(){const t=this._meshManager.requests.arePending;return!this._isLoaded||this._isProcessing||t}get frozen(){return!!this._frozen}set frozen(t){t!==this._frozen&&(this._frozen=t,t||this._refreshView())}get getClippingPlanesEvent(){return this._viewManager.getClippingPlanesEvent}set getClippingPlanesEvent(t){this._viewManager.getClippingPlanesEvent=t}async dispose(){this._isLoaded=!1,await this._dataManager.dispose(this,this._meshManager,this._alignmentsManager)}async getSpatialStructure(){return this._dataManager.getSpatialStructure(this)}async getLocalIdsByGuids(t){return this._dataManager.getLocalIdsByGuids(this,t)}async getCategories(){return this._dataManager.getCategories(this)}async getItemsWithGeometryCategories(){return this._dataManager.getItemsWithGeometryCategories(this)}async getItemsWithGeometry(){return this._dataManager.getItemsWithGeometry(this)}async getItemsIdsWithGeometry(){return this._dataManager.getItemsIdsWithGeometry(this)}async getMetadata(){return this._dataManager.getMetadata(this)}async getGuidsByLocalIds(t){return this._dataManager.getGuidsByLocalIds(this,t)}async getBuffer(t=!1){return this._dataManager.getBuffer(this,t)}async getItemsOfCategories(t){return this._dataManager.getItemsOfCategories(this,t)}async getGuids(){return await this.threads.invoke(this.modelId,"getGuids",[])}async getLocalIds(){return await this.threads.invoke(this.modelId,"getLocalIds",[])}async getItemsByQuery(t){return this._dataManager.getItemsByQuery(this,t)}async getItemsMaterialDefinition(t){return await this.threads.invoke(this.modelId,"getItemsMaterialDefinition",[t])}async getItemsGeometry(t){return await this.threads.invoke(this.modelId,"getItemsGeometry",[t])}async getItemsVolume(t){return await this.threads.invoke(this.modelId,"getItemsVolume",[t])}async getAttributeNames(){return await this.threads.invoke(this.modelId,"getAttributeNames",[])}async getAttributeValues(){return await this.threads.invoke(this.modelId,"getAttributeValues",[])}async getAttributesUniqueValues(t){return await this.threads.invoke(this.modelId,"getAttributesUniqueValues",[t])}async getAttributeTypes(){return await this.threads.invoke(this.modelId,"getAttributeTypes",[])}async getRelationNames(){return await this.threads.invoke(this.modelId,"getRelationNames",[])}async getMaxLocalId(){return this._dataManager.getMaxLocalId(this)}getItem(t){return this._itemsManager.getItem(this,t)}async getItemsChildren(t){return this._itemsManager.getItemsChildren(this,t)}async getItemsData(t,e){return this._itemsManager.getItemsData(this,t,e)}async getPositions(t){return this._coordinatesManager.getPositions(this,t)}async getCoordinates(){return this._coordinatesManager.getCoordinates(this)}async getCoordinationMatrix(){return this._coordinatesManager.getCoordinationMatrix(this)}async getMergedBox(t){return this._boxManager.getMergedBox(this,t)}async getBoxes(t){return this._boxManager.getBoxes(this,t)}async getAlignments(){return this._alignmentsManager.getAlignments()}async getHorizontalAlignments(){return this._alignmentsManager.getHorizontalAlignments()}async getVerticalAlignments(){return this._alignmentsManager.getVerticalAlignments()}getAlignmentStyles(){return this._alignmentsManager.getAlignmentStyles()}useCamera(t){this._viewManager.useCamera(t)}async rectangleRaycast(t){return this._raycastManager.rectangleRaycast(this,this._meshManager,t)}async raycast(t){return this._raycastManager.raycast(this,t)}async raycastWithSnapping(t){return this._raycastManager.raycastWithSnapping(this,t)}async setVisible(t,e){const s=[t,e];await this.threads.invoke(this.modelId,"setVisible",s)}async toggleVisible(t){const e=[t];await this.threads.invoke(this.modelId,"toggleVisible",e)}async getItemsByVisibility(t){return this._visibilityManager.getItemsByVisibility(this,t)}async getVisible(t){return this._visibilityManager.getVisible(this,t)}async resetVisible(){return this._visibilityManager.resetVisible(this)}async highlight(t,e){return this._highlightManager.highlight(this,t,e)}async getHighlight(t){return this._highlightManager.getHighlight(this,t)}async resetHighlight(t){return this._highlightManager.resetHighlight(this,t)}async getHighlightItemIds(){return this._highlightManager.getHighlightItemIds(this)}async getSection(t,e){return this._sectionManager.getSection(this,t,e)}async getSequenced(t,e,s){return this._sequenceManager.getSequenced(this,t,e,s)}async handleRequest(t){await this._meshManager.requests.handleRequest(this._meshManager,t)}_finishProcessing(){this._isProcessing=!1}async _refreshView(){this.frozen||(this._isProcessing=!0,await this._viewManager.refreshView(this,this._meshManager))}async _setup(t,e,s){this._isSetup||(this._setupManager.setup(this,this._bbox,t,e,s),this._isLoaded=!0,this._isProcessing=!0,this._isSetup=!0)}}class Mu{constructor(){c(this,"list",[]),c(this,"onFinish",()=>{})}get arePending(){return this.list.length>0}async handleRequest(t,e){if(e.class===Se.RECOMPUTE_MESHES)this.add(e.list),e.list=void 0;else if(e.class===Se.CREATE_MATERIAL){const{materialDefinitions:s,modelId:i}=e;pa.resetColors(s),t.materials.addDefinitions(i,s),e.materialDefinitions=void 0}else e.class===Se.THROW_ERROR&&console.error(e)}add(t){for(const e of t)this.insert(e)||this.list.push(e),e.tileRequestClass===_t.FINISH&&this.onFinish()}clean(t){const e=this.list.filter(s=>s.modelId!==t||s.tileRequestClass!==_t.FINISH);this.list=e}insert(t){const{modelId:e,tileId:s,tileRequestClass:i,tileData:r}=t;if(s===void 0)return!1;if(i===_t.DELETE){const a=this.list.filter(o=>!((o.tileRequestClass===_t.CREATE||o.tileRequestClass===_t.DELETE)&&o.modelId===e&&o.tileId===s));this.list=a}if(i===_t.CREATE){const a=this.list.filter(o=>!(o.tileRequestClass===_t.CREATE&&o.modelId===e&&o.tileId===s));this.list=a}if(i===_t.UPDATE){const a=this.list.find(o=>o.modelId===e&&o.tileId===s);if(a)return a.tileRequestClass!==_t.CREATE&&a.tileRequestClass!==_t.UPDATE||(a.tileData=r),!0}return!1}}class Du{constructor(t){c(this,"_materials"),c(this,"white",4294967295),this._materials=t}createMesh(t,e){const s=this._materials.getFromRequest(e);if(!("isLodMaterial"in s)||!s.isLodMaterial)throw new Error("Fragments: material is not an instance of LodMaterial.");const{positions:i}=e;if(!i)throw new Error("Fragments: no positions provided to create the LOD mesh.");const r=new yu,a=this.deleteAttributeEvent(t);return we.setLodBuffer(r,i,a),new Da(r,[s])}updateVisibility(t,e){const{geometry:s}=t,{visibilityData:i,highlightData:r}=e;we.setLodVisibility(s,i),r?(we.setLodFilter(s,r),Ri.getComplementary(r,(a,o)=>{s.addGroup(a,o,0)})):s.addGroup(0,1/0,0)}processMesh(t,e){const{geometry:s}=t,{tileData:{visibilityData:i},currentLod:r}=e;if(r===Y.WIRES&&t instanceof Da)this.updateVisibility(t,e.tileData);else if(i&&i.position.length>0)for(let a=0;a<i.position.length;++a){const o=i.size[a]===this.white,h=i.position[a],l=o?1/0:i.size[a];s.addGroup(h,l,0)}}deleteAttributeEvent(t){return function(){delete this.array}}}class Uu{constructor(t){c(this,"list",new ca),c(this,"materials",new pa),c(this,"lod",new Du(this.materials)),c(this,"requests",new Mu),c(this,"updateThreshold",4),c(this,"_updateFinished",!0),c(this,"_onUpdate"),this._onUpdate=t,this.requests.onFinish=()=>this._updateFinished=!0}forceUpdateFinish(t=200){return new Promise(e=>{this._updateFinished=!1;const s=setInterval(()=>{this.update(),this._updateFinished&&(clearInterval(s),e())},t)})}update(){const t=performance.now();for(;this.requests.arePending;){const e=this.requests.list.shift();if(e&&(this.processTileRequest(e),this._onUpdate(),performance.now()-t>this.updateThreshold))return}}setTileData(t,e){const{tileId:s,itemId:i,matrix:r,aabb:a}=e;this.setMeshData(t,s,i,r),this.setupBoundings(t,a),this.updateStatus(t,e)}processTileRequest(t){const{tileRequestClass:e,tileId:s,modelId:i}=t,r=this.list.get(i);if(r)if(e===_t.CREATE){const a=this.create(t);this.setTileData(a,t),r.tiles.set(a.userData.tileId,a)}else if(e===_t.DELETE)r.tiles.delete(s);else if(e===_t.UPDATE){const a=r.tiles.get(s);a&&this.updateStatus(a,t)}else e===_t.FINISH&&r._finishProcessing()}createMesh(t){const{indices:e,positions:s,normals:i,itemIds:r,faceIds:a}=t,o=new Pr;this.setIndex(o,e),this.setPositions(s,o),this.setNormals(i,o),this.setItemIds(r,o),this.setFaceIds(a,o);const h=this.materials.getFromRequest(t);return new oa(o,[h])}setupBoundings(t,e){const{geometry:s}=t,i=new Et().copy(e),r=new rn;i.getBoundingSphere(r),s.boundingBox=i,s.boundingSphere=r}create(t){if(t.objectClass===Wt.SHELL)return this.createMesh(t);if(t.objectClass===Wt.LINE){const e=new Pr;return this.lod.createMesh(e,t)}throw new Error(`Fragments: object class ${t.objectClass} is not supported.`)}updateStatus(t,e){const{tileData:{highlightData:s},currentLod:i}=e,{geometry:r}=t;if(r.clearGroups(),this.lod.processMesh(t,e),!s||i===Y.WIRES)return;const a=this.materials.createHighlights(t,e);t.material=a}cleanAttributeMemory(t,e){t.attributes[e].onUpload(this.deleteAttribute(t))}setPositions(t,e){if(!t)throw new Error("Fragments: no positions provided to create the mesh.");e.setAttribute("position",new Gs(t,3)),this.cleanAttributeMemory(e,"position")}setFaceIds(t,e){t&&(e.setAttribute("color",new Gs(t,3)),this.cleanAttributeMemory(e,"color"))}setIndex(t,e){if(!e)throw new Error("Fragments: no indices provided to create the mesh.");t.setIndex(new Gs(e,1)),t.index.onUpload(this.deleteAttribute(t))}setNormals(t,e){t&&e.setAttribute("normal",new Gs(t,3,!0)),this.cleanAttributeMemory(e,"normal")}setItemIds(t,e){t&&(e.setAttribute("id",new Gs(t,1,!1)),this.cleanAttributeMemory(e,"id"))}deleteAttribute(t){return function(){delete this.array}}setMeshData(t,e,s,i){t.userData={tileId:e,itemId:s},t.matrixAutoUpdate=!1,t.applyMatrix4(i),t.matrix.copy(i)}}class Vu{constructor(){c(this,"_list",new Map),c(this,"_communicationKey",0)}setupInput(t){t.requestId=this._communicationKey++}set(t,e,s){const i=this.newHandler(e,s);this._list.set(t,i)}run(t){const e=this._list.get(t.requestId);this._list.delete(t.requestId),e(t)}newHandler(t,e){return s=>{s.errorInfo?t(s.errorInfo):e(s)}}}class wt{static newThread(t){return new Worker(t,{type:"module"})}static newUpdater(t,e){return setInterval(t,e)}static getMeshComputeRequest(t,e){return{class:Se.RECOMPUTE_MESHES,modelId:t,list:e}}static planeSet(t){const e=[];for(const s of t){const i=this.array(s.normal),r=s.constant,a=new Yt(i,r);e.push(a)}return e}static data(t){var e,s;if((t==null?void 0:t.elements)!==void 0)return wt.transform(t);if((t==null?void 0:t.origin)!==void 0&&(t==null?void 0:t.direction)!==void 0)return wt.beam(t);if((t==null?void 0:t.planes)!==void 0)return wt.frustum(t);const i=(t==null?void 0:t.normal)!==void 0,r=(t==null?void 0:t.constant)!==void 0;if(i&&r)return wt.plane(t);const a=((e=t[0])==null?void 0:e.normal)!==void 0,o=((s=t[0])==null?void 0:s.constant)!==void 0;if(a&&o)return wt.planeSet(t);const h=(t==null?void 0:t.x)!==void 0,l=(t==null?void 0:t.y)!==void 0,d=(t==null?void 0:t.z)!==void 0;return h&&l&&d?wt.array(t):t}static getExecuteRequest(t,e,s){const i=Array.from(s);return{class:Se.EXECUTE,modelId:t,function:e,parameters:i}}static plane(t){const e=this.array(t.normal),s=t.constant;return new Yt(e,s)}static getRequestContent(t){const e=[];for(const s of t.list)wt.setupCreateRequest(s,e),wt.setupUpdateRequest(s,e);return e}static array(t){const e=new T;return e.set(t.x,t.y,t.z),e}static cleanRequests(t){const e=[],s=wt;for(const i of t)s.isFinishRequest(i)||e.push(i);return e}static frustum(t){const e=this.planeSet(t.planes),[s,i,r,a,o,h]=e;return new ii(s,i,r,a,o,h)}static beam(t){const e=this.array(t.origin),s=this.array(t.direction);return new si(e,s)}static transform(t){const e=new rt;return e.copy(t),e}static deleteUpdater(t){clearInterval(t)}static areCoresAvailable(t){const e=wt.getCpuCapacity();return t<Math.max(e,2)}static isFinishRequest(t){return t.tileRequestClass===_t.FINISH}static setupUpdateRequest(t,e){t.tileRequestClass===_t.UPDATE&&this.addAllTileData(t,e)}static getCpuCapacity(){var t;return(t=globalThis.navigator)!=null&&t.hardwareConcurrency?navigator.hardwareConcurrency-3:0}static addAllTileData(t,e){this.addRequestTileData(t,e,"visibilityData"),this.addRequestTileData(t,e,"highlightData",["highlightIds"])}static addRequestContent(t,e,s){if(!e[t])return;const i=e[t].buffer;s.push(i)}static addRequestTileData(t,e,s,i=[]){const r=t.tileData[s];if(r){e.push(r.position.buffer),e.push(r.size.buffer);for(const a of i)e.push(t.tileData[a].buffer)}}static setupCreateRequest(t,e){if(t.tileRequestClass!==_t.CREATE)return;const s=this.getCreateRequestIds();for(const i of s)this.addRequestContent(i,t,e);this.addAllTileData(t,e)}static getCreateRequestIds(){return["positions","indices","normals","itemIds"]}}class Bu{constructor(t){c(this,"_handlers",new Vu),c(this,"_handleInput"),c(this,"_port"),c(this,"onInput",e=>{e.data.toMainThread?this._handlers.run(e.data):this.manageInput(e.data)}),this._handleInput=t}fetchMeshCompute(t,e){const s=wt,i=s.getMeshComputeRequest(t,e),r=s.getRequestContent(i);this.fetch(i,r)}fetch(t,e){return this._handlers.setupInput(t),new Promise((s,i)=>{this._handlers.set(t.requestId,i,s),this.executeConnection(t,e)})}init(t){this._port=t,this.initConnection(t)}initConnection(t){t.onmessage=this.onInput}async fetchConnection(t){if(!this._port)throw new Error("Fragments: Connection not initialized");return this._port}async executeConnection(t,e){(await this.fetchConnection(t)).postMessage(t,e)}async manageOutput(t){const e=await this.fetchConnection(t);t.toMainThread=!0,e.postMessage(t)}async manageConnection(t){try{await this._handleInput(t)}catch(e){t.errorInfo=e.toString(),console.error(e)}}async manageInput(t){await this.manageConnection(t),await this.manageOutput(t)}}class zu{constructor(t){c(this,"_modelThread",new Map),c(this,"_threadsModelAmount",new Map),c(this,"_threadPort",new Map),c(this,"_threadPath"),c(this,"_placeholder"),this._placeholder={},this._threadPath=t}get path(){return this._threadPath}usePlaceholder(t){this._modelThread.set(t,this._placeholder)}getAmount(t){return this._threadsModelAmount.get(t)}getThread(t){return this._modelThread.get(t)}getAndCheckThread(t){const e=this._modelThread.get(t);if(e===this._placeholder)throw new Error("Fragments: Error fetching thread!");return e}set(t,e){this._modelThread.set(t,e)}deleteModel(t){const e=this.getThreadSafe(t),s=this.getAmountSafe(e)-1;this.setAmount(e,s),this._modelThread.delete(t)}getThreadSafe(t){const e=this.getThread(t);if(!e)throw new Error(`Fragments: Thread for model ${t} not found`);return e}deleteThread(t){this._threadsModelAmount.delete(t),this._threadPort.delete(t),t.terminate()}getThreadAmount(){return this._threadsModelAmount.size}balanceThreadLoad(t){const{lessBusyThread:e,modelAmount:s}=this.getLessBusyThread();return this._threadsModelAmount.set(e,s+1),this._modelThread.set(t.modelId,e),this._threadPort.get(e)}getAmountSafe(t){const e=this.getAmount(t);if(!e)throw new Error(`Fragments: Amount for thread ${t} not found`);return e}setPort(t,e){this._threadPort.set(t,e)}setAmount(t,e){this._threadsModelAmount.set(t,e)}getPort(t){return this._threadPort.get(t)}getLessBusyThread(){let t=Number.MAX_VALUE,e=this._threadsModelAmount.keys().next().value;for(const[s,i]of this._threadsModelAmount)i<t&&(t=i,e=s);return{lessBusyThread:e,modelAmount:t}}}class Gu extends Bu{constructor(t,e){super(t),c(this,"_data"),this._data=new zu(e)}delete(t){const e=this._data.getThreadSafe(t),s=this._data.getAmountSafe(e)-1;this._data.deleteModel(t),s===0&&this._data.deleteThread(e)}async invoke(t,e,s=[]){const i=wt.getExecuteRequest(t,e,s);return(await this.fetch(i)).result}async fetchConnection(t){const e=this._data.getAndCheckThread(t.modelId);return e?this._data.getPort(e):this.setupNewThread(t)}setupNewThread(t){const e=wt;this._data.usePlaceholder(t.modelId);const s=this._data.getThreadAmount();return e.areCoresAvailable(s)?this.newThread(t,this._data.path):this._data.balanceThreadLoad(t)}setupThread(t){const e=new MessageChannel,s=e.port1,i=e.port2;this.initConnection(s),this._data.setPort(t,s),t.postMessage(i,[i])}newThread(t,e){const s=wt.newThread(e);return this.setupThread(s),this._data.setAmount(s,1),this._data.set(t.modelId,s),this._data.getPort(s)}}/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */function ai(n){let t=n.length;for(;--t>=0;)n[t]=0}const Zr=256,zo=286,Pi=30,Mi=15,Xr=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),Vn=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),ku=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),Ua=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Je=new Array(576);ai(Je);const wi=new Array(60);ai(wi);const Qi=new Array(512);ai(Qi);const Di=new Array(256);ai(Di);const ba=new Array(29);ai(ba);const Qn=new Array(Pi);function Ir(n,t,e,s,i){this.static_tree=n,this.extra_bits=t,this.extra_base=e,this.elems=s,this.max_length=i,this.has_stree=n&&n.length}let Va,Ba,za;function _r(n,t){this.dyn_tree=n,this.max_code=0,this.stat_desc=t}ai(Qn);const Go=n=>n<256?Qi[n]:Qi[256+(n>>>7)],Ki=(n,t)=>{n.pending_buf[n.pending++]=255&t,n.pending_buf[n.pending++]=t>>>8&255},ee=(n,t,e)=>{n.bi_valid>16-e?(n.bi_buf|=t<<n.bi_valid&65535,Ki(n,n.bi_buf),n.bi_buf=t>>16-n.bi_valid,n.bi_valid+=e-16):(n.bi_buf|=t<<n.bi_valid&65535,n.bi_valid+=e)},Ye=(n,t,e)=>{ee(n,e[2*t],e[2*t+1])},ko=(n,t)=>{let e=0;do e|=1&n,n>>>=1,e<<=1;while(--t>0);return e>>>1},Yo=(n,t,e)=>{const s=new Array(16);let i,r,a=0;for(i=1;i<=Mi;i++)a=a+e[i-1]<<1,s[i]=a;for(r=0;r<=t;r++){let o=n[2*r+1];o!==0&&(n[2*r]=ko(s[o]++,o))}},Ga=n=>{let t;for(t=0;t<zo;t++)n.dyn_ltree[2*t]=0;for(t=0;t<Pi;t++)n.dyn_dtree[2*t]=0;for(t=0;t<19;t++)n.bl_tree[2*t]=0;n.dyn_ltree[512]=1,n.opt_len=n.static_len=0,n.sym_next=n.matches=0},Ho=n=>{n.bi_valid>8?Ki(n,n.bi_buf):n.bi_valid>0&&(n.pending_buf[n.pending++]=n.bi_buf),n.bi_buf=0,n.bi_valid=0},ka=(n,t,e,s)=>{const i=2*t,r=2*e;return n[i]<n[r]||n[i]===n[r]&&s[t]<=s[e]},Er=(n,t,e)=>{const s=n.heap[e];let i=e<<1;for(;i<=n.heap_len&&(i<n.heap_len&&ka(t,n.heap[i+1],n.heap[i],n.depth)&&i++,!ka(t,s,n.heap[i],n.depth));)n.heap[e]=n.heap[i],e=i,i<<=1;n.heap[e]=s},Ya=(n,t,e)=>{let s,i,r,a,o=0;if(n.sym_next!==0)do s=255&n.pending_buf[n.sym_buf+o++],s+=(255&n.pending_buf[n.sym_buf+o++])<<8,i=n.pending_buf[n.sym_buf+o++],s===0?Ye(n,i,t):(r=Di[i],Ye(n,r+Zr+1,t),a=Xr[r],a!==0&&(i-=ba[r],ee(n,i,a)),s--,r=Go(s),Ye(n,r,e),a=Vn[r],a!==0&&(s-=Qn[r],ee(n,s,a)));while(o<n.sym_next);Ye(n,256,t)},mr=(n,t)=>{const e=t.dyn_tree,s=t.stat_desc.static_tree,i=t.stat_desc.has_stree,r=t.stat_desc.elems;let a,o,h,l=-1;for(n.heap_len=0,n.heap_max=573,a=0;a<r;a++)e[2*a]!==0?(n.heap[++n.heap_len]=l=a,n.depth[a]=0):e[2*a+1]=0;for(;n.heap_len<2;)h=n.heap[++n.heap_len]=l<2?++l:0,e[2*h]=1,n.depth[h]=0,n.opt_len--,i&&(n.static_len-=s[2*h+1]);for(t.max_code=l,a=n.heap_len>>1;a>=1;a--)Er(n,e,a);h=r;do a=n.heap[1],n.heap[1]=n.heap[n.heap_len--],Er(n,e,1),o=n.heap[1],n.heap[--n.heap_max]=a,n.heap[--n.heap_max]=o,e[2*h]=e[2*a]+e[2*o],n.depth[h]=(n.depth[a]>=n.depth[o]?n.depth[a]:n.depth[o])+1,e[2*a+1]=e[2*o+1]=h,n.heap[1]=h++,Er(n,e,1);while(n.heap_len>=2);n.heap[--n.heap_max]=n.heap[1],((d,u)=>{const p=u.dyn_tree,f=u.max_code,m=u.stat_desc.static_tree,b=u.stat_desc.has_stree,I=u.stat_desc.extra_bits,C=u.stat_desc.extra_base,R=u.stat_desc.max_length;let E,g,w,A,y,F,S=0;for(A=0;A<=Mi;A++)d.bl_count[A]=0;for(p[2*d.heap[d.heap_max]+1]=0,E=d.heap_max+1;E<573;E++)g=d.heap[E],A=p[2*p[2*g+1]+1]+1,A>R&&(A=R,S++),p[2*g+1]=A,g>f||(d.bl_count[A]++,y=0,g>=C&&(y=I[g-C]),F=p[2*g],d.opt_len+=F*(A+y),b&&(d.static_len+=F*(m[2*g+1]+y)));if(S!==0){do{for(A=R-1;d.bl_count[A]===0;)A--;d.bl_count[A]--,d.bl_count[A+1]+=2,d.bl_count[R]--,S-=2}while(S>0);for(A=R;A!==0;A--)for(g=d.bl_count[A];g!==0;)w=d.heap[--E],w>f||(p[2*w+1]!==A&&(d.opt_len+=(A-p[2*w+1])*p[2*w],p[2*w+1]=A),g--)}})(n,t),Yo(e,l,n.bl_count)},Ha=(n,t,e)=>{let s,i,r=-1,a=t[1],o=0,h=7,l=4;for(a===0&&(h=138,l=3),t[2*(e+1)+1]=65535,s=0;s<=e;s++)i=a,a=t[2*(s+1)+1],++o<h&&i===a||(o<l?n.bl_tree[2*i]+=o:i!==0?(i!==r&&n.bl_tree[2*i]++,n.bl_tree[32]++):o<=10?n.bl_tree[34]++:n.bl_tree[36]++,o=0,r=i,a===0?(h=138,l=3):i===a?(h=6,l=3):(h=7,l=4))},Wa=(n,t,e)=>{let s,i,r=-1,a=t[1],o=0,h=7,l=4;for(a===0&&(h=138,l=3),s=0;s<=e;s++)if(i=a,a=t[2*(s+1)+1],!(++o<h&&i===a)){if(o<l)do Ye(n,i,n.bl_tree);while(--o!=0);else i!==0?(i!==r&&(Ye(n,i,n.bl_tree),o--),Ye(n,16,n.bl_tree),ee(n,o-3,2)):o<=10?(Ye(n,17,n.bl_tree),ee(n,o-3,3)):(Ye(n,18,n.bl_tree),ee(n,o-11,7));o=0,r=i,a===0?(h=138,l=3):i===a?(h=6,l=3):(h=7,l=4)}};let ja=!1;const qa=(n,t,e,s)=>{ee(n,0+(s?1:0),3),Ho(n),Ki(n,e),Ki(n,~e),e&&n.pending_buf.set(n.window.subarray(t,t+e),n.pending),n.pending+=e};var Yu={_tr_init:n=>{ja||((()=>{let t,e,s,i,r;const a=new Array(16);for(s=0,i=0;i<28;i++)for(ba[i]=s,t=0;t<1<<Xr[i];t++)Di[s++]=i;for(Di[s-1]=i,r=0,i=0;i<16;i++)for(Qn[i]=r,t=0;t<1<<Vn[i];t++)Qi[r++]=i;for(r>>=7;i<Pi;i++)for(Qn[i]=r<<7,t=0;t<1<<Vn[i]-7;t++)Qi[256+r++]=i;for(e=0;e<=Mi;e++)a[e]=0;for(t=0;t<=143;)Je[2*t+1]=8,t++,a[8]++;for(;t<=255;)Je[2*t+1]=9,t++,a[9]++;for(;t<=279;)Je[2*t+1]=7,t++,a[7]++;for(;t<=287;)Je[2*t+1]=8,t++,a[8]++;for(Yo(Je,287,a),t=0;t<Pi;t++)wi[2*t+1]=5,wi[2*t]=ko(t,5);Va=new Ir(Je,Xr,257,zo,Mi),Ba=new Ir(wi,Vn,0,Pi,Mi),za=new Ir(new Array(0),ku,0,19,7)})(),ja=!0),n.l_desc=new _r(n.dyn_ltree,Va),n.d_desc=new _r(n.dyn_dtree,Ba),n.bl_desc=new _r(n.bl_tree,za),n.bi_buf=0,n.bi_valid=0,Ga(n)},_tr_stored_block:qa,_tr_flush_block:(n,t,e,s)=>{let i,r,a=0;n.level>0?(n.strm.data_type===2&&(n.strm.data_type=(o=>{let h,l=4093624447;for(h=0;h<=31;h++,l>>>=1)if(1&l&&o.dyn_ltree[2*h]!==0)return 0;if(o.dyn_ltree[18]!==0||o.dyn_ltree[20]!==0||o.dyn_ltree[26]!==0)return 1;for(h=32;h<Zr;h++)if(o.dyn_ltree[2*h]!==0)return 1;return 0})(n)),mr(n,n.l_desc),mr(n,n.d_desc),a=(o=>{let h;for(Ha(o,o.dyn_ltree,o.l_desc.max_code),Ha(o,o.dyn_dtree,o.d_desc.max_code),mr(o,o.bl_desc),h=18;h>=3&&o.bl_tree[2*Ua[h]+1]===0;h--);return o.opt_len+=3*(h+1)+5+5+4,h})(n),i=n.opt_len+3+7>>>3,r=n.static_len+3+7>>>3,r<=i&&(i=r)):i=r=e+5,e+4<=i&&t!==-1?qa(n,t,e,s):n.strategy===4||r===i?(ee(n,2+(s?1:0),3),Ya(n,Je,wi)):(ee(n,4+(s?1:0),3),((o,h,l,d)=>{let u;for(ee(o,h-257,5),ee(o,l-1,5),ee(o,d-4,4),u=0;u<d;u++)ee(o,o.bl_tree[2*Ua[u]+1],3);Wa(o,o.dyn_ltree,h-1),Wa(o,o.dyn_dtree,l-1)})(n,n.l_desc.max_code+1,n.d_desc.max_code+1,a+1),Ya(n,n.dyn_ltree,n.dyn_dtree)),Ga(n),s&&Ho(n)},_tr_tally:(n,t,e)=>(n.pending_buf[n.sym_buf+n.sym_next++]=t,n.pending_buf[n.sym_buf+n.sym_next++]=t>>8,n.pending_buf[n.sym_buf+n.sym_next++]=e,t===0?n.dyn_ltree[2*e]++:(n.matches++,t--,n.dyn_ltree[2*(Di[e]+Zr+1)]++,n.dyn_dtree[2*Go(t)]++),n.sym_next===n.sym_end),_tr_align:n=>{ee(n,2,3),Ye(n,256,Je),(t=>{t.bi_valid===16?(Ki(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)})(n)}},Ui=(n,t,e,s)=>{let i=65535&n,r=n>>>16&65535,a=0;for(;e!==0;){a=e>2e3?2e3:e,e-=a;do i=i+t[s++]|0,r=r+i|0;while(--a);i%=65521,r%=65521}return i|r<<16};const Hu=new Uint32Array((()=>{let n,t=[];for(var e=0;e<256;e++){n=e;for(var s=0;s<8;s++)n=1&n?3988292384^n>>>1:n>>>1;t[e]=n}return t})());var Ft=(n,t,e,s)=>{const i=Hu,r=s+e;n^=-1;for(let a=s;a<r;a++)n=n>>>8^i[255&(n^t[a])];return~n},Us={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},an={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:Wu,_tr_stored_block:$r,_tr_flush_block:ju,_tr_tally:Es,_tr_align:qu}=Yu,{Z_NO_FLUSH:ms,Z_PARTIAL_FLUSH:Zu,Z_FULL_FLUSH:Xu,Z_FINISH:me,Z_BLOCK:Za,Z_OK:Nt,Z_STREAM_END:Xa,Z_STREAM_ERROR:Me,Z_DATA_ERROR:$u,Z_BUF_ERROR:Cr,Z_DEFAULT_COMPRESSION:Qu,Z_FILTERED:Ku,Z_HUFFMAN_ONLY:gn,Z_RLE:Ju,Z_FIXED:tf,Z_DEFAULT_STRATEGY:ef,Z_UNKNOWN:sf,Z_DEFLATED:Kn}=an,Ls=258,We=262,ti=42,ys=113,Fi=666,xs=(n,t)=>(n.msg=Us[t],t),$a=n=>2*n-(n>4?9:0),ps=n=>{let t=n.length;for(;--t>=0;)n[t]=0},nf=n=>{let t,e,s,i=n.w_size;t=n.hash_size,s=t;do e=n.head[--s],n.head[s]=e>=i?e-i:0;while(--t);t=i,s=t;do e=n.prev[--s],n.prev[s]=e>=i?e-i:0;while(--t)};let Cs=(n,t,e)=>(t<<n.hash_shift^e)&n.hash_mask;const ne=n=>{const t=n.state;let e=t.pending;e>n.avail_out&&(e=n.avail_out),e!==0&&(n.output.set(t.pending_buf.subarray(t.pending_out,t.pending_out+e),n.next_out),n.next_out+=e,t.pending_out+=e,n.total_out+=e,n.avail_out-=e,t.pending-=e,t.pending===0&&(t.pending_out=0))},le=(n,t)=>{ju(n,n.block_start>=0?n.block_start:-1,n.strstart-n.block_start,t),n.block_start=n.strstart,ne(n.strm)},J=(n,t)=>{n.pending_buf[n.pending++]=t},bi=(n,t)=>{n.pending_buf[n.pending++]=t>>>8&255,n.pending_buf[n.pending++]=255&t},Qr=(n,t,e,s)=>{let i=n.avail_in;return i>s&&(i=s),i===0?0:(n.avail_in-=i,t.set(n.input.subarray(n.next_in,n.next_in+i),e),n.state.wrap===1?n.adler=Ui(n.adler,t,i,e):n.state.wrap===2&&(n.adler=Ft(n.adler,t,i,e)),n.next_in+=i,n.total_in+=i,i)},Wo=(n,t)=>{let e,s,i=n.max_chain_length,r=n.strstart,a=n.prev_length,o=n.nice_match;const h=n.strstart>n.w_size-We?n.strstart-(n.w_size-We):0,l=n.window,d=n.w_mask,u=n.prev,p=n.strstart+Ls;let f=l[r+a-1],m=l[r+a];n.prev_length>=n.good_match&&(i>>=2),o>n.lookahead&&(o=n.lookahead);do if(e=t,l[e+a]===m&&l[e+a-1]===f&&l[e]===l[r]&&l[++e]===l[r+1]){r+=2,e++;do;while(l[++r]===l[++e]&&l[++r]===l[++e]&&l[++r]===l[++e]&&l[++r]===l[++e]&&l[++r]===l[++e]&&l[++r]===l[++e]&&l[++r]===l[++e]&&l[++r]===l[++e]&&r<p);if(s=Ls-(p-r),r=p-Ls,s>a){if(n.match_start=t,a=s,s>=o)break;f=l[r+a-1],m=l[r+a]}}while((t=u[t&d])>h&&--i!=0);return a<=n.lookahead?a:n.lookahead},$s=n=>{const t=n.w_size;let e,s,i;do{if(s=n.window_size-n.lookahead-n.strstart,n.strstart>=t+(t-We)&&(n.window.set(n.window.subarray(t,t+t-s),0),n.match_start-=t,n.strstart-=t,n.block_start-=t,n.insert>n.strstart&&(n.insert=n.strstart),nf(n),s+=t),n.strm.avail_in===0)break;if(e=Qr(n.strm,n.window,n.strstart+n.lookahead,s),n.lookahead+=e,n.lookahead+n.insert>=3)for(i=n.strstart-n.insert,n.ins_h=n.window[i],n.ins_h=Cs(n,n.ins_h,n.window[i+1]);n.insert&&(n.ins_h=Cs(n,n.ins_h,n.window[i+3-1]),n.prev[i&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=i,i++,n.insert--,!(n.lookahead+n.insert<3)););}while(n.lookahead<We&&n.strm.avail_in!==0)},jo=(n,t)=>{let e,s,i,r=n.pending_buf_size-5>n.w_size?n.w_size:n.pending_buf_size-5,a=0,o=n.strm.avail_in;do{if(e=65535,i=n.bi_valid+42>>3,n.strm.avail_out<i||(i=n.strm.avail_out-i,s=n.strstart-n.block_start,e>s+n.strm.avail_in&&(e=s+n.strm.avail_in),e>i&&(e=i),e<r&&(e===0&&t!==me||t===ms||e!==s+n.strm.avail_in)))break;a=t===me&&e===s+n.strm.avail_in?1:0,$r(n,0,0,a),n.pending_buf[n.pending-4]=e,n.pending_buf[n.pending-3]=e>>8,n.pending_buf[n.pending-2]=~e,n.pending_buf[n.pending-1]=~e>>8,ne(n.strm),s&&(s>e&&(s=e),n.strm.output.set(n.window.subarray(n.block_start,n.block_start+s),n.strm.next_out),n.strm.next_out+=s,n.strm.avail_out-=s,n.strm.total_out+=s,n.block_start+=s,e-=s),e&&(Qr(n.strm,n.strm.output,n.strm.next_out,e),n.strm.next_out+=e,n.strm.avail_out-=e,n.strm.total_out+=e)}while(a===0);return o-=n.strm.avail_in,o&&(o>=n.w_size?(n.matches=2,n.window.set(n.strm.input.subarray(n.strm.next_in-n.w_size,n.strm.next_in),0),n.strstart=n.w_size,n.insert=n.strstart):(n.window_size-n.strstart<=o&&(n.strstart-=n.w_size,n.window.set(n.window.subarray(n.w_size,n.w_size+n.strstart),0),n.matches<2&&n.matches++,n.insert>n.strstart&&(n.insert=n.strstart)),n.window.set(n.strm.input.subarray(n.strm.next_in-o,n.strm.next_in),n.strstart),n.strstart+=o,n.insert+=o>n.w_size-n.insert?n.w_size-n.insert:o),n.block_start=n.strstart),n.high_water<n.strstart&&(n.high_water=n.strstart),a?4:t!==ms&&t!==me&&n.strm.avail_in===0&&n.strstart===n.block_start?2:(i=n.window_size-n.strstart,n.strm.avail_in>i&&n.block_start>=n.w_size&&(n.block_start-=n.w_size,n.strstart-=n.w_size,n.window.set(n.window.subarray(n.w_size,n.w_size+n.strstart),0),n.matches<2&&n.matches++,i+=n.w_size,n.insert>n.strstart&&(n.insert=n.strstart)),i>n.strm.avail_in&&(i=n.strm.avail_in),i&&(Qr(n.strm,n.window,n.strstart,i),n.strstart+=i,n.insert+=i>n.w_size-n.insert?n.w_size-n.insert:i),n.high_water<n.strstart&&(n.high_water=n.strstart),i=n.bi_valid+42>>3,i=n.pending_buf_size-i>65535?65535:n.pending_buf_size-i,r=i>n.w_size?n.w_size:i,s=n.strstart-n.block_start,(s>=r||(s||t===me)&&t!==ms&&n.strm.avail_in===0&&s<=i)&&(e=s>i?i:s,a=t===me&&n.strm.avail_in===0&&e===s?1:0,$r(n,n.block_start,e,a),n.block_start+=e,ne(n.strm)),a?3:1)},gr=(n,t)=>{let e,s;for(;;){if(n.lookahead<We){if($s(n),n.lookahead<We&&t===ms)return 1;if(n.lookahead===0)break}if(e=0,n.lookahead>=3&&(n.ins_h=Cs(n,n.ins_h,n.window[n.strstart+3-1]),e=n.prev[n.strstart&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=n.strstart),e!==0&&n.strstart-e<=n.w_size-We&&(n.match_length=Wo(n,e)),n.match_length>=3)if(s=Es(n,n.strstart-n.match_start,n.match_length-3),n.lookahead-=n.match_length,n.match_length<=n.max_lazy_match&&n.lookahead>=3){n.match_length--;do n.strstart++,n.ins_h=Cs(n,n.ins_h,n.window[n.strstart+3-1]),e=n.prev[n.strstart&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=n.strstart;while(--n.match_length!=0);n.strstart++}else n.strstart+=n.match_length,n.match_length=0,n.ins_h=n.window[n.strstart],n.ins_h=Cs(n,n.ins_h,n.window[n.strstart+1]);else s=Es(n,0,n.window[n.strstart]),n.lookahead--,n.strstart++;if(s&&(le(n,!1),n.strm.avail_out===0))return 1}return n.insert=n.strstart<2?n.strstart:2,t===me?(le(n,!0),n.strm.avail_out===0?3:4):n.sym_next&&(le(n,!1),n.strm.avail_out===0)?1:2},zs=(n,t)=>{let e,s,i;for(;;){if(n.lookahead<We){if($s(n),n.lookahead<We&&t===ms)return 1;if(n.lookahead===0)break}if(e=0,n.lookahead>=3&&(n.ins_h=Cs(n,n.ins_h,n.window[n.strstart+3-1]),e=n.prev[n.strstart&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=n.strstart),n.prev_length=n.match_length,n.prev_match=n.match_start,n.match_length=2,e!==0&&n.prev_length<n.max_lazy_match&&n.strstart-e<=n.w_size-We&&(n.match_length=Wo(n,e),n.match_length<=5&&(n.strategy===Ku||n.match_length===3&&n.strstart-n.match_start>4096)&&(n.match_length=2)),n.prev_length>=3&&n.match_length<=n.prev_length){i=n.strstart+n.lookahead-3,s=Es(n,n.strstart-1-n.prev_match,n.prev_length-3),n.lookahead-=n.prev_length-1,n.prev_length-=2;do++n.strstart<=i&&(n.ins_h=Cs(n,n.ins_h,n.window[n.strstart+3-1]),e=n.prev[n.strstart&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=n.strstart);while(--n.prev_length!=0);if(n.match_available=0,n.match_length=2,n.strstart++,s&&(le(n,!1),n.strm.avail_out===0))return 1}else if(n.match_available){if(s=Es(n,0,n.window[n.strstart-1]),s&&le(n,!1),n.strstart++,n.lookahead--,n.strm.avail_out===0)return 1}else n.match_available=1,n.strstart++,n.lookahead--}return n.match_available&&(s=Es(n,0,n.window[n.strstart-1]),n.match_available=0),n.insert=n.strstart<2?n.strstart:2,t===me?(le(n,!0),n.strm.avail_out===0?3:4):n.sym_next&&(le(n,!1),n.strm.avail_out===0)?1:2};function Le(n,t,e,s,i){this.good_length=n,this.max_lazy=t,this.nice_length=e,this.max_chain=s,this.func=i}const Si=[new Le(0,0,0,0,jo),new Le(4,4,8,4,gr),new Le(4,5,16,8,gr),new Le(4,6,32,32,gr),new Le(4,4,16,16,zs),new Le(8,16,32,32,zs),new Le(8,16,128,128,zs),new Le(8,32,128,256,zs),new Le(32,128,258,1024,zs),new Le(32,258,258,4096,zs)];function rf(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Kn,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),ps(this.dyn_ltree),ps(this.dyn_dtree),ps(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),ps(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),ps(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const yi=n=>{if(!n)return 1;const t=n.state;return!t||t.strm!==n||t.status!==ti&&t.status!==57&&t.status!==69&&t.status!==73&&t.status!==91&&t.status!==103&&t.status!==ys&&t.status!==Fi?1:0},qo=n=>{if(yi(n))return xs(n,Me);n.total_in=n.total_out=0,n.data_type=sf;const t=n.state;return t.pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap===2?57:t.wrap?ti:ys,n.adler=t.wrap===2?0:1,t.last_flush=-2,Wu(t),Nt},Zo=n=>{const t=qo(n);var e;return t===Nt&&((e=n.state).window_size=2*e.w_size,ps(e.head),e.max_lazy_match=Si[e.level].max_lazy,e.good_match=Si[e.level].good_length,e.nice_match=Si[e.level].nice_length,e.max_chain_length=Si[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=2,e.match_available=0,e.ins_h=0),t},Qa=(n,t,e,s,i,r)=>{if(!n)return Me;let a=1;if(t===Qu&&(t=6),s<0?(a=0,s=-s):s>15&&(a=2,s-=16),i<1||i>9||e!==Kn||s<8||s>15||t<0||t>9||r<0||r>tf||s===8&&a!==1)return xs(n,Me);s===8&&(s=9);const o=new rf;return n.state=o,o.strm=n,o.status=ti,o.wrap=a,o.gzhead=null,o.w_bits=s,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=i+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+3-1)/3),o.window=new Uint8Array(2*o.w_size),o.head=new Uint16Array(o.hash_size),o.prev=new Uint16Array(o.w_size),o.lit_bufsize=1<<i+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new Uint8Array(o.pending_buf_size),o.sym_buf=o.lit_bufsize,o.sym_end=3*(o.lit_bufsize-1),o.level=t,o.strategy=r,o.method=e,Zo(n)};var Vi={deflateInit:(n,t)=>Qa(n,t,Kn,15,8,ef),deflateInit2:Qa,deflateReset:Zo,deflateResetKeep:qo,deflateSetHeader:(n,t)=>yi(n)||n.state.wrap!==2?Me:(n.state.gzhead=t,Nt),deflate:(n,t)=>{if(yi(n)||t>Za||t<0)return n?xs(n,Me):Me;const e=n.state;if(!n.output||n.avail_in!==0&&!n.input||e.status===Fi&&t!==me)return xs(n,n.avail_out===0?Cr:Me);const s=e.last_flush;if(e.last_flush=t,e.pending!==0){if(ne(n),n.avail_out===0)return e.last_flush=-1,Nt}else if(n.avail_in===0&&$a(t)<=$a(s)&&t!==me)return xs(n,Cr);if(e.status===Fi&&n.avail_in!==0)return xs(n,Cr);if(e.status===ti&&e.wrap===0&&(e.status=ys),e.status===ti){let i=Kn+(e.w_bits-8<<4)<<8,r=-1;if(r=e.strategy>=gn||e.level<2?0:e.level<6?1:e.level===6?2:3,i|=r<<6,e.strstart!==0&&(i|=32),i+=31-i%31,bi(e,i),e.strstart!==0&&(bi(e,n.adler>>>16),bi(e,65535&n.adler)),n.adler=1,e.status=ys,ne(n),e.pending!==0)return e.last_flush=-1,Nt}if(e.status===57){if(n.adler=0,J(e,31),J(e,139),J(e,8),e.gzhead)J(e,(e.gzhead.text?1:0)+(e.gzhead.hcrc?2:0)+(e.gzhead.extra?4:0)+(e.gzhead.name?8:0)+(e.gzhead.comment?16:0)),J(e,255&e.gzhead.time),J(e,e.gzhead.time>>8&255),J(e,e.gzhead.time>>16&255),J(e,e.gzhead.time>>24&255),J(e,e.level===9?2:e.strategy>=gn||e.level<2?4:0),J(e,255&e.gzhead.os),e.gzhead.extra&&e.gzhead.extra.length&&(J(e,255&e.gzhead.extra.length),J(e,e.gzhead.extra.length>>8&255)),e.gzhead.hcrc&&(n.adler=Ft(n.adler,e.pending_buf,e.pending,0)),e.gzindex=0,e.status=69;else if(J(e,0),J(e,0),J(e,0),J(e,0),J(e,0),J(e,e.level===9?2:e.strategy>=gn||e.level<2?4:0),J(e,3),e.status=ys,ne(n),e.pending!==0)return e.last_flush=-1,Nt}if(e.status===69){if(e.gzhead.extra){let i=e.pending,r=(65535&e.gzhead.extra.length)-e.gzindex;for(;e.pending+r>e.pending_buf_size;){let o=e.pending_buf_size-e.pending;if(e.pending_buf.set(e.gzhead.extra.subarray(e.gzindex,e.gzindex+o),e.pending),e.pending=e.pending_buf_size,e.gzhead.hcrc&&e.pending>i&&(n.adler=Ft(n.adler,e.pending_buf,e.pending-i,i)),e.gzindex+=o,ne(n),e.pending!==0)return e.last_flush=-1,Nt;i=0,r-=o}let a=new Uint8Array(e.gzhead.extra);e.pending_buf.set(a.subarray(e.gzindex,e.gzindex+r),e.pending),e.pending+=r,e.gzhead.hcrc&&e.pending>i&&(n.adler=Ft(n.adler,e.pending_buf,e.pending-i,i)),e.gzindex=0}e.status=73}if(e.status===73){if(e.gzhead.name){let i,r=e.pending;do{if(e.pending===e.pending_buf_size){if(e.gzhead.hcrc&&e.pending>r&&(n.adler=Ft(n.adler,e.pending_buf,e.pending-r,r)),ne(n),e.pending!==0)return e.last_flush=-1,Nt;r=0}i=e.gzindex<e.gzhead.name.length?255&e.gzhead.name.charCodeAt(e.gzindex++):0,J(e,i)}while(i!==0);e.gzhead.hcrc&&e.pending>r&&(n.adler=Ft(n.adler,e.pending_buf,e.pending-r,r)),e.gzindex=0}e.status=91}if(e.status===91){if(e.gzhead.comment){let i,r=e.pending;do{if(e.pending===e.pending_buf_size){if(e.gzhead.hcrc&&e.pending>r&&(n.adler=Ft(n.adler,e.pending_buf,e.pending-r,r)),ne(n),e.pending!==0)return e.last_flush=-1,Nt;r=0}i=e.gzindex<e.gzhead.comment.length?255&e.gzhead.comment.charCodeAt(e.gzindex++):0,J(e,i)}while(i!==0);e.gzhead.hcrc&&e.pending>r&&(n.adler=Ft(n.adler,e.pending_buf,e.pending-r,r))}e.status=103}if(e.status===103){if(e.gzhead.hcrc){if(e.pending+2>e.pending_buf_size&&(ne(n),e.pending!==0))return e.last_flush=-1,Nt;J(e,255&n.adler),J(e,n.adler>>8&255),n.adler=0}if(e.status=ys,ne(n),e.pending!==0)return e.last_flush=-1,Nt}if(n.avail_in!==0||e.lookahead!==0||t!==ms&&e.status!==Fi){let i=e.level===0?jo(e,t):e.strategy===gn?((r,a)=>{let o;for(;;){if(r.lookahead===0&&($s(r),r.lookahead===0)){if(a===ms)return 1;break}if(r.match_length=0,o=Es(r,0,r.window[r.strstart]),r.lookahead--,r.strstart++,o&&(le(r,!1),r.strm.avail_out===0))return 1}return r.insert=0,a===me?(le(r,!0),r.strm.avail_out===0?3:4):r.sym_next&&(le(r,!1),r.strm.avail_out===0)?1:2})(e,t):e.strategy===Ju?((r,a)=>{let o,h,l,d;const u=r.window;for(;;){if(r.lookahead<=Ls){if($s(r),r.lookahead<=Ls&&a===ms)return 1;if(r.lookahead===0)break}if(r.match_length=0,r.lookahead>=3&&r.strstart>0&&(l=r.strstart-1,h=u[l],h===u[++l]&&h===u[++l]&&h===u[++l])){d=r.strstart+Ls;do;while(h===u[++l]&&h===u[++l]&&h===u[++l]&&h===u[++l]&&h===u[++l]&&h===u[++l]&&h===u[++l]&&h===u[++l]&&l<d);r.match_length=Ls-(d-l),r.match_length>r.lookahead&&(r.match_length=r.lookahead)}if(r.match_length>=3?(o=Es(r,1,r.match_length-3),r.lookahead-=r.match_length,r.strstart+=r.match_length,r.match_length=0):(o=Es(r,0,r.window[r.strstart]),r.lookahead--,r.strstart++),o&&(le(r,!1),r.strm.avail_out===0))return 1}return r.insert=0,a===me?(le(r,!0),r.strm.avail_out===0?3:4):r.sym_next&&(le(r,!1),r.strm.avail_out===0)?1:2})(e,t):Si[e.level].func(e,t);if(i!==3&&i!==4||(e.status=Fi),i===1||i===3)return n.avail_out===0&&(e.last_flush=-1),Nt;if(i===2&&(t===Zu?qu(e):t!==Za&&($r(e,0,0,!1),t===Xu&&(ps(e.head),e.lookahead===0&&(e.strstart=0,e.block_start=0,e.insert=0))),ne(n),n.avail_out===0))return e.last_flush=-1,Nt}return t!==me?Nt:e.wrap<=0?Xa:(e.wrap===2?(J(e,255&n.adler),J(e,n.adler>>8&255),J(e,n.adler>>16&255),J(e,n.adler>>24&255),J(e,255&n.total_in),J(e,n.total_in>>8&255),J(e,n.total_in>>16&255),J(e,n.total_in>>24&255)):(bi(e,n.adler>>>16),bi(e,65535&n.adler)),ne(n),e.wrap>0&&(e.wrap=-e.wrap),e.pending!==0?Nt:Xa)},deflateEnd:n=>{if(yi(n))return Me;const t=n.state.status;return n.state=null,t===ys?xs(n,$u):Nt},deflateSetDictionary:(n,t)=>{let e=t.length;if(yi(n))return Me;const s=n.state,i=s.wrap;if(i===2||i===1&&s.status!==ti||s.lookahead)return Me;if(i===1&&(n.adler=Ui(n.adler,t,e,0)),s.wrap=0,e>=s.w_size){i===0&&(ps(s.head),s.strstart=0,s.block_start=0,s.insert=0);let h=new Uint8Array(s.w_size);h.set(t.subarray(e-s.w_size,e),0),t=h,e=s.w_size}const r=n.avail_in,a=n.next_in,o=n.input;for(n.avail_in=e,n.next_in=0,n.input=t,$s(s);s.lookahead>=3;){let h=s.strstart,l=s.lookahead-2;do s.ins_h=Cs(s,s.ins_h,s.window[h+3-1]),s.prev[h&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=h,h++;while(--l);s.strstart=h,s.lookahead=2,$s(s)}return s.strstart+=s.lookahead,s.block_start=s.strstart,s.insert=s.lookahead,s.lookahead=0,s.match_length=s.prev_length=2,s.match_available=0,n.next_in=a,n.input=o,n.avail_in=r,s.wrap=i,Nt},deflateInfo:"pako deflate (from Nodeca project)"};const af=(n,t)=>Object.prototype.hasOwnProperty.call(n,t);var Xo=function(n){const t=Array.prototype.slice.call(arguments,1);for(;t.length;){const e=t.shift();if(e){if(typeof e!="object")throw new TypeError(e+"must be non-object");for(const s in e)af(e,s)&&(n[s]=e[s])}}return n},$o=n=>{let t=0;for(let s=0,i=n.length;s<i;s++)t+=n[s].length;const e=new Uint8Array(t);for(let s=0,i=0,r=n.length;s<r;s++){let a=n[s];e.set(a,i),i+=a.length}return e};let Qo=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{Qo=!1}const Ji=new Uint8Array(256);for(let n=0;n<256;n++)Ji[n]=n>=252?6:n>=248?5:n>=240?4:n>=224?3:n>=192?2:1;Ji[254]=Ji[254]=1;var Ia=n=>{if(typeof TextEncoder=="function"&&TextEncoder.prototype.encode)return new TextEncoder().encode(n);let t,e,s,i,r,a=n.length,o=0;for(i=0;i<a;i++)e=n.charCodeAt(i),(64512&e)==55296&&i+1<a&&(s=n.charCodeAt(i+1),(64512&s)==56320&&(e=65536+(e-55296<<10)+(s-56320),i++)),o+=e<128?1:e<2048?2:e<65536?3:4;for(t=new Uint8Array(o),r=0,i=0;r<o;i++)e=n.charCodeAt(i),(64512&e)==55296&&i+1<a&&(s=n.charCodeAt(i+1),(64512&s)==56320&&(e=65536+(e-55296<<10)+(s-56320),i++)),e<128?t[r++]=e:e<2048?(t[r++]=192|e>>>6,t[r++]=128|63&e):e<65536?(t[r++]=224|e>>>12,t[r++]=128|e>>>6&63,t[r++]=128|63&e):(t[r++]=240|e>>>18,t[r++]=128|e>>>12&63,t[r++]=128|e>>>6&63,t[r++]=128|63&e);return t},of=(n,t)=>{const e=t||n.length;if(typeof TextDecoder=="function"&&TextDecoder.prototype.decode)return new TextDecoder().decode(n.subarray(0,t));let s,i;const r=new Array(2*e);for(i=0,s=0;s<e;){let a=n[s++];if(a<128){r[i++]=a;continue}let o=Ji[a];if(o>4)r[i++]=65533,s+=o-1;else{for(a&=o===2?31:o===3?15:7;o>1&&s<e;)a=a<<6|63&n[s++],o--;o>1?r[i++]=65533:a<65536?r[i++]=a:(a-=65536,r[i++]=55296|a>>10&1023,r[i++]=56320|1023&a)}}return((a,o)=>{if(o<65534&&a.subarray&&Qo)return String.fromCharCode.apply(null,a.length===o?a:a.subarray(0,o));let h="";for(let l=0;l<o;l++)h+=String.fromCharCode(a[l]);return h})(r,i)},lf=(n,t)=>{(t=t||n.length)>n.length&&(t=n.length);let e=t-1;for(;e>=0&&(192&n[e])==128;)e--;return e<0||e===0?t:e+Ji[n[e]]>t?e:t},Ko=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0};const Jo=Object.prototype.toString,{Z_NO_FLUSH:hf,Z_SYNC_FLUSH:cf,Z_FULL_FLUSH:df,Z_FINISH:uf,Z_OK:Jn,Z_STREAM_END:ff,Z_DEFAULT_COMPRESSION:pf,Z_DEFAULT_STRATEGY:bf,Z_DEFLATED:If}=an;function Bi(n){this.options=Xo({level:pf,method:If,chunkSize:16384,windowBits:15,memLevel:8,strategy:bf},n||{});let t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Ko,this.strm.avail_out=0;let e=Vi.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(e!==Jn)throw new Error(Us[e]);if(t.header&&Vi.deflateSetHeader(this.strm,t.header),t.dictionary){let s;if(s=typeof t.dictionary=="string"?Ia(t.dictionary):Jo.call(t.dictionary)==="[object ArrayBuffer]"?new Uint8Array(t.dictionary):t.dictionary,e=Vi.deflateSetDictionary(this.strm,s),e!==Jn)throw new Error(Us[e]);this._dict_set=!0}}function Tr(n,t){const e=new Bi(t);if(e.push(n,!0),e.err)throw e.msg||Us[e.err];return e.result}Bi.prototype.push=function(n,t){const e=this.strm,s=this.options.chunkSize;let i,r;if(this.ended)return!1;for(r=t===~~t?t:t===!0?uf:hf,typeof n=="string"?e.input=Ia(n):Jo.call(n)==="[object ArrayBuffer]"?e.input=new Uint8Array(n):e.input=n,e.next_in=0,e.avail_in=e.input.length;;)if(e.avail_out===0&&(e.output=new Uint8Array(s),e.next_out=0,e.avail_out=s),(r===cf||r===df)&&e.avail_out<=6)this.onData(e.output.subarray(0,e.next_out)),e.avail_out=0;else{if(i=Vi.deflate(e,r),i===ff)return e.next_out>0&&this.onData(e.output.subarray(0,e.next_out)),i=Vi.deflateEnd(this.strm),this.onEnd(i),this.ended=!0,i===Jn;if(e.avail_out!==0){if(r>0&&e.next_out>0)this.onData(e.output.subarray(0,e.next_out)),e.avail_out=0;else if(e.avail_in===0)break}else this.onData(e.output)}return!0},Bi.prototype.onData=function(n){this.chunks.push(n)},Bi.prototype.onEnd=function(n){n===Jn&&(this.result=$o(this.chunks)),this.chunks=[],this.err=n,this.msg=this.strm.msg};var _f={Deflate:Bi,deflate:Tr,deflateRaw:function(n,t){return(t=t||{}).raw=!0,Tr(n,t)},gzip:function(n,t){return(t=t||{}).gzip=!0,Tr(n,t)}};const Tn=16209;var Ef=function(n,t){let e,s,i,r,a,o,h,l,d,u,p,f,m,b,I,C,R,E,g,w,A,y,F,S;const x=n.state;e=n.next_in,F=n.input,s=e+(n.avail_in-5),i=n.next_out,S=n.output,r=i-(t-n.avail_out),a=i+(n.avail_out-257),o=x.dmax,h=x.wsize,l=x.whave,d=x.wnext,u=x.window,p=x.hold,f=x.bits,m=x.lencode,b=x.distcode,I=(1<<x.lenbits)-1,C=(1<<x.distbits)-1;t:do{f<15&&(p+=F[e++]<<f,f+=8,p+=F[e++]<<f,f+=8),R=m[p&I];e:for(;;){if(E=R>>>24,p>>>=E,f-=E,E=R>>>16&255,E===0)S[i++]=65535&R;else{if(!(16&E)){if(64&E){if(32&E){x.mode=16191;break t}n.msg="invalid literal/length code",x.mode=Tn;break t}R=m[(65535&R)+(p&(1<<E)-1)];continue e}for(g=65535&R,E&=15,E&&(f<E&&(p+=F[e++]<<f,f+=8),g+=p&(1<<E)-1,p>>>=E,f-=E),f<15&&(p+=F[e++]<<f,f+=8,p+=F[e++]<<f,f+=8),R=b[p&C];;){if(E=R>>>24,p>>>=E,f-=E,E=R>>>16&255,16&E){if(w=65535&R,E&=15,f<E&&(p+=F[e++]<<f,f+=8,f<E&&(p+=F[e++]<<f,f+=8)),w+=p&(1<<E)-1,w>o){n.msg="invalid distance too far back",x.mode=Tn;break t}if(p>>>=E,f-=E,E=i-r,w>E){if(E=w-E,E>l&&x.sane){n.msg="invalid distance too far back",x.mode=Tn;break t}if(A=0,y=u,d===0){if(A+=h-E,E<g){g-=E;do S[i++]=u[A++];while(--E);A=i-w,y=S}}else if(d<E){if(A+=h+d-E,E-=d,E<g){g-=E;do S[i++]=u[A++];while(--E);if(A=0,d<g){E=d,g-=E;do S[i++]=u[A++];while(--E);A=i-w,y=S}}}else if(A+=d-E,E<g){g-=E;do S[i++]=u[A++];while(--E);A=i-w,y=S}for(;g>2;)S[i++]=y[A++],S[i++]=y[A++],S[i++]=y[A++],g-=3;g&&(S[i++]=y[A++],g>1&&(S[i++]=y[A++]))}else{A=i-w;do S[i++]=S[A++],S[i++]=S[A++],S[i++]=S[A++],g-=3;while(g>2);g&&(S[i++]=S[A++],g>1&&(S[i++]=S[A++]))}break}if(64&E){n.msg="invalid distance code",x.mode=Tn;break t}R=b[(65535&R)+(p&(1<<E)-1)]}}break}}while(e<s&&i<a);g=f>>3,e-=g,f-=g<<3,p&=(1<<f)-1,n.next_in=e,n.next_out=i,n.avail_in=e<s?s-e+5:5-(e-s),n.avail_out=i<a?a-i+257:257-(i-a),x.hold=p,x.bits=f};const Rn=15,mf=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),Cf=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),gf=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),Tf=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);var zi=(n,t,e,s,i,r,a,o)=>{const h=o.bits;let l,d,u,p,f,m,b=0,I=0,C=0,R=0,E=0,g=0,w=0,A=0,y=0,F=0,S=null;const x=new Uint16Array(16),v=new Uint16Array(16);let M,V,nt,ft=null;for(b=0;b<=Rn;b++)x[b]=0;for(I=0;I<s;I++)x[t[e+I]]++;for(E=h,R=Rn;R>=1&&x[R]===0;R--);if(E>R&&(E=R),R===0)return i[r++]=20971520,i[r++]=20971520,o.bits=1,0;for(C=1;C<R&&x[C]===0;C++);for(E<C&&(E=C),A=1,b=1;b<=Rn;b++)if(A<<=1,A-=x[b],A<0)return-1;if(A>0&&(n===0||R!==1))return-1;for(v[1]=0,b=1;b<Rn;b++)v[b+1]=v[b]+x[b];for(I=0;I<s;I++)t[e+I]!==0&&(a[v[t[e+I]]++]=I);if(n===0?(S=ft=a,m=20):n===1?(S=mf,ft=Cf,m=257):(S=gf,ft=Tf,m=0),F=0,I=0,b=C,f=r,g=E,w=0,u=-1,y=1<<E,p=y-1,n===1&&y>852||n===2&&y>592)return 1;for(;;){M=b-w,a[I]+1<m?(V=0,nt=a[I]):a[I]>=m?(V=ft[a[I]-m],nt=S[a[I]-m]):(V=96,nt=0),l=1<<b-w,d=1<<g,C=d;do d-=l,i[f+(F>>w)+d]=M<<24|V<<16|nt;while(d!==0);for(l=1<<b-1;F&l;)l>>=1;if(l!==0?(F&=l-1,F+=l):F=0,I++,--x[b]==0){if(b===R)break;b=t[e+a[I]]}if(b>E&&(F&p)!==u){for(w===0&&(w=E),f+=C,g=b-w,A=1<<g;g+w<R&&(A-=x[g+w],!(A<=0));)g++,A<<=1;if(y+=1<<g,n===1&&y>852||n===2&&y>592)return 1;u=F&p,i[u]=E<<24|g<<16|f-r}}return F!==0&&(i[f+F]=b-w<<24|64<<16),o.bits=E,0};const{Z_FINISH:Ka,Z_BLOCK:Rf,Z_TREES:An,Z_OK:Os,Z_STREAM_END:Af,Z_NEED_DICT:wf,Z_STREAM_ERROR:_e,Z_DATA_ERROR:Ja,Z_MEM_ERROR:to,Z_BUF_ERROR:Ff,Z_DEFLATED:eo}=an,rr=16180,wn=16190,Qe=16191,Rr=16192,Ar=16194,Fn=16199,Sn=16200,wr=16206,lt=16209,so=n=>(n>>>24&255)+(n>>>8&65280)+((65280&n)<<8)+((255&n)<<24);function Sf(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const Ns=n=>{if(!n)return 1;const t=n.state;return!t||t.strm!==n||t.mode<rr||t.mode>16211?1:0},tl=n=>{if(Ns(n))return _e;const t=n.state;return n.total_in=n.total_out=t.total=0,n.msg="",t.wrap&&(n.adler=1&t.wrap),t.mode=rr,t.last=0,t.havedict=0,t.flags=-1,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Int32Array(852),t.distcode=t.distdyn=new Int32Array(592),t.sane=1,t.back=-1,Os},el=n=>{if(Ns(n))return _e;const t=n.state;return t.wsize=0,t.whave=0,t.wnext=0,tl(n)},sl=(n,t)=>{let e;if(Ns(n))return _e;const s=n.state;return t<0?(e=0,t=-t):(e=5+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?_e:(s.window!==null&&s.wbits!==t&&(s.window=null),s.wrap=e,s.wbits=t,el(n))},io=(n,t)=>{if(!n)return _e;const e=new Sf;n.state=e,e.strm=n,e.window=null,e.mode=rr;const s=sl(n,t);return s!==Os&&(n.state=null),s};let Fr,Sr,no=!0;const yf=n=>{if(no){Fr=new Int32Array(512),Sr=new Int32Array(32);let t=0;for(;t<144;)n.lens[t++]=8;for(;t<256;)n.lens[t++]=9;for(;t<280;)n.lens[t++]=7;for(;t<288;)n.lens[t++]=8;for(zi(1,n.lens,0,288,Fr,0,n.work,{bits:9}),t=0;t<32;)n.lens[t++]=5;zi(2,n.lens,0,32,Sr,0,n.work,{bits:5}),no=!1}n.lencode=Fr,n.lenbits=9,n.distcode=Sr,n.distbits=5},ro=(n,t,e,s)=>{let i;const r=n.state;return r.window===null&&(r.wsize=1<<r.wbits,r.wnext=0,r.whave=0,r.window=new Uint8Array(r.wsize)),s>=r.wsize?(r.window.set(t.subarray(e-r.wsize,e),0),r.wnext=0,r.whave=r.wsize):(i=r.wsize-r.wnext,i>s&&(i=s),r.window.set(t.subarray(e-s,e-s+i),r.wnext),(s-=i)?(r.window.set(t.subarray(e-s,e),0),r.wnext=s,r.whave=r.wsize):(r.wnext+=i,r.wnext===r.wsize&&(r.wnext=0),r.whave<r.wsize&&(r.whave+=i))),0};var es={inflateReset:el,inflateReset2:sl,inflateResetKeep:tl,inflateInit:n=>io(n,15),inflateInit2:io,inflate:(n,t)=>{let e,s,i,r,a,o,h,l,d,u,p,f,m,b,I,C,R,E,g,w,A,y,F=0;const S=new Uint8Array(4);let x,v;const M=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(Ns(n)||!n.output||!n.input&&n.avail_in!==0)return _e;e=n.state,e.mode===Qe&&(e.mode=Rr),a=n.next_out,i=n.output,h=n.avail_out,r=n.next_in,s=n.input,o=n.avail_in,l=e.hold,d=e.bits,u=o,p=h,y=Os;t:for(;;)switch(e.mode){case rr:if(e.wrap===0){e.mode=Rr;break}for(;d<16;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}if(2&e.wrap&&l===35615){e.wbits===0&&(e.wbits=15),e.check=0,S[0]=255&l,S[1]=l>>>8&255,e.check=Ft(e.check,S,2,0),l=0,d=0,e.mode=16181;break}if(e.head&&(e.head.done=!1),!(1&e.wrap)||(((255&l)<<8)+(l>>8))%31){n.msg="incorrect header check",e.mode=lt;break}if((15&l)!==eo){n.msg="unknown compression method",e.mode=lt;break}if(l>>>=4,d-=4,A=8+(15&l),e.wbits===0&&(e.wbits=A),A>15||A>e.wbits){n.msg="invalid window size",e.mode=lt;break}e.dmax=1<<e.wbits,e.flags=0,n.adler=e.check=1,e.mode=512&l?16189:Qe,l=0,d=0;break;case 16181:for(;d<16;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}if(e.flags=l,(255&e.flags)!==eo){n.msg="unknown compression method",e.mode=lt;break}if(57344&e.flags){n.msg="unknown header flags set",e.mode=lt;break}e.head&&(e.head.text=l>>8&1),512&e.flags&&4&e.wrap&&(S[0]=255&l,S[1]=l>>>8&255,e.check=Ft(e.check,S,2,0)),l=0,d=0,e.mode=16182;case 16182:for(;d<32;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}e.head&&(e.head.time=l),512&e.flags&&4&e.wrap&&(S[0]=255&l,S[1]=l>>>8&255,S[2]=l>>>16&255,S[3]=l>>>24&255,e.check=Ft(e.check,S,4,0)),l=0,d=0,e.mode=16183;case 16183:for(;d<16;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}e.head&&(e.head.xflags=255&l,e.head.os=l>>8),512&e.flags&&4&e.wrap&&(S[0]=255&l,S[1]=l>>>8&255,e.check=Ft(e.check,S,2,0)),l=0,d=0,e.mode=16184;case 16184:if(1024&e.flags){for(;d<16;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}e.length=l,e.head&&(e.head.extra_len=l),512&e.flags&&4&e.wrap&&(S[0]=255&l,S[1]=l>>>8&255,e.check=Ft(e.check,S,2,0)),l=0,d=0}else e.head&&(e.head.extra=null);e.mode=16185;case 16185:if(1024&e.flags&&(f=e.length,f>o&&(f=o),f&&(e.head&&(A=e.head.extra_len-e.length,e.head.extra||(e.head.extra=new Uint8Array(e.head.extra_len)),e.head.extra.set(s.subarray(r,r+f),A)),512&e.flags&&4&e.wrap&&(e.check=Ft(e.check,s,f,r)),o-=f,r+=f,e.length-=f),e.length))break t;e.length=0,e.mode=16186;case 16186:if(2048&e.flags){if(o===0)break t;f=0;do A=s[r+f++],e.head&&A&&e.length<65536&&(e.head.name+=String.fromCharCode(A));while(A&&f<o);if(512&e.flags&&4&e.wrap&&(e.check=Ft(e.check,s,f,r)),o-=f,r+=f,A)break t}else e.head&&(e.head.name=null);e.length=0,e.mode=16187;case 16187:if(4096&e.flags){if(o===0)break t;f=0;do A=s[r+f++],e.head&&A&&e.length<65536&&(e.head.comment+=String.fromCharCode(A));while(A&&f<o);if(512&e.flags&&4&e.wrap&&(e.check=Ft(e.check,s,f,r)),o-=f,r+=f,A)break t}else e.head&&(e.head.comment=null);e.mode=16188;case 16188:if(512&e.flags){for(;d<16;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}if(4&e.wrap&&l!==(65535&e.check)){n.msg="header crc mismatch",e.mode=lt;break}l=0,d=0}e.head&&(e.head.hcrc=e.flags>>9&1,e.head.done=!0),n.adler=e.check=0,e.mode=Qe;break;case 16189:for(;d<32;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}n.adler=e.check=so(l),l=0,d=0,e.mode=wn;case wn:if(e.havedict===0)return n.next_out=a,n.avail_out=h,n.next_in=r,n.avail_in=o,e.hold=l,e.bits=d,wf;n.adler=e.check=1,e.mode=Qe;case Qe:if(t===Rf||t===An)break t;case Rr:if(e.last){l>>>=7&d,d-=7&d,e.mode=wr;break}for(;d<3;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}switch(e.last=1&l,l>>>=1,d-=1,3&l){case 0:e.mode=16193;break;case 1:if(yf(e),e.mode=Fn,t===An){l>>>=2,d-=2;break t}break;case 2:e.mode=16196;break;case 3:n.msg="invalid block type",e.mode=lt}l>>>=2,d-=2;break;case 16193:for(l>>>=7&d,d-=7&d;d<32;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}if((65535&l)!=(l>>>16^65535)){n.msg="invalid stored block lengths",e.mode=lt;break}if(e.length=65535&l,l=0,d=0,e.mode=Ar,t===An)break t;case Ar:e.mode=16195;case 16195:if(f=e.length,f){if(f>o&&(f=o),f>h&&(f=h),f===0)break t;i.set(s.subarray(r,r+f),a),o-=f,r+=f,h-=f,a+=f,e.length-=f;break}e.mode=Qe;break;case 16196:for(;d<14;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}if(e.nlen=257+(31&l),l>>>=5,d-=5,e.ndist=1+(31&l),l>>>=5,d-=5,e.ncode=4+(15&l),l>>>=4,d-=4,e.nlen>286||e.ndist>30){n.msg="too many length or distance symbols",e.mode=lt;break}e.have=0,e.mode=16197;case 16197:for(;e.have<e.ncode;){for(;d<3;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}e.lens[M[e.have++]]=7&l,l>>>=3,d-=3}for(;e.have<19;)e.lens[M[e.have++]]=0;if(e.lencode=e.lendyn,e.lenbits=7,x={bits:e.lenbits},y=zi(0,e.lens,0,19,e.lencode,0,e.work,x),e.lenbits=x.bits,y){n.msg="invalid code lengths set",e.mode=lt;break}e.have=0,e.mode=16198;case 16198:for(;e.have<e.nlen+e.ndist;){for(;F=e.lencode[l&(1<<e.lenbits)-1],I=F>>>24,C=F>>>16&255,R=65535&F,!(I<=d);){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}if(R<16)l>>>=I,d-=I,e.lens[e.have++]=R;else{if(R===16){for(v=I+2;d<v;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}if(l>>>=I,d-=I,e.have===0){n.msg="invalid bit length repeat",e.mode=lt;break}A=e.lens[e.have-1],f=3+(3&l),l>>>=2,d-=2}else if(R===17){for(v=I+3;d<v;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}l>>>=I,d-=I,A=0,f=3+(7&l),l>>>=3,d-=3}else{for(v=I+7;d<v;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}l>>>=I,d-=I,A=0,f=11+(127&l),l>>>=7,d-=7}if(e.have+f>e.nlen+e.ndist){n.msg="invalid bit length repeat",e.mode=lt;break}for(;f--;)e.lens[e.have++]=A}}if(e.mode===lt)break;if(e.lens[256]===0){n.msg="invalid code -- missing end-of-block",e.mode=lt;break}if(e.lenbits=9,x={bits:e.lenbits},y=zi(1,e.lens,0,e.nlen,e.lencode,0,e.work,x),e.lenbits=x.bits,y){n.msg="invalid literal/lengths set",e.mode=lt;break}if(e.distbits=6,e.distcode=e.distdyn,x={bits:e.distbits},y=zi(2,e.lens,e.nlen,e.ndist,e.distcode,0,e.work,x),e.distbits=x.bits,y){n.msg="invalid distances set",e.mode=lt;break}if(e.mode=Fn,t===An)break t;case Fn:e.mode=Sn;case Sn:if(o>=6&&h>=258){n.next_out=a,n.avail_out=h,n.next_in=r,n.avail_in=o,e.hold=l,e.bits=d,Ef(n,p),a=n.next_out,i=n.output,h=n.avail_out,r=n.next_in,s=n.input,o=n.avail_in,l=e.hold,d=e.bits,e.mode===Qe&&(e.back=-1);break}for(e.back=0;F=e.lencode[l&(1<<e.lenbits)-1],I=F>>>24,C=F>>>16&255,R=65535&F,!(I<=d);){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}if(C&&!(240&C)){for(E=I,g=C,w=R;F=e.lencode[w+((l&(1<<E+g)-1)>>E)],I=F>>>24,C=F>>>16&255,R=65535&F,!(E+I<=d);){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}l>>>=E,d-=E,e.back+=E}if(l>>>=I,d-=I,e.back+=I,e.length=R,C===0){e.mode=16205;break}if(32&C){e.back=-1,e.mode=Qe;break}if(64&C){n.msg="invalid literal/length code",e.mode=lt;break}e.extra=15&C,e.mode=16201;case 16201:if(e.extra){for(v=e.extra;d<v;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}e.length+=l&(1<<e.extra)-1,l>>>=e.extra,d-=e.extra,e.back+=e.extra}e.was=e.length,e.mode=16202;case 16202:for(;F=e.distcode[l&(1<<e.distbits)-1],I=F>>>24,C=F>>>16&255,R=65535&F,!(I<=d);){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}if(!(240&C)){for(E=I,g=C,w=R;F=e.distcode[w+((l&(1<<E+g)-1)>>E)],I=F>>>24,C=F>>>16&255,R=65535&F,!(E+I<=d);){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}l>>>=E,d-=E,e.back+=E}if(l>>>=I,d-=I,e.back+=I,64&C){n.msg="invalid distance code",e.mode=lt;break}e.offset=R,e.extra=15&C,e.mode=16203;case 16203:if(e.extra){for(v=e.extra;d<v;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}e.offset+=l&(1<<e.extra)-1,l>>>=e.extra,d-=e.extra,e.back+=e.extra}if(e.offset>e.dmax){n.msg="invalid distance too far back",e.mode=lt;break}e.mode=16204;case 16204:if(h===0)break t;if(f=p-h,e.offset>f){if(f=e.offset-f,f>e.whave&&e.sane){n.msg="invalid distance too far back",e.mode=lt;break}f>e.wnext?(f-=e.wnext,m=e.wsize-f):m=e.wnext-f,f>e.length&&(f=e.length),b=e.window}else b=i,m=a-e.offset,f=e.length;f>h&&(f=h),h-=f,e.length-=f;do i[a++]=b[m++];while(--f);e.length===0&&(e.mode=Sn);break;case 16205:if(h===0)break t;i[a++]=e.length,h--,e.mode=Sn;break;case wr:if(e.wrap){for(;d<32;){if(o===0)break t;o--,l|=s[r++]<<d,d+=8}if(p-=h,n.total_out+=p,e.total+=p,4&e.wrap&&p&&(n.adler=e.check=e.flags?Ft(e.check,i,p,a-p):Ui(e.check,i,p,a-p)),p=h,4&e.wrap&&(e.flags?l:so(l))!==e.check){n.msg="incorrect data check",e.mode=lt;break}l=0,d=0}e.mode=16207;case 16207:if(e.wrap&&e.flags){for(;d<32;){if(o===0)break t;o--,l+=s[r++]<<d,d+=8}if(4&e.wrap&&l!==(4294967295&e.total)){n.msg="incorrect length check",e.mode=lt;break}l=0,d=0}e.mode=16208;case 16208:y=Af;break t;case lt:y=Ja;break t;case 16210:return to;default:return _e}return n.next_out=a,n.avail_out=h,n.next_in=r,n.avail_in=o,e.hold=l,e.bits=d,(e.wsize||p!==n.avail_out&&e.mode<lt&&(e.mode<wr||t!==Ka))&&ro(n,n.output,n.next_out,p-n.avail_out),u-=n.avail_in,p-=n.avail_out,n.total_in+=u,n.total_out+=p,e.total+=p,4&e.wrap&&p&&(n.adler=e.check=e.flags?Ft(e.check,i,p,n.next_out-p):Ui(e.check,i,p,n.next_out-p)),n.data_type=e.bits+(e.last?64:0)+(e.mode===Qe?128:0)+(e.mode===Fn||e.mode===Ar?256:0),(u===0&&p===0||t===Ka)&&y===Os&&(y=Ff),y},inflateEnd:n=>{if(Ns(n))return _e;let t=n.state;return t.window&&(t.window=null),n.state=null,Os},inflateGetHeader:(n,t)=>{if(Ns(n))return _e;const e=n.state;return 2&e.wrap?(e.head=t,t.done=!1,Os):_e},inflateSetDictionary:(n,t)=>{const e=t.length;let s,i,r;return Ns(n)?_e:(s=n.state,s.wrap!==0&&s.mode!==wn?_e:s.mode===wn&&(i=1,i=Ui(i,t,e,0),i!==s.check)?Ja:(r=ro(n,t,e,e),r?(s.mode=16210,to):(s.havedict=1,Os)))},inflateInfo:"pako inflate (from Nodeca project)"},xf=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1};const il=Object.prototype.toString,{Z_NO_FLUSH:Of,Z_FINISH:vf,Z_OK:Gi,Z_STREAM_END:yr,Z_NEED_DICT:xr,Z_STREAM_ERROR:Lf,Z_DATA_ERROR:ao,Z_MEM_ERROR:Nf}=an;function ki(n){this.options=Xo({chunkSize:65536,windowBits:15,to:""},n||{});const t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,t.windowBits===0&&(t.windowBits=-15)),!(t.windowBits>=0&&t.windowBits<16)||n&&n.windowBits||(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&(15&t.windowBits||(t.windowBits|=15)),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Ko,this.strm.avail_out=0;let e=es.inflateInit2(this.strm,t.windowBits);if(e!==Gi)throw new Error(Us[e]);if(this.header=new xf,es.inflateGetHeader(this.strm,this.header),t.dictionary&&(typeof t.dictionary=="string"?t.dictionary=Ia(t.dictionary):il.call(t.dictionary)==="[object ArrayBuffer]"&&(t.dictionary=new Uint8Array(t.dictionary)),t.raw&&(e=es.inflateSetDictionary(this.strm,t.dictionary),e!==Gi)))throw new Error(Us[e])}function Or(n,t){const e=new ki(t);if(e.push(n),e.err)throw e.msg||Us[e.err];return e.result}ki.prototype.push=function(n,t){const e=this.strm,s=this.options.chunkSize,i=this.options.dictionary;let r,a,o;if(this.ended)return!1;for(a=t===~~t?t:t===!0?vf:Of,il.call(n)==="[object ArrayBuffer]"?e.input=new Uint8Array(n):e.input=n,e.next_in=0,e.avail_in=e.input.length;;){for(e.avail_out===0&&(e.output=new Uint8Array(s),e.next_out=0,e.avail_out=s),r=es.inflate(e,a),r===xr&&i&&(r=es.inflateSetDictionary(e,i),r===Gi?r=es.inflate(e,a):r===ao&&(r=xr));e.avail_in>0&&r===yr&&e.state.wrap>0&&n[e.next_in]!==0;)es.inflateReset(e),r=es.inflate(e,a);switch(r){case Lf:case ao:case xr:case Nf:return this.onEnd(r),this.ended=!0,!1}if(o=e.avail_out,e.next_out&&(e.avail_out===0||r===yr))if(this.options.to==="string"){let h=lf(e.output,e.next_out),l=e.next_out-h,d=of(e.output,h);e.next_out=l,e.avail_out=s-l,l&&e.output.set(e.output.subarray(h,h+l),0),this.onData(d)}else this.onData(e.output.length===e.next_out?e.output:e.output.subarray(0,e.next_out));if(r!==Gi||o!==0){if(r===yr)return r=es.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,!0;if(e.avail_in===0)break}}return!0},ki.prototype.onData=function(n){this.chunks.push(n)},ki.prototype.onEnd=function(n){n===Gi&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=$o(this.chunks)),this.chunks=[],this.err=n,this.msg=this.strm.msg};var Pf={Inflate:ki,inflate:Or,inflateRaw:function(n,t){return(t=t||{}).raw=!0,Or(n,t)},ungzip:Or};const{Deflate:Mf,deflate:Df,deflateRaw:Uf,gzip:Vf}=_f,{Inflate:Bf,inflate:zf,inflateRaw:Gf,ungzip:kf}=Pf;var Yf={Deflate:Mf,deflate:Df,deflateRaw:Uf,gzip:Vf,Inflate:Bf,inflate:zf,inflateRaw:Gf,ungzip:kf,constants:an};const Hf=32;new Array(Hf).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}));class as{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let r=0,a=t.length;r<a;r++){const o=t[r][e];s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let r=0,a=e.length;r<a;r++){const o=e[r],h=t.dot(o);s=h<s?h:s,i=h>i?h:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}as.prototype.setFromBox=function(){const n=new T;return function(t,e){const s=e.min,i=e.max;let r=1/0,a=-1/0;for(let o=0;o<=1;o++)for(let h=0;h<=1;h++)for(let l=0;l<=1;l++){n.x=s.x*o+i.x*(1-o),n.y=s.y*h+i.y*(1-h),n.z=s.z*l+i.z*(1-l);const d=t.dot(n);r=Math.min(d,r),a=Math.max(d,a)}this.min=r,this.max=a}}();const Wf=function(){const n=new T,t=new T,e=new T;return function(s,i,r){const a=s.start,o=n,h=i.start,l=t;e.subVectors(a,h),n.subVectors(s.end,s.start),t.subVectors(i.end,i.start);const d=e.dot(l),u=l.dot(o),p=l.dot(l),f=e.dot(o),m=o.dot(o)*p-u*u;let b,I;b=m!==0?(d*u-f*p)/m:0,I=(d+b*u)/p,r.x=b,r.y=I}}(),Kr=function(){const n=new He,t=new T,e=new T;return function(s,i,r,a){Wf(s,i,n);let o=n.x,h=n.y;if(o>=0&&o<=1&&h>=0&&h<=1)return s.at(o,r),void i.at(h,a);if(o>=0&&o<=1)return h<0?i.at(0,a):i.at(1,a),void s.closestPointToPoint(a,!0,r);if(h>=0&&h<=1)return o<0?s.at(0,r):s.at(1,r),void i.closestPointToPoint(r,!0,a);{let l,d;l=o<0?s.start:s.end,d=h<0?i.start:i.end;const u=t,p=e;return s.closestPointToPoint(d,!0,t),i.closestPointToPoint(l,!0,e),u.distanceToSquared(d)<=p.distanceToSquared(l)?(r.copy(u),void a.copy(d)):(r.copy(l),void a.copy(p))}}}(),jf=function(){const n=new T,t=new T,e=new Yt,s=new Ee;return function(i,r){const{radius:a,center:o}=i,{a:h,b:l,c:d}=r;if(s.start=h,s.end=l,s.closestPointToPoint(o,!0,n).distanceTo(o)<=a||(s.start=h,s.end=d,s.closestPointToPoint(o,!0,n).distanceTo(o)<=a)||(s.start=l,s.end=d,s.closestPointToPoint(o,!0,n).distanceTo(o)<=a))return!0;const u=r.getPlane(e);if(Math.abs(u.distanceToPoint(o))<=a){const p=u.projectPoint(o,t);if(r.containsPoint(p))return!0}return!1}}();function vr(n){return Math.abs(n)<1e-15}class Fe extends ji{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new T),this.satBounds=new Array(4).fill().map(()=>new as),this.points=[this.a,this.b,this.c],this.sphere=new rn,this.plane=new Yt,this.needsUpdate=!0}intersectsSphere(t){return jf(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,r=this.satAxes,a=this.satBounds,o=r[0],h=a[0];this.getNormal(o),h.setFromPoints(o,i);const l=r[1],d=a[1];l.subVectors(t,e),d.setFromPoints(l,i);const u=r[2],p=a[2];u.subVectors(e,s),p.setFromPoints(u,i);const f=r[3],m=a[3];f.subVectors(s,t),m.setFromPoints(f,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,t),this.needsUpdate=!1}}Fe.prototype.closestPointToSegment=function(){const n=new T,t=new T,e=new Ee;return function(s,i=null,r=null){const{start:a,end:o}=s,h=this.points;let l,d=1/0;for(let u=0;u<3;u++){const p=(u+1)%3;e.start.copy(h[u]),e.end.copy(h[p]),Kr(e,s,n,t),l=n.distanceToSquared(t),l<d&&(d=l,i&&i.copy(n),r&&r.copy(t))}return this.closestPointToPoint(a,n),l=a.distanceToSquared(n),l<d&&(d=l,i&&i.copy(n),r&&r.copy(a)),this.closestPointToPoint(o,n),l=o.distanceToSquared(n),l<d&&(d=l,i&&i.copy(n),r&&r.copy(o)),Math.sqrt(d)}}(),Fe.prototype.intersectsTriangle=function(){const n=new Fe,t=new Array(3),e=new Array(3),s=new as,i=new as,r=new T,a=new T,o=new T,h=new T,l=new T,d=new Ee,u=new Ee,p=new Ee,f=new T;function m(b,I,C){const R=b.points;let E=0,g=-1;for(let w=0;w<3;w++){const{start:A,end:y}=d;A.copy(R[w]),y.copy(R[(w+1)%3]),d.delta(a);const F=vr(I.distanceToPoint(A));if(vr(I.normal.dot(a))&&F){C.copy(d),E=2;break}const S=I.intersectLine(d,f);if(!S&&F&&f.copy(A),(S||F)&&!vr(f.distanceTo(y))){if(E<=1)(E===1?C.start:C.end).copy(f),F&&(g=E);else if(E>=2){(g===1?C.start:C.end).copy(f),E=2;break}if(E++,E===2&&g===-1)break}}return E}return function(b,I=null,C=!1){this.needsUpdate&&this.update(),b.isExtendedTriangle?b.needsUpdate&&b.update():(n.copy(b),n.update(),b=n);const R=this.plane,E=b.plane;if(Math.abs(R.normal.dot(E.normal))>1-1e-10){const g=this.satBounds,w=this.satAxes;e[0]=b.a,e[1]=b.b,e[2]=b.c;for(let F=0;F<4;F++){const S=g[F],x=w[F];if(s.setFromPoints(x,e),S.isSeparated(s))return!1}const A=b.satBounds,y=b.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let F=0;F<4;F++){const S=A[F],x=y[F];if(s.setFromPoints(x,t),S.isSeparated(s))return!1}for(let F=0;F<4;F++){const S=w[F];for(let x=0;x<4;x++){const v=y[x];if(r.crossVectors(S,v),s.setFromPoints(r,t),i.setFromPoints(r,e),s.isSeparated(i))return!1}}return I&&(C||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),I.start.set(0,0,0),I.end.set(0,0,0)),!0}{const g=m(this,E,u);if(g===1&&b.containsPoint(u.end))return I&&(I.start.copy(u.end),I.end.copy(u.end)),!0;if(g!==2)return!1;const w=m(b,R,p);if(w===1&&this.containsPoint(p.end))return I&&(I.start.copy(p.end),I.end.copy(p.end)),!0;if(w!==2)return!1;if(u.delta(o),p.delta(h),o.dot(h)<0){let x=p.start;p.start=p.end,p.end=x}const A=u.start.dot(o),y=u.end.dot(o),F=p.start.dot(o),S=p.end.dot(o);return(A===S||F===y||y<F!=A<S)&&(I&&(l.subVectors(u.start,p.start),l.dot(o)>0?I.start.copy(u.start):I.start.copy(p.start),l.subVectors(u.end,p.end),l.dot(o)<0?I.end.copy(u.end):I.end.copy(p.end)),!0)}}}(),Fe.prototype.distanceToPoint=function(){const n=new T;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}}(),Fe.prototype.distanceToTriangle=function(){const n=new T,t=new T,e=["a","b","c"],s=new Ee,i=new Ee;return function(r,a=null,o=null){const h=a||o?s:null;if(this.intersectsTriangle(r,h))return(a||o)&&(a&&h.getCenter(a),o&&h.getCenter(o)),0;let l=1/0;for(let d=0;d<3;d++){let u;const p=e[d],f=r[p];this.closestPointToPoint(f,n),u=f.distanceToSquared(n),u<l&&(l=u,a&&a.copy(n),o&&o.copy(f));const m=this[p];r.closestPointToPoint(m,n),u=m.distanceToSquared(n),u<l&&(l=u,a&&a.copy(m),o&&o.copy(n))}for(let d=0;d<3;d++){const u=e[d],p=e[(d+1)%3];s.set(this[u],this[p]);for(let f=0;f<3;f++){const m=e[f],b=e[(f+1)%3];i.set(r[m],r[b]),Kr(s,i,n,t);const I=n.distanceToSquared(t);I<l&&(l=I,a&&a.copy(n),o&&o.copy(t))}}return Math.sqrt(l)}}();class Ht{constructor(t,e,s){this.isOrientedBox=!0,this.min=new T,this.max=new T,this.matrix=new rt,this.invMatrix=new rt,this.points=new Array(8).fill().map(()=>new T),this.satAxes=new Array(3).fill().map(()=>new T),this.satBounds=new Array(3).fill().map(()=>new as),this.alignedSatBounds=new Array(3).fill().map(()=>new as),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}Ht.prototype.update=function(){return function(){const n=this.matrix,t=this.min,e=this.max,s=this.points;for(let h=0;h<=1;h++)for(let l=0;l<=1;l++)for(let d=0;d<=1;d++){const u=s[1*h|2*l|4*d];u.x=h?e.x:t.x,u.y=l?e.y:t.y,u.z=d?e.z:t.z,u.applyMatrix4(n)}const i=this.satBounds,r=this.satAxes,a=s[0];for(let h=0;h<3;h++){const l=r[h],d=i[h],u=s[1<<h];l.subVectors(a,u),d.setFromPoints(l,s)}const o=this.alignedSatBounds;o[0].setFromPointsField(s,"x"),o[1].setFromPointsField(s,"y"),o[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}(),Ht.prototype.intersectsBox=function(){const n=new as;return function(t){this.needsUpdate&&this.update();const e=t.min,s=t.max,i=this.satBounds,r=this.satAxes,a=this.alignedSatBounds;if(n.min=e.x,n.max=s.x,a[0].isSeparated(n)||(n.min=e.y,n.max=s.y,a[1].isSeparated(n))||(n.min=e.z,n.max=s.z,a[2].isSeparated(n)))return!1;for(let o=0;o<3;o++){const h=r[o],l=i[o];if(n.setFromBox(h,t),l.isSeparated(n))return!1}return!0}}(),Ht.prototype.intersectsTriangle=function(){const n=new Fe,t=new Array(3),e=new as,s=new as,i=new T;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(n.copy(r),n.update(),r=n);const a=this.satBounds,o=this.satAxes;t[0]=r.a,t[1]=r.b,t[2]=r.c;for(let u=0;u<3;u++){const p=a[u],f=o[u];if(e.setFromPoints(f,t),p.isSeparated(e))return!1}const h=r.satBounds,l=r.satAxes,d=this.points;for(let u=0;u<3;u++){const p=h[u],f=l[u];if(e.setFromPoints(f,d),p.isSeparated(e))return!1}for(let u=0;u<3;u++){const p=o[u];for(let f=0;f<4;f++){const m=l[f];if(i.crossVectors(p,m),e.setFromPoints(i,t),s.setFromPoints(i,d),e.isSeparated(s))return!1}}return!0}}(),Ht.prototype.closestPointToPoint=function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}(),Ht.prototype.distanceToPoint=function(){const n=new T;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}}(),Ht.prototype.distanceToBox=function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new Ee),e=new Array(12).fill().map(()=>new Ee),s=new T,i=new T;return function(r,a=0,o=null,h=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(o||h)&&(r.getCenter(i),this.closestPointToPoint(i,s),r.closestPointToPoint(s,i),o&&o.copy(s),h&&h.copy(i)),0;const l=a*a,d=r.min,u=r.max,p=this.points;let f=1/0;for(let b=0;b<8;b++){const I=p[b];i.copy(I).clamp(d,u);const C=I.distanceToSquared(i);if(C<f&&(f=C,o&&o.copy(I),h&&h.copy(i),C<l))return Math.sqrt(C)}let m=0;for(let b=0;b<3;b++)for(let I=0;I<=1;I++)for(let C=0;C<=1;C++){const R=(b+1)%3,E=(b+2)%3,g=1<<b|I<<R|C<<E,w=p[I<<R|C<<E],A=p[g];t[m].set(w,A);const y=n[b],F=n[R],S=n[E],x=e[m],v=x.start,M=x.end;v[y]=d[y],v[F]=I?d[F]:u[F],v[S]=C?d[S]:u[F],M[y]=u[y],M[F]=I?d[F]:u[F],M[S]=C?d[S]:u[F],m++}for(let b=0;b<=1;b++)for(let I=0;I<=1;I++)for(let C=0;C<=1;C++){i.x=b?u.x:d.x,i.y=I?u.y:d.y,i.z=C?u.z:d.z,this.closestPointToPoint(i,s);const R=i.distanceToSquared(s);if(R<f&&(f=R,o&&o.copy(s),h&&h.copy(i),R<l))return Math.sqrt(R)}for(let b=0;b<12;b++){const I=t[b];for(let C=0;C<12;C++){const R=e[C];Kr(I,R,s,i);const E=s.distanceToSquared(i);if(E<f&&(f=E,o&&o.copy(s),h&&h.copy(i),E<l))return Math.sqrt(E)}}return Math.sqrt(f)}}();class qf{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Zf extends qf{constructor(){super(()=>new Fe)}}new Zf;const nl=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const n=[];let t=null;this.setBuffer=e=>{t&&n.push(t),t=e,this.float32Array=new Float32Array(e),this.uint16Array=new Uint16Array(e),this.uint32Array=new Uint32Array(e)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,n.length!==0&&this.setBuffer(n.pop())}}};new T;new T;new T;new T;new T;new He;new He;new He;new T;new T;new T;new T;new Et;new T;new T;new Et;new Fe;new Fe;new rt;new Ht;new Ht;new rt;new Ht;new Ht;new T;new T;new T;new T;new T;new T;new Et;new Fe;new Fe;new rt;new Ht;new Ht;new rt;new Ht;new Ht;new T;new T;new T;new T;new nl.constructor;new nl.constructor;new Et;new Et;new Et;new Et;new Ht;new Et;new si;new rt;class rl{constructor(t,e){c(this,"meshes"),c(this,"_templateController",new Fp),c(this,"_meshIds",new Set),c(this,"_idGenerator",new fa),c(this,"_modelCode"),this.meshes=e,this._modelCode=this.getModelCode(t)}dispose(){js.delete(this._meshIds)}useMesh(t,e,s){const i=this.meshCode(t,s);js.lockIn(e),this._templateController.add(i,e)}getMesh(t,e){const s=this.meshCode(t,e);return js.get(s)??this._templateController.get(s)}saveMesh(t,e,s){Ae.forEach(e,js.updateMeshMemory);const i=this.meshCode(t,s);js.add(i,e),this._meshIds.add(i)}meshCode(t,e){const s=[this._modelCode,this.getRepresentation(),e,t];return this._idGenerator.generate(s)}getModelCode(t){return this._idGenerator.generate([t])}}const Yi=32767;var Ps=(n=>(n[n.NONE=0]="NONE",n[n.AABB=1]="AABB",n[n.CUSTOM=2]="CUSTOM",n))(Ps||{});const Kt=class Re{static getProfile(t,e,s){return t.type()===Dt.BIG?t.bigProfiles(e,s):t.profiles(e,s)}static getPoints(t){const e=new Float32Array(3*t.pointsLength());for(let s=0;s<t.pointsLength();s++)t.points(s,this._tempPoint),e[3*s]=this._tempPoint.x(),e[3*s+1]=this._tempPoint.y(),e[3*s+2]=this._tempPoint.z();return e}static getProfileIndices(t,e){const s=t.type()===Dt.BIG,i={outer:[],inners:[]},r=s?t.bigHolesLength():t.holesLength(),a=s?"bigHoles":"holes",o=Re.getProfile(t,e);i.outer=Array.from(o.indicesArray());for(let h=0;h<r;h++){const l=t[a](h);if(l.profileId()===e){const d=Array.from(l.indicesArray());i.inners.push(d)}}return i}static getHole(t,e,s){return t.type()===Dt.BIG?t.bigHoles(e,s):t.holes(e,s)}static getProfilesLength(t){return t.type()===Dt.BIG?t.bigProfilesLength():t.profilesLength()}static getHolesLength(t){return t.type()===Dt.BIG?t.bigHolesLength():t.holesLength()}static getShell(t,e){return t.shells(e,this._shell)}static point(t,e,s){t instanceof It&&t.points(e,this._tempPoint);const i=this._tempPoint.x(),r=this._tempPoint.y(),a=this._tempPoint.z();s.set(i,r,a)}static getNormalsOfShellProfile(t,e){const s=Re.getProfilesLength(t);for(let i=0;i<s;i++){const r=Re.getProfile(t,i),a=this.fetchNormalsOfProfile(t,r);e.push(a)}return e}static computeNormalsAvg(t,e,s,i){this.setupNormalBuffer(t);const r=s[e];for(let a=0;a<t.length;a++){const o=t[a],h=i.get(o);this.aggregateNormals(h,s,r),this.computeAvgNormal(a)}return this._normalBuffer}static getBuffer(t){const e=t.bb,s=e.__offset(t.bb_pos,8),i=3*t.pointsLength(),r=e.__vector(t.bb_pos+s),a=e.bytes().buffer;return new Float32Array(a,r,i)}static getPointsShell(t){return this._pointsByProfile.clear(),this.fetchAllPointsByProfile(t),Re.fetchAllPointsByHole(t),this._pointsByProfile}static addNormals(t,e,s){for(const i of t){const r=e[i];s.dot(r)>this._faceThreshold&&this._tempNormal.add(r)}}static setupNormalBuffer(t){const e=3*t.length;this._normalBuffer.length<e&&(this._normalBuffer=new Int16Array(e))}static fetchNormalsOfProfile(t,e){const s=e.indicesLength();return this.isTooSmall(t,s)?new T(1,0,0):this.computeProfileNormal(s,e,t)}static fetchAllPointsByHole(t){const e=Re.getHolesLength(t),s=this.getTempHole(t);for(let i=0;i<e;i++){Re.getHole(t,i,s);const r=s.profileId(),a=s.indicesLength();for(let o=0;o<a;o++){const h=s.indices(o);Re.savePointByProfile(h,r)}}}static computeProfileNormal(t,e,s){this._v3.set(0,0,0);for(let r=0;r<t;r++)this.fetchPointsForNormal(r,t,e,s),this.computeProfilePointNormal();const i=this._v3.clone();return i.normalize(),i}static computeProfilePointNormal(){const t=this._v1.x-this._v2.x,e=this._v1.y-this._v2.y,s=this._v1.z-this._v2.z,i=this._v1.x+this._v2.x,r=this._v1.y+this._v2.y,a=this._v1.z+this._v2.z;this._v3.x+=e*a,this._v3.y+=s*i,this._v3.z+=t*r}static aggregateNormals(t,e,s){if(this._tempNormal.set(0,0,0),!t||!t.length)return void this._tempNormal.set(1,0,0);if(t.length===1){const i=t[0];this._tempNormal=e[i].clone()}else Re.addNormals(t,e,s)}static fetchPointsForNormal(t,e,s,i){const r=(t+1)%e,a=s.indices(t),o=s.indices(r);this.point(i,a,this._v1),this.point(i,o,this._v2)}static savePointByProfile(t,e){this._pointsByProfile.has(t)||this._pointsByProfile.set(t,[]),this._pointsByProfile.get(t).push(e)}static isTooSmall(t,e){return t.pointsLength()<=2||e<=2}static fetchAllPointsByProfile(t){const e=this.getProfilesLength(t),s=this.getTempProfile(t);for(let i=0;i<e;i++){Re.getProfile(t,i,s);const r=s.indicesLength();for(let a=0;a<r;a++){const o=s.indices(a);Re.savePointByProfile(o,i)}}}static computeAvgNormal(t){this._tempNormal.normalize(),this._tempNormal.multiplyScalar(Yi),this._tempNormal.toArray(this._normalBuffer,3*t)}static getTempProfile(t){return t.type()===Dt.BIG?this._bigShellProfile:this._shellProfile}static getTempHole(t){return t.type()===Dt.BIG?this._bigShellHole:this._shellHole}};c(Kt,"_faceThreshold",Math.cos(Math.PI/8)),c(Kt,"_shell",new It),c(Kt,"_normalBuffer",new Int16Array),c(Kt,"_tempNormal",new T),c(Kt,"_tempPoint",new xt),c(Kt,"_shellProfile",new ce),c(Kt,"_bigShellProfile",new he),c(Kt,"_shellHole",new oe),c(Kt,"_bigShellHole",new ae),c(Kt,"_pointsByProfile",new Map),c(Kt,"_v1",new T),c(Kt,"_v2",new T),c(Kt,"_v3",new T);let Q=Kt;class Xf{constructor(){c(this,"_shellHole",new oe),c(this,"_bigShellHole",new ae),c(this,"holePoints",0),c(this,"profilePoints",0),c(this,"triangleAmount",0),c(this,"indexCount",0),c(this,"meshes",[]),c(this,"_shellProfile",new ce),c(this,"_bigShellProfile",new he)}newMeshTemplate(t){return this.getIsEmpty(t)?{objectClass:Wt.SHELL}:(this.reset(!0),this.processShell(t),this.getResult())}manageDataLeft(){this.getIsDataLeft()&&this.setMesh()}getIsEmpty(t){return Q.getProfilesLength(t)===0}processShellHoles(t,e){let s=!1;const i=Q.getHolesLength(t),r=this.getTempHole(t);for(let a=0;a<i;a++)Q.getHole(t,a,r),r.profileId()===e&&(this.updateBuffers(t,s),s=!0);this.manageFoundHoles(t,s)}newMesh(){return{objectClass:Wt.SHELL,indexCount:3*this.triangleAmount,positionCount:3*(this.holePoints+this.profilePoints),normalCount:3*(this.holePoints+this.profilePoints)}}reset(t){this.holePoints=0,this.profilePoints=0,this.triangleAmount=0,t&&(this.meshes=void 0)}getIsDataLeft(){const t=this.triangleAmount>0,e=this.holePoints>0,s=this.profilePoints>0;return t||e||s}processShell(t){const e=Q.getProfilesLength(t),s=this.getTempProfile(t);for(let i=0;i<e;i++)Q.getProfile(t,i,s),this.indexCount=s.indicesLength(),this.profilePoints+=this.indexCount,this.processShellHoles(t,i),this.manageMemory();this.manageDataLeft()}manageFoundHoles(t,e){const s=this.getTempProfile(t).indicesLength();e?this.triangleAmount+=s:s>2&&(this.triangleAmount+=s-2)}getResult(){const t=this.meshes;return this.meshes=void 0,t}manageMemory(){this.holePoints+this.profilePoints+this.indexCount>ni&&this.setMesh()}updateBuffers(t,e){const s=this.getTempHole(t);this.holePoints+=s.indicesLength(),this.triangleAmount+=s.indicesLength(),e&&(this.triangleAmount+=2)}setMesh(){const t=this.newMesh();this.meshes?Array.isArray(this.meshes)?this.meshes.push(t):this.meshes=[this.meshes,t]:this.meshes=t,this.reset(!1)}getTempProfile(t){return t.type()===Dt.BIG?this._bigShellProfile:this._shellProfile}getTempHole(t){return t.type()===Dt.BIG?this._bigShellHole:this._shellHole}}var Jr=(n=>(n[n.four=4]="four",n[n.three=3]="three",n))(Jr||{});function $f(n,t,e,s,i,r){const a=t&&t.length,o=a?t[0]*e:n.length;let h,l,d,u=oo(n,0,o,e,!0,s,i);if(u&&u.next!==u.prev){if(a&&(u=function(p,f,m,b,I,C){const R=[];for(let E=0,g=f.length;E<g;E++){const w=oo(p,f[E]*b,E<g-1?f[E+1]*b:p.length,b,!1,I,C);w===w.next&&(w.steiner=!0),R.push(np(w))}R.sort(ep);for(let E=0;E<R.length;E++)m=Ts(m=sp(R[E],m),m.next);return m}(n,t,u,e,s,i)),n.length>80*e){let p=n[s],f=n[i];h=p,l=f;for(let m=e;m<o;m+=e){const b=n[m+s],I=n[m+i];b<h&&(h=b),I<l&&(l=I),b>p&&(p=b),I>f&&(f=I)}d=Math.max(p-h,f-l),d=d!==0?1/d:0}tn(u,r,e,h,l,d)}}function oo(n,t,e,s,i,r,a){let o,h,l;if(i===function(d,u,p,f,m,b){let I=0;for(let C=u,R=p-f;C<p;C+=f)I+=(d[R+m]-d[C+m])*(d[C+b]+d[R+b]),R=C;return I}(n,t,e,s,r,a)>0)for(l=t;l<e;l+=s)o=lo(l,n[l+r],n[l+a],o);else for(l=e-s;l>=t;l-=s)o=lo(l,n[l+r],n[l+a],o);return o&&ar(o,o.next)&&(h=o.next,sn(o),o=h),o}function Ts(n,t){if(!n)return n;t||(t=n);let e,s,i=n;do if(e=!1,i.steiner||!ar(i,i.next)&&ut(i.prev,i,i.next)!==0)i=i.next;else{if(s=i.prev,sn(i),i=t=s,i===i.next)break;e=!0}while(e||i!==t);return t}function tn(n,t,e,s,i,r,a){!a&&r&&function(h,l,d,u){let p=h;do p.z===null&&(p.z=ta(p.x,p.y,l,d,u)),p.prevZ=p.prev,p.nextZ=p.next,p=p.next;while(p!==h);p.prevZ.nextZ=null,p.prevZ=null,function(f){let m,b=1;do{let I,C=f;f=null;let R=null;for(m=0;C;){m++;let E=C,g=0;for(let A=0;A<b&&(g++,E=E.nextZ,E);A++);let w=b;for(;g>0||w>0&&E;)g!==0&&(w===0||!E||C.z<=E.z)?(I=C,C=C.nextZ,g--):(I=E,E=E.nextZ,w--),R?R.nextZ=I:f=I,I.prevZ=R,R=I;C=E}R.nextZ=null,b*=2}while(m>1)}(p)}(n,s,i,r);let o=n;for(;n.prev!==n.next;){const h=n.prev,l=n.next;if(r?Kf(n,s,i,r):Qf(n))t(h.i/e,n.i/e,l.i/e),sn(n),n=l.next,o=l.next;else if((n=l)===o){a?a===1?tn(n=Jf(Ts(n),t,e),t,e,s,i,r,2):a===2&&tp(n,t,e,s,i,r):tn(Ts(n),t,e,s,i,r,1);break}}}function Qf(n){const t=n.prev,e=n,s=n.next;if(ut(t,e,s)>=0)return!1;let i=n.next.next;for(;i!==n.prev;){if(Qs(t.x,t.y,e.x,e.y,s.x,s.y,i.x,i.y)&&ut(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function Kf(n,t,e,s){const i=n.prev,r=n,a=n.next;if(ut(i,r,a)>=0)return!1;const o=Math.min(i.x,r.x,a.x),h=Math.min(i.y,r.y,a.y),l=Math.max(i.x,r.x,a.x),d=Math.max(i.y,r.y,a.y),u=ta(o,h,t,e,s),p=ta(l,d,t,e,s);let f=n.prevZ,m=n.nextZ;for(;f&&f.z>=u&&m&&m.z<=p;){if(f!==n.prev&&f!==n.next&&Qs(i.x,i.y,r.x,r.y,a.x,a.y,f.x,f.y)&&ut(f.prev,f,f.next)>=0||(f=f.prevZ,m!==n.prev&&m!==n.next&&Qs(i.x,i.y,r.x,r.y,a.x,a.y,m.x,m.y)&&ut(m.prev,m,m.next)>=0))return!1;m=m.nextZ}for(;f&&f.z>=u;){if(f!==n.prev&&f!==n.next&&Qs(i.x,i.y,r.x,r.y,a.x,a.y,f.x,f.y)&&ut(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;m&&m.z<=p;){if(m!==n.prev&&m!==n.next&&Qs(i.x,i.y,r.x,r.y,a.x,a.y,m.x,m.y)&&ut(m.prev,m,m.next)>=0)return!1;m=m.nextZ}return!0}function Jf(n,t,e){let s=n;do{const i=s.prev,r=s.next.next;!ar(i,r)&&al(i,s,s.next,r)&&en(i,r)&&en(r,i)&&(t(i.i/e,s.i/e,r.i/e),sn(s.next),sn(s),s=n=r),s=s.next}while(s!==n);return Ts(s)}function tp(n,t,e,s,i,r){let a=n;do{let o=a.next.next;for(;o!==a.prev;){if(a.i!==o.i&&rp(a,o)){let h=ol(a,o);return a=Ts(a,a.next),h=Ts(h,h.next),tn(a,t,e,s,i,r),void tn(h,t,e,s,i,r)}o=o.next}a=a.next}while(a!==n)}function ep(n,t){return n.x-t.x}function sp(n,t){const e=function(r,a){let o=a;const h=r.x,l=r.y;let d,u=-1/0;do{if(l<=o.y&&l>=o.next.y&&o.next.y!==o.y){const I=o.x+(l-o.y)*(o.next.x-o.x)/(o.next.y-o.y);if(I<=h&&I>u){if(u=I,I===h){if(l===o.y)return o;if(l===o.next.y)return o.next}d=o.x<o.next.x?o:o.next}}o=o.next}while(o!==a);if(!d)return null;if(h===u)return d;const p=d,f=d.x,m=d.y;let b=1/0;o=d;do{if(h>=o.x&&o.x>=f&&h!==o.x&&Qs(l<m?h:u,l,f,m,l<m?u:h,l,o.x,o.y)){const I=Math.abs(l-o.y)/(h-o.x);en(o,r)&&(I<b||I===b&&(o.x>d.x||o.x===d.x&&ip(d,o)))&&(d=o,b=I)}o=o.next}while(o!==p);return d}(n,t);if(!e)return t;const s=ol(e,n),i=Ts(e,e.next);return Ts(s,s.next),t===t.next||e===t?i:t}function ip(n,t){return ut(n.prev,n,t.prev)<0&&ut(t.next,n,n.next)<0}function ta(n,t,e,s,i){return(n=1431655765&((n=858993459&((n=252645135&((n=16711935&((n=32767*(n-e)*i)|n<<8))|n<<4))|n<<2))|n<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-s)*i)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function np(n){let t=n,e=n;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==n);return e}function Qs(n,t,e,s,i,r,a,o){return(i-a)*(t-o)-(n-a)*(r-o)>=0&&(n-a)*(s-o)-(e-a)*(t-o)>=0&&(e-a)*(r-o)-(i-a)*(s-o)>=0}function rp(n,t){return n.next.i!==t.i&&n.prev.i!==t.i&&!function(e,s){let i=e;do{if(i.i!==e.i&&i.next.i!==e.i&&i.i!==s.i&&i.next.i!==s.i&&al(i,i.next,e,s))return!0;i=i.next}while(i!==e);return!1}(n,t)&&(en(n,t)&&en(t,n)&&function(e,s){let i=e,r=!1;const a=(e.x+s.x)/2,o=(e.y+s.y)/2;do i.y>o!=i.next.y>o&&i.next.y!==i.y&&a<(i.next.x-i.x)*(o-i.y)/(i.next.y-i.y)+i.x&&(r=!r),i=i.next;while(i!==e);return r}(n,t)&&(ut(n.prev,n,t.prev)||ut(n,t.prev,t))||ar(n,t)&&ut(n.prev,n,n.next)>0&&ut(t.prev,t,t.next)>0)}function ut(n,t,e){return(t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y)}function ar(n,t){return n.x===t.x&&n.y===t.y}function al(n,t,e,s){const i=xn(ut(n,t,e)),r=xn(ut(n,t,s)),a=xn(ut(e,s,n)),o=xn(ut(e,s,t));return i!==r&&a!==o||!(i!==0||!yn(n,e,t))||!(r!==0||!yn(n,s,t))||!(a!==0||!yn(e,n,s))||!(o!==0||!yn(e,t,s))}function yn(n,t,e){return t.x<=Math.max(n.x,e.x)&&t.x>=Math.min(n.x,e.x)&&t.y<=Math.max(n.y,e.y)&&t.y>=Math.min(n.y,e.y)}function xn(n){return n>0?1:n<0?-1:0}function en(n,t){return ut(n.prev,n,n.next)<0?ut(n,t,n.next)>=0&&ut(n,n.prev,t)>=0:ut(n,t,n.prev)<0||ut(n,n.next,t)<0}function ol(n,t){const e=ea(n.i,n.x,n.y),s=ea(t.i,t.x,t.y),i=n.next,r=t.prev;return n.next=t,t.prev=n,e.next=i,i.prev=e,s.next=e,e.prev=s,r.next=s,s.prev=r,s}function lo(n,t,e,s){const i=ea(n,t,e);return s?(i.next=s.next,i.prev=s,s.next.prev=i,s.next=i):(i.prev=i,i.next=i),i}function sn(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ),n.next=n,n.prev=n}function ea(n,t,e){return{i:n,x:t,y:e,prev:null,next:null,z:null,prevZ:null,nextZ:null,steiner:!1}}const ll=class sa{static create(t,e,s,i,r,a,o,h){const l=t.length,d=o.verticesAmount;sa.processBuffers(l,t,r,o,e,s);const u=r.positionBuffer,p=(o.verticesAmount-d)/3;this.processNormals(u,this._tempVec,p,d),this.triangulate(a,i,l,r,o,d),this.setFaceId(d,o,r,h)}static setFaceId(t,e,s,i){const r=t/3,a=e.verticesAmount/3;for(let o=r;o<a;o++)s.faceIdBuffer[o]=i}static getVertices(t,e,s){const i=t.positionBuffer.buffer,r=4*e,a=s.verticesAmount-e;return new Float32Array(i,r,a)}static getEvent(t,e,s){return(i,r,a)=>{const o=t.indexBuffer;o[e.indices++]=i+s/3,o[e.indices++]=r+s/3,o[e.indices++]=a+s/3}}static processBuffers(t,e,s,i,r,a){for(let o=0;o<t;o++)this.processPositionBuffer(s,e,o,i,r),this.processNormalbuffer(s,a,o,i),this.updateBufferData(i)}static getHoles(t,e,s,i,r){if(t&&t.has(e)){const a=t.get(e),o=[];for(const h of a.indices)o.push(h+s);return this.setHolesBuffers(i,a,r),o}}static setHolesBuffers(t,e,s){const i=t.positionBuffer,r=t.normalBuffer;i.set(e.points,s.verticesAmount);const a=e.points.length;s.verticesAmount+=a,s.vertices+=a/3,r.set(e.normals,s.normalsAmount),s.normalsAmount+=a}static updateBufferData(t){t.vertices+=1,t.verticesAmount+=3,t.normalsAmount+=3}static processPositionBuffer(t,e,s,i,r){const a=t.positionBuffer;for(let o=0;o<3;o++){const h=3*e[s];a[i.verticesAmount+o]=r[h+o]}}static triangulate(t,e,s,i,r,a){const o=this.getHoles(t,e,s,i,r),h=sa.getVertices(i,a,r),l=Uo.getEarcutDimensions(this._tempVec),d=this.getEvent(i,r,a);$f(h,o,3,l[0],l[1],d)}static processNormals(t,e,s,i=0){e.set(0,0,0);for(let r=0;r<s;r++){const a=i+3*r,o=i+3*((r+1)%s),h=t[a+0],l=t[o+0],d=t[a+1],u=t[o+1],p=t[a+2],f=t[o+2];e.x+=(d-u)*(p+f),e.y+=(p-f)*(h+l),e.z+=(h-l)*(d+u)}e.normalize()}static processNormalbuffer(t,e,s,i){const r=t.normalBuffer,a=3*s,o=e[a],h=e[a+1],l=e[a+2];r.set([o,h,l],i.normalsAmount)}};c(ll,"_tempVec",new T);let hl=ll;const Tt=class{static create(n,t,e,s,i,r,a){this.setAllVectors(n,t),this.getIsConvex()?this.processConvexFace4(i,r,e,a):hl.create(n,t,e,s,i,void 0,r,a)}static setAllVectors(n,t){this.setVector(n,t,this.a,0),this.setVector(n,t,this.b,1),this.setVector(n,t,this.c,2),this.setVector(n,t,this.d,3),this.getCrossVectors()}static processConvexFace4(n,t,e,s){this.processIndices(n,t),this.processPoints(n,t),this.processNormal(n,t,e),this.setFaceId(n,t,s),this.updateData(t)}static setFaceId(n,t,e){const s=n.faceIdBuffer;for(let i=t.vertices;i<t.vertices+4;i++)s[i]=e}static getIsConvex(){return this.h.dot(this.i)>0}static getCrossVectors(){this.e.copy(this.b),this.f.copy(this.c),this.g.copy(this.d),this.e.sub(this.a),this.f.sub(this.a),this.g.sub(this.a),this.h.crossVectors(this.e,this.f),this.i.crossVectors(this.f,this.g)}static updateData(n){n.normalsAmount+=this.totalIncrease,n.vertices+=this.vertexIncrease,n.verticesAmount+=this.totalIncrease}static processPoints(n,t){let e=0;const s=n.positionBuffer,i=t.verticesAmount;for(let r=0;r<this.vertexIncrease;r++){const a=this._vecs[r];s[i+e++]=a.x,s[i+e++]=a.y,s[i+e++]=a.z}}static setVector(n,t,e,s){const i=3*n[s],r=t[i],a=t[i+1],o=t[i+2];e.set(r,a,o)}static processNormal(n,t,e){const s=n.normalBuffer,i=t.normalsAmount;for(let r=0;r<this.totalIncrease;r++)s[i+r]=e[r]}static processIndices(n,t){const e=n.indexBuffer;for(let s=0;s<this.indexIncrease;s++){const i=this._convexIndices[s];e[t.indices+s]=t.vertices+i}t.indices+=this.indexIncrease}};c(Tt,"a",new T),c(Tt,"b",new T),c(Tt,"c",new T),c(Tt,"d",new T),c(Tt,"e",new T),c(Tt,"f",new T),c(Tt,"g",new T),c(Tt,"h",new T),c(Tt,"i",new T),c(Tt,"_vecs",[Tt.a,Tt.b,Tt.c,Tt.d]),c(Tt,"_convexIndices",[0,1,3,3,1,2]),c(Tt,"totalIncrease",12),c(Tt,"indexIncrease",6),c(Tt,"vertexIncrease",4);let ap=Tt;const ia=class Bn{static create(t,e,s,i,r,a){this.setFaceIds(r,i,a),this.setIndices(i,r),this.setPoints(t,i,r,e),this.setNormals(i,r,s),this.updateData(r)}static setFaceIds(t,e,s){const i=t.verticesAmount/3,r=i+3;for(let a=i;a<r;a++)e.faceIdBuffer[a]=s}static setNormals(t,e,s){const i=t.normalBuffer;for(let r=0;r<this.totalIncrease;r++)i[e.normalsAmount+r]=s[r]}static setPoints(t,e,s,i){let r=0;const a=e.positionBuffer;for(let o=0;o<this.vertexIncrease;o++){const h=t[o]*this.vertexIncrease;for(let l=0;l<this.vertexIncrease;l++)a[s.verticesAmount+r]=i[h+l],r++}}static setIndices(t,e){const s=t.indexBuffer;for(let i=0;i<this.vertexIncrease;i++)s[e.indices+i]=e.vertices+i;e.indices+=this.vertexIncrease}static updateData(t){t.normalsAmount+=Bn.totalIncrease,t.vertices+=Bn.vertexIncrease,t.verticesAmount+=Bn.totalIncrease}};c(ia,"vertexIncrease",3),c(ia,"totalIncrease",9);let op=ia;class lp{constructor(){c(this,"point",new xt),c(this,"_shellHole",new oe),c(this,"_bigShellHole",new ae),c(this,"interiorProfiles",new Map),c(this,"normalsAvgInterior",new Int16Array),c(this,"_pointsPerProfile",new Map),c(this,"_shellProfile",new ce),c(this,"_bigShellProfile",new he),c(this,"_normalsAvg",new Int16Array),c(this,"_normals",[]),c(this,"_indices",0),c(this,"_sizes",{vertices:0,indices:0,verticesAmount:0,normalsAmount:0,normals:0}),c(this,"_tileData"),c(this,"_nextFaceId",1),c(this,"nextBuffer",t=>{this.setTileData(t),this.initializeIndices(),this.initializePositions(),this.initializeNormals(),this.initializeFaceIds(),this.initializeSizes(),this._indices++})}construct(t,e){this.resetConstructData(e),this.getPointsPerWire(t);const s=Q.getBuffer(t);this.newShellInteriorProfiles(t),this.constructShell(t,s,e),this._tileData=void 0}getIntProfileNormalsAvg(t,e){const s=this.getTempHole(t).indicesArray();this.normalsAvgInterior=Q.computeNormalsAvg(s,e,this._normals,this._pointsPerProfile)}saveInteriorProfile(t){const e=this.getTempHole(t).profileId();if(this.interiorProfiles.has(e))return this.saveExistingInteriorProfile(e),e;const s=this.getNewIntProfileData();return this.interiorProfiles.set(e,s),e}computeNormalsAvg(t,e,s){if(!this.isShell(t))return;const i=this._normals,r=this._pointsPerProfile;this._normalsAvg=Q.computeNormalsAvg(e,s,i,r)}isShell(t){return t instanceof It}getPointsPerWire(t){this.isShell(t)&&(Q.getNormalsOfShellProfile(t,this._normals),this._pointsPerProfile=Q.getPointsShell(t))}getIndices(t,e){const s=this.getTempProfile(t);return Q.getProfile(t,e,s),s.indicesArray()}resetConstructData(t){this._indices=0,this._tileData=void 0,this.nextBuffer(t),this._normals.length=0}initializeIndices(){const t=this._tileData.indexCount;this._tileData.indexBuffer=new Uint16Array(t)}constructFace4(t,e,s){const i=this.getNextFaceId();ap.create(t,e,this._normalsAvg,s,this._tileData,this._sizes,i)}initializeSizes(){this._sizes.vertices=0,this._sizes.indices=0,this._sizes.verticesAmount=0,this._sizes.normalsAmount=0,this._sizes.normals=0}getInteriorProfileBuffer(t,e){const s=this.getTempHole(t).indicesLength();if(this.isShell(t))for(let i=0;i<s;i++)this.getIntProfilePoints(i,t,e),this.getIntProfileNormals(e,i)}constructProfile(t,e,s,i){const r=this.getTempProfile(e).indicesLength(),a=!this.interiorProfiles.has(t);if(r===Jr.three&&a)return void this.constructFace3(s,i);r===Jr.four&&a?this.constructFace4(s,i,t):this.constructFaceX(s,i,t)}getIntProfileNormals(t,e){const s=3*e,i=this.normalsAvgInterior[s],r=this.normalsAvgInterior[s+1],a=this.normalsAvgInterior[s+2];t.normals.push(i,r,a)}saveExistingInteriorProfile(t){const e=this.interiorProfiles.get(t),s=e.points.length/3;e.indices.push(s),this.interiorProfiles.set(t,e)}getNewIntProfileData(){return{indices:[0],points:[],normals:[]}}constructFace3(t,e){const s=this.getNextFaceId();op.create(t,e,this._normalsAvg,this._tileData,this._sizes,s)}getIntProfilePoints(t,e,s){const i=this.getTempHole(e).indices(t);e.points(i,this.point);const r=this.point.x(),a=this.point.y(),o=this.point.z();s.points.push(r,a,o)}manageMemory(t,e){const s=this.getTempProfile(t).indicesLength();this._sizes.verticesAmount/3+s>ni&&this.nextBuffer(e)}initializeFaceIds(){const t=this._tileData.positionCount;this._tileData.faceIdBuffer=new Uint32Array(t/3)}getNextFaceId(){return this._nextFaceId++}newShellInteriorProfiles(t){this.interiorProfiles.clear();const e=Q.getHolesLength(t),s=this.getTempHole(t);for(let i=0;i<e;i++){Q.getHole(t,i,s);const r=this.saveInteriorProfile(t),a=this.interiorProfiles.get(r);this.getIntProfileNormalsAvg(t,r),this.getInteriorProfileBuffer(t,a)}return this.interiorProfiles}initializePositions(){const t=this._tileData.positionCount;this._tileData.positionBuffer=new Float32Array(t)}initializeNormals(){const t=this._tileData.normalCount;this._tileData.normalBuffer=new Int16Array(t)}setTileData(t){Array.isArray(t)?this._tileData=t[this._indices]:this._tileData=t}constructShell(t,e,s){const i=Q.getProfilesLength(t);for(let r=0;r<i;r++){const a=this.getIndices(t,r);this.computeNormalsAvg(t,a,r),this.constructProfile(r,t,a,e),this.manageMemory(t,s)}}constructFaceX(t,e,s){const i=this.getNextFaceId();hl.create(t,e,this._normalsAvg,s,this._tileData,this.interiorProfiles,this._sizes,i)}getTempProfile(t){return t.type()===Dt.BIG?this._bigShellProfile:this._shellProfile}getTempHole(t){return t.type()===Dt.BIG?this._bigShellHole:this._shellHole}}class hp{constructor(t){c(this,"a",new T),c(this,"b",new T),c(this,"c",new T),c(this,"d",new T),c(this,"e",new T),c(this,"f",new T),c(this,"g",new T),c(this,"h",new T),c(this,"i",new T),c(this,"j",new T),c(this,"k",new T),c(this,"tempTriangle",new ji),c(this,"tempPlane",new Yt),c(this,"includedVertices",[]),c(this,"interiorProfiles",new Map),c(this,"_meshes"),this._meshes=t}faceRaycast(t,e){const s=Q.getShell(this._meshes,t);this.resetData(),this.getInteriorProfiles(s);const i=Q.getBuffer(s);return this.processAllCollisions(s,i,e),this.includedVertices}resetVectors(){this.a.set(0,0,0),this.b.set(0,0,0),this.c.set(0,0,0),this.d.set(0,0,0)}resetData(){this.includedVertices.length=0,this.interiorProfiles.clear()}getInteriorProfiles(t){const e=Q.getHolesLength(t);for(let s=0;s<e;s++){const i=Q.getHole(t,s).profileId();this.interiorProfiles.has(i)||this.interiorProfiles.set(i,[]),this.interiorProfiles.get(i).push(s)}}processTriangle(t,e,s){const i=3*t[0],r=3*t[1],a=3*t[2];this.saveTriPoint(this.e,e,i),this.saveTriPoint(this.f,e,r),this.saveTriPoint(this.g,e,a);const o=this.triangleHit(s);if(o){const h=this.getTriangleBuffer(e,t);o.facePoints=h.points,o.faceIndices=h.indices,this.includedVertices.push(o)}}processAllCollisions(t,e,s){const i=Q.getProfilesLength(t);for(let r=0;r<i;r++){this.resetVectors();const a=this.getIndices(t,r);this.getValidCollision(a,e,s,r,t)&&this.processCollision(t,r,e,a)}}saveTriPoint(t,e,s){const i=e[s],r=e[s+1],a=e[s+2];t.set(i,r,a)}getIndices(t,e){return Q.getProfile(t,e).indicesArray()}getIsTriangle(t){return t.length===3}getNormal(){this.tempTriangle.a=this.e,this.tempTriangle.b=this.f,this.tempTriangle.c=this.g;const t=new T;return this.tempTriangle.getNormal(t),t}isHole(t,e,s){if(this.interiorProfiles.has(t)){const i=this.interiorProfiles.get(t);return this.holeContains(i,e,s)}return!1}computeNormal(t,e){this.d.set(0,0,0);const s=e.length;for(let i=0;i<s;i++){const r=(i+1)%s,a=3*e[i],o=3*e[r];this.processNormal(t,a,o)}this.d.normalize()}holeContains(t,e,s){const i=t.length;for(let r=0;r<i;r++){const a=Q.getHole(e,t[r]).indicesArray();if(this.polygonContains(s,a))return!0}return!1}triangleHit(t){const e=this.e,s=this.f,i=this.g;if(!t.intersectTriangle(e,s,i,!1,this.h))return;const r=this.getNormal();return{point:this.h.clone(),normal:r}}getValidCollision(t,e,s,i,r){return this.getIsTriangle(t)?(this.processTriangle(t,e,s),!1):this.getCollidesPlane(t,e,s)?!this.isHole(i,r,e):!1}processCollision(t,e,s,i){if(!this.polygonContains(s,i))return;const r=this.b.clone(),a=this.tempPlane.normal.clone(),o=this.getFaceBuffer(t,e,s);this.includedVertices.push({point:r,normal:a,facePoints:o.points,faceIndices:o.indices})}newOrthoNormalBasis(){const t=this.tempPlane.normal,e=this.j,s=this.i;if(Math.abs(t.x)>=Math.abs(t.y)){const i=1/Math.sqrt(t.x*t.x+t.z*t.z),r=-t.z*i,a=0,o=t.x*i;e.set(r,a,o);const h=t.y*e.z,l=t.z*e.x-t.x*e.z,d=-t.y*e.x;s.set(h,l,d)}else{const i=1/Math.sqrt(t.y*t.y+t.z*t.z),r=0,a=t.z*i,o=-t.y*i;e.set(r,a,o);const h=t.y*e.z-t.z*e.y,l=-t.x*e.z,d=t.x*e.y;s.set(h,l,d)}e.normalize(),s.normalize()}polygonContains(t,e){let s=!1;this.newOrthoNormalBasis(),this.setPolyContainVec(e,t);let i=this.k.dot(this.i),r=this.k.dot(this.j);for(let a=0;a<e.length;a++){const o=3*e[a],h=t[o],l=t[o+1],d=t[o+2];this.k.set(h,l,d),this.k.sub(this.b);const u=this.k.dot(this.i),p=this.k.dot(this.j);p>0!=r>0&&(i-u)*-p/(r-p)+u>0&&(s=!s),i=u,r=p}return s}processNormal(t,e,s){const i=t[e+0],r=t[s+0],a=t[e+1],o=t[s+1],h=t[e+2],l=t[s+2];this.d.x+=(a-o)*(h+l),this.d.y+=(h-l)*(i+r),this.d.z+=(i-r)*(a+o)}getCollidesPlane(t,e,s){const i=3*t[0],r=e[i],a=e[i+1],o=e[i+2];return this.a.set(r,a,o),this.computeNormal(e,t),this.tempPlane.setFromNormalAndCoplanarPoint(this.d,this.a),s.intersectPlane(this.tempPlane,this.b)}setPolyContainVec(t,e){const s=3*t[t.length-1],i=e[s],r=e[s+1],a=e[s+2];this.k.set(i,r,a),this.k.sub(this.b)}getTriangleBuffer(t,e){const s=[],i=[];for(let r=0;r<e.length;r++){const a=3*e[r];s.push(t[a],t[a+1],t[a+2]),i.push(r)}return{points:new Float32Array(s),indices:i}}getFaceBuffer(t,e,s){const i=Q.getProfileIndices(t,e),{outer:r,inners:a}=i,o=[];for(let R=0;R<r.length;R++){const E=3*r[R];o.push(s[E],s[E+1],s[E+2])}const h=[];for(let R=0;R<a.length;R++){const E=a[R];h.push(o.length/3);for(let g=0;g<E.length;g++){const w=3*E[g];o.push(s[w],s[w+1],s[w+2])}}const l=new T,d=new T,u=new T;l.set(o[0],o[1],o[2]),d.set(o[3],o[4],o[5]),u.set(o[6],o[7],o[8]);const p=new ji;p.set(l,d,u);const f=new T;p.getNormal(f);const[m,b]=Uo.getEarcutDimensions(f),I=[];for(let R=0;R<o.length;R+=3){const E=[o[R],o[R+1],o[R+2]];I.push(E[m],E[b])}const C=iu(I,h);return{points:new Float32Array(o),indices:C}}}class cp{constructor(t){c(this,"_meshes"),c(this,"_minAngle",Math.PI/32),c(this,"_shellProfile",new ce),c(this,"_bigShellProfile",new he),c(this,"_tempV1",new T),c(this,"_tempV2",new T),c(this,"_tempPoint",new T),c(this,"_normals",[]),c(this,"_pointsByProfile",new Map),c(this,"_shell",new It),c(this,"_result",[]),this._meshes=t}lineRaycast(t,e,s){return this.resetData(t),this.lineRaycastItems(e,s),this._result}lineRaycastItems(t,e){const s=Q.getProfilesLength(this._shell);for(let i=0;i<s;i++){const r=this.getTempProfile(this._shell);Q.getProfile(this._shell,i,r),this.lineRaycastProfile(t,e,i)}}resetData(t){this._shell=Q.getShell(this._meshes,t),this._normals.length=0,Q.getNormalsOfShellProfile(this._shell,this._normals),this._pointsByProfile=Q.getPointsShell(this._shell),this._result=[]}lineRaycastProfile(t,e,s){const i=this.getTempProfile(this._shell),r=i.indicesLength();for(let a=0;a<r;a++){const o=i.indices(a),h=this.getSecondIndex(a,r);this.cast(o,h,t,e,s)&&this.saveResult(s)}}isInvalidAngle(t,e,s){const i=this.getProfile(t,e,s);if(!i.length)return!0;const r=this._normals[i[0]],a=this._normals[s];return r.dot(a)>Math.cos(this._minAngle)}getProfile(t,e,s){const i=this._pointsByProfile.get(t),r=this._pointsByProfile.get(e),a=[];for(const o of i)r.indexOf(o)!==-1&&o!==s&&a.push(o);return a}cast(t,e,s,i,r){return Q.point(this._shell,t,this._tempV1),Q.point(this._shell,e,this._tempV2),this.raycastSegment(s),i.containsPoint(this._tempPoint)?!this.isInvalidAngle(t,e,r):!1}saveResult(t){const e=this._tempV1.clone(),s=this._tempV2.clone(),i=this._normals[t],r=this._tempPoint.clone();this._result.push({point:r,normal:i,snappedEdgeP1:e,snappedEdgeP2:s})}getSecondIndex(t,e){const s=t===e-1,i=this.getTempProfile(this._shell);return s?i.indices(0):i.indices(t+1)}raycastSegment(t){t.distanceSqToSegment(this._tempV1,this._tempV2,void 0,this._tempPoint)}getTempProfile(t){return t.type()===Dt.BIG?this._bigShellProfile:this._shellProfile}}class dp{constructor(t){c(this,"_meshes"),c(this,"_tempVec",new T),this._meshes=t}pointRaycast(t,e){const s=Q.getShell(this._meshes,t),i=[];return this.cast(s,e,i),i}cast(t,e,s){const i=t.pointsLength();for(let r=0;r<i;r++){if(Q.point(t,r,this._tempVec),!e.containsPoint(this._tempVec))continue;const a=this._tempVec.clone();s.push({point:a})}}}class up extends rl{constructor(){super(...arguments),c(this,"_lodClass",Ps.AABB),c(this,"_objectClass",Wt.SHELL),c(this,"_representationClass",gs.SHELL),c(this,"_templates",new Xf),c(this,"_constructor",new lp),c(this,"_faceRaycaster",new hp(this.meshes)),c(this,"_lineRaycaster",new cp(this.meshes)),c(this,"_pointRaycaster",new dp(this.meshes))}fetchMeshes(t,e){const s=this.getMesh(t,Y.GEOMETRY);return this.constructMesh(s,e,t),s}newMeshTemplate(t){return this._templates.newMeshTemplate(t)}lineRaycast(t,e,s){return this._lineRaycaster.lineRaycast(t,e,s)}faceRaycast(t,e){return this._faceRaycaster.faceRaycast(t,e)}raycast(t,e){return this._faceRaycaster.faceRaycast(t,e)}pointRaycast(t,e,s){return this._pointRaycaster.pointRaycast(t,s)}setupTemplates(){for(let t=0,e=this.meshes.shellsLength();t<e;t++){const s=Q.getShell(this.meshes,t);this.useMesh(t,this.newMeshTemplate(s),Y.GEOMETRY)}}getRepresentation(){return this._representationClass}getObjectClass(){return this._objectClass}getLodClass(){return this._lodClass}isVoidMesh(t){return Array.isArray(t)?t[0].positionBuffer===void 0:t.positionBuffer===void 0}constructMesh(t,e,s){if(!this.isVoidMesh(t)||!e)return;const i=Q.getShell(this.meshes,s);this._constructor.construct(i,t),this.saveMesh(s,t,Y.GEOMETRY)}}class G{static circleCurve3Divisions(t){const e=t.aperture()*t.radius()*4,s=Math.round(e);return Math.min(Math.max(s,4),32)}static traverseCircleCurve(t,e,s){const i=t.circleCurvesLength();for(let r=0;r<i;r++){this.getAllCircleCurveData(t,r);const a=s(this._circleCurve);this._circlePoints.length=a-2,this.getCircleCurveMids(a),this.getNewCircleCurveData(),e(this._circleP1,this._circlePoints,this._circleP2)}}static traverseWireSets(t,e){const s=t.wireSetsLength();for(let i=0;i<s;i++)t.wireSets(i,this._wireSet),this.traverseWireSetWires(e)}static raycastCircleExtr(t,e,s,i){const r=e.distanceTo(t);return this.setupCircleExtrusionAxes(e,t),this.setupCircleExtrusionTransform(t,i),this.setupCircleExtrusionRay(s),this.computeCircleExtrusionRaycast(r,i)}static traverseWires(t,e){const s=t.wiresLength();for(let i=0;i<s;i++)t.wires(i,this._wire),this.setWire(),e(this._wireP1,this._wireP2)}static getNewCircleCurveData(){this._circleP2.copy(this._circleP1);const t=this._circleCurve.aperture(),e=this._circleCurve.radius();this._circleP2.applyAxisAngle(this._circleOrientation,t),this._circleP2.multiplyScalar(e),this._circleP2.add(this._circleOrigin),this._circleP1.multiplyScalar(e),this._circleP1.add(this._circleOrigin)}static setWire(){this.setWirePoint("p1",this._wireP1),this.setWirePoint("p2",this._wireP2)}static getCircleCurveMids(t){const e=this._circlePoints.length;for(let s=0;s<e;s++)this._circlePoints[s]=this.newCirclePoint(s,t)}static newCirclePoint(t,e){const s=e-1,i=t+1,r=new T;r.copy(this._circleP1);const a=this._circleCurve.radius(),o=this._circleCurve.aperture()*i/s;return r.applyAxisAngle(this._circleOrientation,o),r.multiplyScalar(a),r.add(this._circleOrigin),r}static getAllCircleCurveData(t,e){t.circleCurves(e,this._circleCurve),this.getCircleCurveData(this._circleOrigin,"position"),this.getCircleCurveData(this._circleOrientation,"xDirection"),this.getCircleCurveData(this._circleP1,"yDirection")}static setWirePoint(t,e){this._wire[t](this._floats);const s=this._floats.x(),i=this._floats.y(),r=this._floats.z();e.set(s,i,r)}static getCircleCurveData(t,e){const s=this._circleCurve[e]();this.getVectorData(s,t)}static getVectorData(t,e){const s=t.x(),i=t.y(),r=t.z();e.set(s,i,r)}static traverseWireSetWires(t){const e=this._wireSet.psLength()-1;for(let s=0;s<e;s++)this.getWiresetPoint(this._currentWireSetPoint,s),this.getWiresetPoint(this._nextWireSetPoint,s+1),t(this._currentWireSetPoint,this._nextWireSetPoint)}static getWiresetPoint(t,e){const s=this._wireSet.ps(e);this.getVectorData(s,t)}static setupCircleExtrusionTransform(t,e){this._ceTransform.identity(),this._ceTransform.makeBasis(this._ceAxisX,this._ceAxisY,this._ceAxisZ),this._ceTransform.setPosition(t),this._ceSize.set(e,e,e),this._ceTransform.scale(this._ceSize)}static computeCircleExtrusionRaycastFactors(){const t=this._ceRay.direction,e=this._ceRay.origin,s=t.x*t.x+t.y*t.y,i=2*e.x*t.x+2*e.y*t.y,r=4*s*(e.x*e.x+e.y*e.y-1),a=i*i;if(r>a)return null;const o=2*s,h=Math.sqrt(a-r);return{factorA:(-i+h)/o,factorB:(-i-h)/o}}static computeCircleExtrusionRaycast(t,e){const s=this.computeCircleExtrusionRaycastFactors();if(s===null)return[];const{factorA:i,factorB:r}=s;return this._ceInverseTransform.transpose(),this._ceRaycastPoints=[],this.computeCircleExtrusionRaycastPoints(i,t,e),this.computeCircleExtrusionRaycastPoints(r,t,e),this._ceRaycastPoints}static setupCircleExtrusionRay(t){this._ceInverseTransform.copy(this._ceTransform),this._ceInverseTransform.invert(),this._ceRay.copy(t),this._ceRay.applyMatrix4(this._ceInverseTransform)}static computeCircleExtrusionRaycastPoints(t,e,s){if(!this.checkIfCircleExtrusionClashes(t,e,s))return;this._ceRaycastPoint.applyMatrix4(this._ceTransform);const i=this._ceRaycastPoint.clone();this._ceRaycastPoints.push({point:i})}static setupCircleExtrusionAxes(t,e){this._ceAxisZ.copy(t),this._ceAxisZ.sub(e),this._ceAxisZ.normalize(),this.computeNormal(this._ceAxisZ,this._ceAxisX),this._ceAxisY.crossVectors(this._ceAxisZ,this._ceAxisX)}static computeNormal(t,e){const s=t.dot(this._ceAbsoluteX),i=Math.abs(s)>.9?this._ceAbsoluteZ:this._ceAbsoluteX;e.crossVectors(t,i),e.normalize()}static setupCircleExtrusionRaycastPoint(t){this._ceRaycastPoint.copy(this._ceRay.direction),this._ceRaycastPoint.normalize(),this._ceRaycastPoint.multiplyScalar(t),this._ceRaycastPoint.add(this._ceRay.origin)}static checkIfCircleExtrusionClashes(t,e,s){this.setupCircleExtrusionRaycastPoint(t);const i=e/s,r=this._ceRaycastPoint.z;return r>=0&&r<=i}}c(G,"_floats",new xt),c(G,"_wire",new ua),c(G,"_wireSet",new is),c(G,"_circleCurve",new sr),c(G,"_wireP1",new T),c(G,"_wireP2",new T),c(G,"_circleP1",new T),c(G,"_circleP2",new T),c(G,"_circleOrigin",new T),c(G,"_circleOrientation",new T),c(G,"_currentWireSetPoint",new T),c(G,"_nextWireSetPoint",new T),c(G,"_ceAxisZ",new T),c(G,"_ceAxisY",new T),c(G,"_ceAxisX",new T),c(G,"_ceRaycastPoint",new T),c(G,"_ceSize",new T),c(G,"_ceAbsoluteX",new T(0,0,1)),c(G,"_ceAbsoluteZ",new T(1,0,0)),c(G,"_circlePoints",[]),c(G,"_ceTransform",new rt),c(G,"_ceInverseTransform",new rt),c(G,"_ceRay",new si),c(G,"_ceRaycastPoints",[]);const pt=class Ws{static newPaths(t,e){const s=Ws.newPathData();return this.fetchCircleCurveData(t,s),this.fetchCircleCurveMids(e,s,t),this.fetchCircleCurveEnds(s,t),this.fetchCircleCurveCuts(s),s.cuts}static getAxisPartSize(t,e,s){const i=t.parts(e),r=t.order(e),a=Ws.getAxisPartData(i,s,t,r);return Ws.fetchAxisPartSize(s,a),this._axisPartSize}static vertexLength(t,e=200){const s=Math.round(t*e),i=Math.max(s,Ws._minSize);return Math.min(i,Ws._maxSize)}static setPathVertices(t){const e=this.circleCurvePoints,s=!e,i=e&&e.length!==t;if(s||i){this.circleCurvePoints=[];for(let r=0;r<t;r++){const a=2*Math.PI*r/t,o=Math.sin(a),h=Math.cos(a),l=new T(o,h,0);this.circleCurvePoints.push(l)}}}static fetchCircleCurveEnds(t,e){t.last.copy(t.first),t.last.applyAxisAngle(t.axis,e.aperture()),t.last.multiplyScalar(e.radius()),t.last.add(t.center),t.first.multiplyScalar(e.radius()),t.first.add(t.center)}static getAxisPartData(t,e,s,i){return{[bt.WIRE]:this.getAxisPartWireData,[bt.WIRE_SET]:this.getAxisPartWireSetData,[bt.CIRCLE_CURVE]:this.getAxisPartCircleCurveData}[t](s,i,e)}static newEmptyAxisPartData(){return{indices:0,points:0,faces:0,links:0}}static fetchCircleCurveMids(t,e,s){const i=t-2;for(let r=0;r<i;r++){const a=new T;a.copy(e.first);const o=s.aperture()*(r+1)/(t-1);a.applyAxisAngle(e.axis,o),a.multiplyScalar(s.radius()),a.add(e.center),e.mids[r]=a}}static validSize(t,e,s){return ni>=t+e+s}static fetchCircleCurveCuts(t){t.cuts.push(t.first),t.cuts.push(...t.mids),t.cuts.push(t.last)}static fetchCircleCurveData(t,e){const s=t.position();e.center.set(s.x(),s.y(),s.z());const i=t.xDirection();e.axis.set(i.x(),i.y(),i.z());const r=t.yDirection();e.first.set(r.x(),r.y(),r.z())}static newPathData(){return{axis:new T,cuts:[],center:new T,last:new T,first:new T,mids:[]}}static fetchAxisPartSize(t,e){const s=t-2,i=e.faces*s*3,r=e.links*t*this._wireSize;this._axisPartSize.verticesLength=e.points,this._axisPartSize.indicesLength=e.indices+i+r}};c(pt,"up",new T(0,0,1)),c(pt,"circleCurves",[]),c(pt,"circleCurvePoints"),c(pt,"temp",{circleExtrusion:new yt,circleCurve:new sr,wireSet:new is,axis:new it,rotation:new Co,vector:new T}),c(pt,"_wireSize",6),c(pt,"_minSize",6),c(pt,"_maxSize",30),c(pt,"_axisPartSize",{verticesLength:0,indicesLength:0}),c(pt,"getAxisPartWireSetData",(n,t,e)=>{const s=pt.newEmptyAxisPartData();n.wireSets(t,pt.temp.wireSet);const i=pt.temp.wireSet.psLength()-1;return s.points=2*i*e,s.indices=pt._wireSize*i*e,s.faces=2*i,s}),c(pt,"getAxisPartWireData",(n,t,e)=>{const s=pt.newEmptyAxisPartData();return s.points=2*e,s.indices=pt._wireSize*e,s.faces=2,s}),c(pt,"getAxisPartCircleCurveData",(n,t,e)=>{const s=pt.newEmptyAxisPartData();n.circleCurves(t,pt.temp.circleCurve);const i=G.circleCurve3Divisions(pt.temp.circleCurve),r=e*i;s.points=r;const a=e*(i-1),o=pt._wireSize*a;return s.indices=o,s.faces=2,s.links=2,s});let O=pt;class fp{constructor(){c(this,"_minLinkDistance",1e-8),c(this,"_first",new T),c(this,"_last",new T),c(this,"_currentPoint"),c(this,"_currentIndex"),c(this,"_v1",new T),c(this,"_v2",new T),c(this,"_v3",new T),c(this,"_v4",new T),c(this,"_tempLine",new Ee),c(this,"_total",0),c(this,"_closest",0),c(this,"_result",0)}newTemplate(t,e,s){const i=t.radius(e),r=t.axes(e,O.temp.axis),a=O.vertexLength(i);let o=s[s.length-1];const h=r.orderLength();for(let l=0;l<h;l++)o=this.generateTemplate(r,l,a,o,s)}construct(t,e){const s={};let i=0;for(let r=0,a=t.axesLength();r<a;r++){const o=t.radius(r);t.axes(r,O.temp.axis);const h=O.vertexLength(o);i=this.constructVce(h,s,void 0,i,0,e,o)}}getTemplateCreationData(t,e,s){const i=!t;let r=!1;if(!i){const a=t.positionCount/3,o=e.verticesLength;r=O.validSize(a,o,s)}return{isStart:i,fits:r}}generateTemplate(t,e,s,i,r){const a=O.getAxisPartSize(t,e,s),{isStart:o,fits:h}=this.getTemplateCreationData(i,a,s);return(o||!h)&&(i=this.newTemplateData(),r.push(i),this.savePrevious(o,e,s,i)),i.positionCount+=3*a.verticesLength,i.normalCount+=3*a.verticesLength,i.indexCount+=a.indicesLength,i}savePrevious(t,e,s,i){if(!t&&e!==0){const r=3*(s-2);i.positionCount+=3*s,i.normalCount+=3*s,i.indexCount+=r}}constructNewVce(t,e,s,i,r,a,o){const h=!t;let l=!1;if(!h){const d=e.verticesLength;l=O.validSize(s,d,i)}if(h||!l){t=r[a++],this.setupNewVceBuffers(t);const d=this._currentPoint;if(s=this.clearOffset(s),!h&&o!==0){const u=r[a-2];this.getClone(u,t,d,i),s+=i}}return{data:t,pointAmount:s,position:a}}constructVce(t,e,s,i,r,a,o){const h=O.temp.axis.orderLength();for(let l=0;l<h;l++){const d=O.temp.axis,u=O.getAxisPartSize(d,l,t);this.setupLink(l,e),{data:s,pointAmount:i,position:r}=this.constructNewVce(s,u,i,t,a,r,l),this.newAxisPart(O.temp.axis,l,s,o,t,e),i+=u.verticesLength}return i}newTemplateData(){return{objectClass:Wt.SHELL,indexCount:0,positionCount:0,normalCount:0}}setupNewVceBuffers(t){t.positionBuffer=new Float32Array(t.positionCount),t.normalBuffer=new Int16Array(t.normalCount),t.indexBuffer=new Uint16Array(t.indexCount)}clearOffset(t){return this._currentPoint=0,this._currentIndex=0,0}getClone(t,e,s,i){for(let r=-3*i;r<0;r++){const a=e.positionBuffer,o=t.positionBuffer,h=e.normalBuffer,l=t.normalBuffer;a[this._currentPoint]=o[s+r],h[this._currentPoint]=l[s+r],this._currentPoint++}}manageAxisPartCreation(t,e,s,i,r,a,o){if(t!==bt.CIRCLE_CURVE)if(t!==bt.WIRE_SET){if(t===bt.WIRE){const h=e.wires(s);this.newWire(h,i,r,a,o)}}else{const h=e.wireSets(s);this.newWireSet(h,i,r,a,o)}else{const h=e.circleCurves(s);this.newCircleCurve(h,i,r,a,o)}}newWireSetStart(t,e,s,i){t===1?this.linkStart(e,s,i,this._first,bt.WIRE_SET):this.newPathOrderData(e,s)}newWireSet(t,e,s,i,r){for(let a=1,o=t.psLength();a<o;a++){const h=O.temp.rotation;this.getWireSetPoints(t,a),this.setWireSetVector(),this.newPath(this._first,e,h,s,i),this.newWireSetStart(a,s,i,r),this.newPath(this._last,e,h,s,i),this.fillWireSetData(a,o,r,s,i),this.linkPaths(s,i)}}fillWireSetData(t,e,s,i,r){t!==e-1||s.last?this.newPathOrderData(i,r,!0):(s.placement=this._last,s.axisClass=bt.WIRE_SET)}setWireSetVector(){O.temp.vector.copy(this._last),O.temp.vector.sub(this._first),O.temp.vector.normalize(),O.temp.rotation.setFromUnitVectors(O.up,O.temp.vector)}newCircleCurveBody(t,e,s,i){const r=t-2;for(let a=0;a<r;a++){const o=O.circleCurves[a],h=O.circleCurves[a+1],l=O.circleCurves[a+2],d=O.temp.vector;d.copy(l),d.sub(o),d.normalize(),O.temp.rotation.setFromUnitVectors(O.up,d),this.newPath(h,e,O.temp.rotation,s,i),this.linkPaths(s,i,!0)}}newCircleCurveFinish(t,e,s,i,r){const a=t-2,o=t-1,h=O.circleCurves[a],l=O.circleCurves[o],d=O.temp.vector;d.copy(l),d.sub(h),d.normalize(),O.temp.rotation.setFromUnitVectors(O.up,d),this.newPath(l,e,O.temp.rotation,s,i),r.last?this.newPathOrderData(s,i,!0):(r.placement=O.circleCurves[o],r.axisClass=bt.CIRCLE_CURVE)}setupLink(t,e){t===0&&(e.first=!0),t===O.temp.axis.orderLength()-1&&(e.last=!0)}newCircleCurveStart(t,e,s,i){const r=O.circleCurves[0],a=O.circleCurves[1],o=O.temp.vector;o.copy(a),o.sub(r),o.normalize(),O.temp.rotation.setFromUnitVectors(O.up,o),this.newPath(r,t,O.temp.rotation,e,s);const h=bt.CIRCLE_CURVE;this.linkStart(e,s,i,r,h)}getWireSetPoints(t,e){const s=t.ps(e-1);this._first.set(s.x(),s.y(),s.z());const i=t.ps(e);this._last.set(i.x(),i.y(),i.z())}finishWire(t,e,s,i){this.newPath(this._last,t,O.temp.rotation,e,s),i.last?this.newPathOrderData(e,s,!0):(i.placement=this._last,i.axisClass=bt.WIRE),this.linkPaths(e,s)}linkPaths(t,e,s=!1){const i=e,{p1:r,p2:a,p3:o}=this.getPathPositions(i,s,t),h=t.indexBuffer;for(let l=0;l<i;l++){const d=(l+1)%i,{i3:u,i4:p,i1:f,i2:m}=this.getLinkPathIndices(o,l,r,i,d,a);h[this._currentIndex++]=u,h[this._currentIndex++]=p,h[this._currentIndex++]=f,h[this._currentIndex++]=f,h[this._currentIndex++]=p,h[this._currentIndex++]=m}}startWire(t,e,s,i){this.newPath(this._first,t,O.temp.rotation,e,s);const r=bt.WIRE;this.linkStart(e,s,i,this._first,r)}setupWireVectors(){const t=O.temp.vector;t.copy(this._last),t.sub(this._first),t.normalize(),O.temp.rotation.setFromUnitVectors(O.up,t)}getLinkPathIndices(t,e,s,i,r,a){let o=0,h=0,l=0,d=0;return o=t+e>=s?t+e-i:t+e,h=t+r>=s?t+r-i:t+r,l=a+e>=s+i?a+e-i:a+e,d=a+r>=s+i?a+r-i:a+r,{i3:l,i4:d,i1:o,i2:h}}fetchWirePoints(t){const e=t.p1(),s=t.p2();this._first.set(e.x(),e.y(),e.z()),this._last.set(s.x(),s.y(),s.z())}findLinkedVertex(t,e,s,i,r){for(let a=t;a<e;a++){this.point(a,s,this._v1);const o=a-i+r,h=o>=t?o-i:o;this.point(h,s,this._v2);const l=o+1>=t?o+1-i:o+1;this.point(l,s,this._v3),this._tempLine.set(this._v2,this._v3),this._tempLine.closestPointToPoint(this._v1,!0,this._v4),this._total+=this._v4.distanceTo(this._v1)}}newPath(t,e,s,i,r){O.setPathVertices(r);for(let a=0;a<r;a++)this.setPathPosition(a,e,s,t,i),this.setPathNormal(a,s,i),this._currentPoint+=3}linkStart(t,e,s,i,r){if(s.first)return void this.newPathOrderData(t,e);const a=bt.CIRCLE_CURVE,o=s.axisClass===a||r===a,h=s.placement.distanceToSquared(i)<this._minLinkDistance;if(!o||!h)return this.newPathOrderData(t,e,!0,!0),void this.newPathOrderData(t,e);this.linkPaths(t,e,!0)}setPathPosition(t,e,s,i,r){const a=O.temp.vector;a.copy(O.circleCurvePoints[t]),a.multiplyScalar(e),a.applyQuaternion(s),a.add(i);const o=r.positionBuffer,h=this._currentPoint,l=this._currentPoint+1,d=this._currentPoint+2;o[h]=a.x,o[l]=a.y,o[d]=a.z}newWire(t,e,s,i,r){this.fetchWirePoints(t),this.setupWireVectors(),this.startWire(e,s,i,r),this.finishWire(e,s,i,r)}newCircleCurve(t,e,s,i,r){const a=G.circleCurve3Divisions(t);O.circleCurves=O.newPaths(t,a),this.newCircleCurveStart(e,s,i,r),this.newCircleCurveBody(a,e,s,i),this.newCircleCurveFinish(a,e,s,i,r),this.linkPaths(s,i,!0)}newPathOrderData(t,e,s=!1,i=!1){const r=e-2,a=t.indexBuffer;for(let o=0;o<r;o++){const h=this._currentPoint/3,l=e*(i?2:1),d=h-l;a[this._currentIndex]=d,this._currentIndex++;const u=h+o+(s?2:1)-l;a[this._currentIndex]=u,this._currentIndex++;const p=h+o+(s?1:2)-l;a[this._currentIndex]=p,this._currentIndex++}}getPathPositions(t,e,s){const i=this._currentPoint/3-t,r=i;let a=i-t;return e&&(a=this.fetchLinkedVertex(i,s,t)),{p3:a,p1:i,p2:r}}newAxisPart(t,e,s,i,r,a){const o=t.parts(e),h=t.order(e);this.manageAxisPartCreation(o,t,h,i,s,r,a),a.first=!1,a.last=!1}fetchLinkedVertex(t,e,s){this._closest=Number.MAX_VALUE;for(let i=0;i<s;i++){this._total=0;const r=t+s;this.findLinkedVertex(t,r,e,s,i),this._total<this._closest&&(this._closest=this._total,this._result=t-s+i+1)}return this._result}setPathNormal(t,e,s){const i=O.temp.vector,r=O.circleCurvePoints[t];i.copy(r),i.applyQuaternion(e);const a=s.normalBuffer,o=this._currentPoint,h=this._currentPoint+1,l=this._currentPoint+2;a[o]=i.x*Yi,a[h]=i.y*Yi,a[l]=i.z*Yi}point(t,e,s){const i=e.positionBuffer,r=3*t+1,a=3*t+2,o=i[3*t],h=i[r],l=i[a];return s.set(o,h,l),s}}class pp{constructor(t){c(this,"_meshes"),c(this,"_results",[]),c(this,"_circleExtrusion",new yt),c(this,"_axis",new it),this._meshes=t}raycast(t,e){this._results.length=0,this._meshes.circleExtrusions(t,this._circleExtrusion);for(let s=0,i=this._circleExtrusion.axesLength();s<i;s++){this._circleExtrusion.axes(s,this._axis);const r=this._circleExtrusion.radius(s);this.traverseAllCurves(e,r)}return this._results}getTraverseWiresEvent(t,e){return(s,i)=>{this.castCurveExtrusion(s,i,t,e)}}castCurveExtrusion(t,e,s,i){const r=G.raycastCircleExtr(t,e,s,i);for(const a of r)this._results.push(a)}getTraverseCircleCurveEvent(t,e){return(s,i,r)=>{const a=i[0];this.castCurveExtrusion(s,a,t,e);for(let h=0;h<i.length;h++){if(h===0)continue;const l=i[h-1],d=i[h];this.castCurveExtrusion(l,d,t,e)}const o=i[i.length-1];this.castCurveExtrusion(o,r,t,e)}}traverseAllCurves(t,e){const s=this.getTraverseWiresEvent(t,e);G.traverseWires(this._axis,s);const i=this.getTraverseCircleCurveEvent(t,e),r=G.circleCurve3Divisions;G.traverseCircleCurve(this._axis,i,r);const a=this.getTraverseWiresEvent(t,e);G.traverseWireSets(this._axis,a)}}class bp{constructor(t){c(this,"_meshes"),c(this,"_found",[]),c(this,"_circleExtrusion",new yt),c(this,"_axis",new it),c(this,"_wirePoint",new T),this._meshes=t}lineRaycast(t,e){this._found.length=0,this._meshes.circleExtrusions(t,this._circleExtrusion);const s=this._circleExtrusion.axesLength();for(let i=0;i<s;i++)this._circleExtrusion.axes(i,this._axis),this.processLineRaycast(i,e);return this._found}wireSetRaycast(t,e){const s=this._axis;G.traverseWireSets(s,(i,r)=>{this.cylinderRaycast(i,r,t,e)})}exclusiveCylinderRaycast(t,e){const s=this._axis,i=this.getCylinderRaycastEvent(t,e);G.traverseWires(s,i)}processLineRaycast(t,e){const s=this._circleExtrusion.radius(t);this.exclusiveCylinderRaycast(e,s),this.circleCurveRaycast(e,s),this.wireSetRaycast(e,s)}getCylinderRaycastEvent(t,e){return(s,i)=>{this.cylinderRaycast(s,i,t,e)}}processCircleCurveBody(t,e,s){for(let i=0;i<t.length;i++){if(i===0)continue;const r=t[i],a=t[i-1];this.cylinderRaycast(a,r,e,s)}}getCircleCurveRaycastEvent(t,e){return(s,i,r)=>{this.cylinderRaycast(s,i[0],t,e),this.processCircleCurveBody(i,t,e);const a=i[i.length-1];this.cylinderRaycast(a,r,t,e)}}fetchCylinderRaycastResult(t,e,s){t.distanceSqToSegment(e,s,void 0,this._wirePoint);const i=this.newResult(e,s);this._found.push(i)}circleCurveRaycast(t,e){const s=G.circleCurve3Divisions,i=this.getCircleCurveRaycastEvent(t,e);G.traverseCircleCurve(this._axis,i,s)}newResult(t,e){return{point:this._wirePoint.clone(),raySquaredDistance:void 0,snappedEdgeP1:t.clone(),snappedEdgeP2:e.clone()}}cylinderRaycast(t,e,s,i){const r=G.raycastCircleExtr(t,e,s,i);for(const a of r)a.point&&this.fetchCylinderRaycastResult(s,t,e)}}class Ip{constructor(t){c(this,"_meshes"),c(this,"_results",[]),c(this,"_circleExtrusion",new yt),c(this,"_axis",new it),c(this,"_normal",new T),c(this,"_point",new T),c(this,"_plane",new Yt),this._meshes=t}pointRaycast(t,e){return this._results.length=0,this._meshes.circleExtrusions(t,this._circleExtrusion),this.traverseAllCircleExtrusions(e),this.getCleanResults()}fetchOrientation(t,e){O.temp.vector.copy(t),O.temp.vector.sub(e),O.temp.vector.normalize(),O.temp.rotation.setFromUnitVectors(O.up,O.temp.vector)}getTraverseWiresEvent(t,e){return(s,i)=>{this.fetchOrientation(s,i);const r=this.raycastCutCircleExtrusion(s,t,e),a=this.raycastCutCircleExtrusion(i,t,e);this._results.push(r,a)}}traverseAllCircleExtrusions(t){const e=this._circleExtrusion.axesLength();for(let s=0;s<e;s++){this._circleExtrusion.axes(s,this._axis);const i=this._circleExtrusion.radius(s),r=O.vertexLength(i);O.setPathVertices(r),this.traverseAllCurves(t,i)}}setupCuttedCircleExtrusion(t){this._normal.set(0,0,1),this._normal.applyQuaternion(O.temp.rotation),this._plane.setFromNormalAndCoplanarPoint(this._normal,t)}getTraverseCircleCurveEvent(t,e){return(s,i,r)=>{this.fetchOrientation(s,i[0]);const a=this.raycastCutCircleExtrusion(s,t,e),o=i[i.length-1];this.fetchOrientation(o,r);const h=this.raycastCutCircleExtrusion(r,t,e);this._results.push(a,h)}}computeCutCircleExtrCast(t,e,s){if(s.intersectPlane(this._plane,this._point),this._point.distanceTo(t)<=e)return{point:t.clone()}}raycastCutCircleExtrusion(t,e,s){if(this.setupCuttedCircleExtrusion(t),e.intersectsPlane(this._plane))return this.computeCutCircleExtrCast(t,s,e)}getCleanResults(){const t=[];for(const e of this._results)e&&t.push(e);return t}traverseAllCurves(t,e){const s=this.getTraverseWiresEvent(t,e);G.traverseWires(this._axis,s);const i=this.getTraverseCircleCurveEvent(t,e),r=G.circleCurve3Divisions;G.traverseCircleCurve(this._axis,i,r);const a=this.getTraverseWiresEvent(t,e);G.traverseWireSets(this._axis,a)}}class _p{constructor(){c(this,"_currentElement",0),c(this,"_wireSize",6),c(this,"newCircleCurveLod",(t,e,s)=>{const i=this.newCircleCurveLodPath(t,e),r=s.positionBuffer;for(let a=1;a<i;a++){const o=O.circleCurves[a-1],h=O.circleCurves[a];this.newWire(r,o,h)}}),c(this,"newWireSetLod",(t,e,s)=>{const i=t.wireSets(e),r=i.psLength(),a=s.positionBuffer;for(let o=1;o<r;o++){const h=i.ps(o-1),l=i.ps(o);this.newWire(a,h,l)}}),c(this,"newWireTemplate",(t,e)=>{e.positionCount+=this._wireSize}),c(this,"newWireSetTemplate",(t,e)=>{const s=O.temp.axis.wireSets(t,O.temp.wireSet).psLength()-1;e.positionCount+=this._wireSize*s}),c(this,"newWireLod",(t,e,s)=>{const i=t.wires(e),r=i.p1(),a=i.p2(),o=s.positionBuffer;this.newWire(o,r,a)}),c(this,"newCircleCurveTemplate",(t,e)=>{const s=O.temp.axis.circleCurves(t,O.temp.circleCurve),i=G.circleCurve3Divisions(s);e.positionCount+=this._wireSize*(i-1)})}construct(t,e){this._currentElement=0,e.positionBuffer=new Float32Array(e.positionCount);for(let s=0,i=t.axesLength();s<i;s++)t.axes(s,O.temp.axis),this.constructLod(e);return e}constructCircleExtrusionLod(t,e){const s=O.temp.axis,i=s.parts(t),r=s.order(t);this.getLodConstructor(i)(s,r,e)}newCircleCurveLodPath(t,e){const s=t.circleCurves(e),i=G.circleCurve3Divisions(s);return O.circleCurves=O.newPaths(s,i),i}selectNextWire(){this._currentElement+=this._wireSize}getAxisPartVertexSize(t,e){const s=O.temp.axis,i=s.parts(t),r=s.order(t);this.getTemplateConstructor(i)(r,e)}getIndices(){return{i1:this._currentElement,i2:this._currentElement+1,i3:this._currentElement+2,i4:this._currentElement+3,i5:this._currentElement+4,i6:this._currentElement+5}}setAxisTemplate(t,e){O.temp.circleExtrusion.axes(t,O.temp.axis);const s=O.temp.axis.partsLength();for(let i=0;i<s;i++)this.getAxisPartVertexSize(i,e);this.setAxisThickness(e,t)}constructLod(t){const e=O.temp.axis.orderLength();for(let s=0;s<e;s++)this.constructCircleExtrusionLod(s,t)}getLodConstructor(t){return{[bt.WIRE]:this.newWireLod,[bt.WIRE_SET]:this.newWireSetLod,[bt.CIRCLE_CURVE]:this.newCircleCurveLod}[t]}newTemplate(){const t=O.temp.circleExtrusion,e=this.newTemplateData(),s=t.axesLength();for(let i=0;i<s;i++)this.setAxisTemplate(i,e);return e}setAxisThickness(t,e){const s=t.lodThickness,i=O.temp.circleExtrusion.radius(e);t.lodThickness=Math.max(s,i)}newTemplateData(){return{objectClass:Wt.LINE,lod:Y.WIRES,lodThickness:0,positionCount:0}}getTemplateConstructor(t){return{[bt.WIRE]:this.newWireTemplate,[bt.WIRE_SET]:this.newWireSetTemplate,[bt.CIRCLE_CURVE]:this.newCircleCurveTemplate}[t]}newWire(t,e,s){const i=e instanceof T?e.x:e.x(),r=e instanceof T?e.y:e.y(),a=e instanceof T?e.z:e.z(),o=s instanceof T?s.x:s.x(),h=s instanceof T?s.y:s.y(),l=s instanceof T?s.z:s.z(),{i1:d,i2:u,i3:p,i4:f,i5:m,i6:b}=this.getIndices();t[d]=i,t[u]=r,t[p]=a,t[f]=o,t[m]=h,t[b]=l,this.selectNextWire()}}class Ep extends rl{constructor(){super(...arguments),c(this,"_vceConstructor",new fp),c(this,"_lodConstructor",new _p),c(this,"_vceRaycaster",new pp(this.meshes)),c(this,"_vceLineRaycaster",new bp(this.meshes)),c(this,"_vcePointRaycaster",new Ip(this.meshes)),c(this,"_representationClass",gs.CIRCLE_EXTRUSION),c(this,"_objectClass",Wt.LINE),c(this,"lodClass",Ps.CUSTOM)}setupTemplates(){const t=this.meshes.circleExtrusionsLength();for(let e=0;e<t;e++)this.newCircleExtrusionTemplate(e)}fetchLod(t,e){const s=this.getMesh(t,Y.WIRES);return this.generateLodIfNeeded(t,e,s),s}fetchMeshes(t,e){const s=this.getMesh(t,Y.GEOMETRY);return this.generateMeshesIfNeeded(t,e,s),s}raycast(t,e){return this._vceRaycaster.raycast(t,e)}faceRaycast(){return[]}pointRaycast(t,e){return this._vcePointRaycaster.pointRaycast(t,e)}lineRaycast(t,e){return this._vceLineRaycaster.lineRaycast(t,e)}getObjectClass(){return this._objectClass}getRepresentation(){return this._representationClass}getLodClass(){return this.lodClass}newMeshes(t,e){this.meshes.circleExtrusions(t,O.temp.circleExtrusion);const s=O.temp.circleExtrusion;this._vceConstructor.construct(s,e),this.saveMesh(t,e,Y.GEOMETRY)}generateMeshesIfNeeded(t,e,s){if(s.length===0)return;const i=!!s.length,r=!s[0].positionBuffer;e&&r&&i&&this.newMeshes(t,s)}newCircleExtrusionTemplate(t){const e=[];this.meshes.circleExtrusions(t,O.temp.circleExtrusion);const s=O.temp.circleExtrusion,i=s.axesLength();for(let a=0;a<i;a++)this._vceConstructor.newTemplate(s,a,e);const r=this._lodConstructor.newTemplate();this.useMesh(t,e,Y.GEOMETRY),this.useMesh(t,r,Y.WIRES)}generateLodIfNeeded(t,e,s){!s.positionBuffer&&e&&(this.meshes.circleExtrusions(t,O.temp.circleExtrusion),this._lodConstructor.construct(O.temp.circleExtrusion,s),this.saveMesh(t,s,Y.WIRES))}}class mp{constructor(t){c(this,"size"),c(this,"_data"),c(this,"_highlightData"),this.size=t,this._data=new Uint8Array(t),this._highlightData=new Uint16Array(t),this._data.fill(1)}getHighlight(t){return this._highlightData[t]}setHighlight(t,e){ur.checkMemory(e),this._highlightData[t]=e}clearHighlight(){this._highlightData.fill(0)}visible(t){return ur.check(this._data,t,Hr.VISIBLE)}setVisible(t,e){ur.apply(this._data,t,Hr.VISIBLE,e)}clearVisible(){this._data.fill(1)}}class Cp{constructor(t,e){c(this,"_rate",64),c(this,"_updater"),c(this,"_modelId"),c(this,"_threshold",16),c(this,"_connection"),c(this,"_list",[]),c(this,"refresh",()=>{if(this._list.length){const s=this._list;this._connection.fetchMeshCompute(this._modelId,s),this._list=[]}}),this._modelId=t,this._connection=e,this._updater=wt.newUpdater(this.refresh,this._rate)}get needsRefresh(){return this._list.length>this._threshold}dispose(){wt.deleteUpdater(this._updater)}clean(){this._list=wt.cleanRequests(this._list)}process(t){this._list.push(t),this.needsRefresh&&this.refresh()}}class gp{constructor(t,e,s,i){c(this,"_meshes"),c(this,"_model"),c(this,"_boxes"),c(this,"_tiles"),c(this,"_items"),c(this,"_edgeThreshold",8),c(this,"_raycastMultiplier",32),c(this,"_maxDuration",512),c(this,"_precission",.001),c(this,"_temp",{sample:new nr,representation:new ir,tempPlane:new Yt,ray:new si,frustum:new ii,m1:new rt,m2:new rt,m3:new rt,v1:new T,planes:[]}),this._model=t,this._boxes=e,this._tiles=s,this._items=i,this._meshes=t.meshes()}static cast(t,e,s,i,r){const a=e.id();return r===hs.FACE?t.faceRaycast(a,s,i):r===hs.LINE?t.lineRaycast(a,s,i):r===hs.POINT?t.pointRaycast(a,s,i):r===void 0?t.raycast(a,s,i):void 0}raycast(t,e,s){const i={ray:t,frustum:e,planes:s},r=this.castBox(e,s);return r.length?this.computeRaycastList(r,i):null}snapRaycast(t,e,s,i){const r=[],a={ray:t,frustum:e,planes:i},o=this.raycast(t,e,i);return o?(this.getSnaps(o,a,s,r),o.normal?this.filterOnFront(r):r):this.snapCastEdges(a,s)}rectangleRaycast(t,e,s){const i=this._boxes.lookup.collideFrustum(e,t,s),r=this.filterVisible(i);return this.localIdsFromItemIds(r)}snapCastEdges(t,e){const s=[],i=e.includes(hs.POINT),r=e.includes(hs.LINE);return(i||r)&&this.computeEdgesCast(t,e,s),this.addDistanceToEdgeResult(s,t.ray),s}filterVisible(t){const e=[];for(const s of t){this._meshes.samples(s,this._temp.sample);const i=this._temp.sample.item();this._items.visible(i)&&e.push(s)}return e}computeSnaps(t,e,s,i){for(const r of t)if(this.isValidSnap(r)){const a={snap:r,...e},o=this.castSample(s,a);for(const h of o)i.push(h)}}computeEdgesCast(t,e,s){const i=this.getRawEdges(t),r=performance.now();for(const a of i)if(this.fetchSampleData(a),this.computeSnaps(e,t,a,s),this.isTimeExceeded(r))break}addDistanceToEdgeResult(t,e){for(const s of t){const i=s.point;s.raySquaredDistance=e.distanceSqToPoint(i)}}getRawEdges(t){const e=this.castBox(t.frustum,t.planes);return e.length<=this._edgeThreshold?e:this.sortBoxes(t.ray,e,this._edgeThreshold)}sortBoxes(t,e,s){const i=[],r=new T,a=t.origin;for(let h=0;h<e.length;h++){const l=e[h],d=this._boxes.get(l);t.intersectBox(d,r);const u=r.distanceToSquared(a);i.push(u)}const o=this.dataSort(e,i);return s&&o.length>s&&o.splice(s),o}castBox(t,e){const s=this._boxes.lookup;if(t instanceof si){const r=s.collideRay(e,t);return this.filterVisible(r)}const i=s.collideFrustum(e,t);return this.filterVisible(i)}dataSort(t,e){const s=Array.from(t.keys()).sort((r,a)=>e[r]-e[a]),i=[];for(const r of s){const a=t[r];i.push(a)}return i}localIdsFromItemIds(t){const e=new Set;for(const s of t){this._meshes.samples(s,this._temp.sample);const i=this._temp.sample.item(),r=this._meshes.meshesItems(i);if(r===null)continue;const a=this._model.localIds(r);a!==null&&e.add(a)}return Array.from(e)}getNearest(t){let e=t[0];for(let s=1;s<t.length;s++){const i=t[s];if(e.raySquaredDistance&&i.raySquaredDistance){const r=this.getNearScore(e);this.getNearScore(i)<r&&(e=i)}else i.cameraSquaredDistance<e.cameraSquaredDistance&&(e=i)}return e}getEdges(t,e,s){const i=this.snapCastEdges(t,e);if(i)for(const r of i)s.push(r)}getNearScore(t){const e=this._raycastMultiplier;return t.raySquaredDistance*e+t.cameraSquaredDistance}setupSampleCastData(t){Xs.get(this._temp.sample,this._meshes,this._temp.m1),this._temp.m2.copy(this._temp.m1).invert(),this._temp.ray.copy(t.ray).applyMatrix4(this._temp.m2),Ms.transform(t.frustum,this._temp.m2,this._temp.frustum)}addLocalId(t){if(!t)return;const e=this._meshes.meshesItems(t.itemId);e!==null&&(t.localId=this._model.localIds(e))}fetchSampleData(t){this._meshes.samples(t,this._temp.sample);const e=this._temp.sample.representation();this._meshes.representations(e,this._temp.representation)}computeRaycastList(t,e){const s=Array.from(new Set(t)),i=this.sortBoxes(e.ray,s),r=this.castBox(e.ray,e.planes),a=this.findAll(i,r,e);if(a.length){const o=this.getNearest(a);return this.addLocalId(o),o}return null}formatRaycastResult(t,e,s){for(const i of t){if(i.point.applyMatrix4(this._temp.m1),i.normal&&i.normal.transformDirection(this._temp.m1),"facePoints"in i){const a=this._meshes.samples(e,this._temp.sample);Xs.get(a,this._meshes,this._temp.m3);for(let o=0;o<i.facePoints.length;o+=3){const h=i.facePoints[o],l=i.facePoints[o+1],d=i.facePoints[o+2];this._temp.v1.set(h,l,d),this._temp.v1.applyMatrix4(this._temp.m3),i.facePoints[o]=this._temp.v1.x,i.facePoints[o+1]=this._temp.v1.y,i.facePoints[o+2]=this._temp.v1.z}}i.sampleId=e,i.itemId=this._temp.sample.item();const r=s.ray.origin.distanceToSquared(i.point);i.cameraSquaredDistance=r,i.snappingClass||(i.snappingClass=s.snap),i.snappedEdgeP1&&i.snappedEdgeP1.applyMatrix4(this._temp.m1),i.snappedEdgeP2&&i.snappedEdgeP2.applyMatrix4(this._temp.m1)}}findAll(t,e,s){const i=[],r=performance.now();for(const a of t){if(this.fetchSampleData(a),!e.includes(a))continue;const o=this.castSample(a,s);for(const h of o)i.push(h);if(this.isTimeExceeded(r))break}return i}isTimeExceeded(t){return performance.now()-t>this._maxDuration}getFilteredSampleCast(t){const e=this._tiles.raycast(this._temp.representation,this._temp.ray,this._temp.frustum,t.snap);if(this._temp.planes.length===0)return e;const s=[];if(e)for(const i of e){const r=this._temp.planes,a=i.point;qi.containedInParallelPlanes(r,a)&&s.push(i)}return s}getSnaps(t,e,s,i){this.fetchSampleData(t.sampleId),t.normal&&(this.setCastSide(t,e.ray),this.setCastPlane(t)),this.getFaces(s,e,t,i),this.getEdges(e,s,i);for(const r of i)this.addLocalId(r)}filterOnFront(t){const e=[];for(const s of t)this._temp.tempPlane.distanceToPoint(s.point)>=0&&e.push(s);return e}setCastSide(t,e){const s=t.point.clone().sub(e.origin);t.normal.dot(s)>0&&t.normal.negate()}getFaces(t,e,s,i){for(const r of t){const a={snap:r,...e},o=this.castSample(s.sampleId,a);for(const h of o)i.push(h)}}setCastPlane(t){const e=this._temp.tempPlane,s=t.point.clone(),i=t.normal.clone();i.multiplyScalar(this._precission),s.sub(i),e.setFromNormalAndCoplanarPoint(t.normal,s)}castSample(t,e){this.setupSampleCastData(e),this.setupPlanesForSampleCast(e);const s=this.getFilteredSampleCast(e);return s&&this.formatRaycastResult(s,t,e),s}isValidSnap(t){const e=t===hs.LINE,s=t===hs.POINT;return e||s}transform(t,e){const s=[];if(t)for(const i of t){const r=new Yt().copy(i);r.applyMatrix4(e),s.push(r)}return s}setupPlanesForSampleCast(t){if(this._temp.planes.length=0,t.planes&&t.planes.length>0){const e=this.transform(t.planes,this._temp.m2);for(const s of e)this._temp.planes.push(s)}}}const ei=typeof performance=="object"&&performance&&typeof performance.now=="function"?performance:Date,ho=new Set,na=typeof process=="object"&&process?process:{},cl=(n,t,e,s)=>{typeof na.emitWarning=="function"?na.emitWarning(n,t,e,s):console.error(`[${e}] ${t}: ${n}`)};let tr=globalThis.AbortController,co=globalThis.AbortSignal;if(tr===void 0){co=class{constructor(){c(this,"onabort"),c(this,"_onabort",[]),c(this,"reason"),c(this,"aborted",!1)}addEventListener(e,s){this._onabort.push(s)}},tr=class{constructor(){c(this,"signal",new co),t()}abort(e){var s,i;if(!this.signal.aborted){this.signal.reason=e,this.signal.aborted=!0;for(const r of this.signal._onabort)r(e);(i=(s=this.signal).onabort)==null||i.call(s,e)}}};let n=((Ra=na.env)==null?void 0:Ra.LRU_CACHE_IGNORE_AC_WARNING)!=="1";const t=()=>{n&&(n=!1,cl("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",t))}}const bs=n=>n&&n===Math.floor(n)&&n>0&&isFinite(n),dl=n=>bs(n)?n<=Math.pow(2,8)?Uint8Array:n<=Math.pow(2,16)?Uint16Array:n<=Math.pow(2,32)?Uint32Array:n<=Number.MAX_SAFE_INTEGER?zn:null:null;class zn extends Array{constructor(t){super(t),this.fill(0)}}const ul=class xi{constructor(t,e){if(c(this,"heap"),c(this,"length"),!_(xi,Oi))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t),this.length=0}static create(t){const e=dl(t);if(!e)return[];B(xi,Oi,!0);const s=new xi(t,e);return B(xi,Oi,!1),s}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}};Oi=new WeakMap,X(ul,Oi,!1);let Tp=ul;const Rp=class fl{constructor(t){X(this,N),X(this,De),X(this,ue),X(this,Ue),X(this,Hs),X(this,Pe),X(this,vi),X(this,mi),c(this,"ttl"),c(this,"ttlResolution"),c(this,"ttlAutopurge"),c(this,"updateAgeOnGet"),c(this,"updateAgeOnHas"),c(this,"allowStale"),c(this,"noDisposeOnSet"),c(this,"noUpdateTTL"),c(this,"maxEntrySize"),c(this,"sizeCalculation"),c(this,"noDeleteOnFetchRejection"),c(this,"noDeleteOnStaleGet"),c(this,"allowStaleOnFetchAbort"),c(this,"allowStaleOnFetchRejection"),c(this,"ignoreFetchAbort"),X(this,St),X(this,fe),X(this,At),X(this,ht),X(this,z),X(this,Jt),X(this,pe),X(this,Gt),X(this,Pt),X(this,Ge),X(this,Mt),X(this,Ve),X(this,Be),X(this,be),X(this,ze),X(this,vs),X(this,te),X(this,Ci),X(this,qs,()=>{}),X(this,ds,()=>{}),X(this,jn,()=>{}),X(this,Ie,()=>!1),X(this,Zs,S=>{}),X(this,Li,(S,x,v)=>{}),X(this,qn,(S,x,v,M)=>{if(v||M)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0}),c(this,Aa,"LRUCache");const{max:e=0,ttl:s,ttlResolution:i=1,ttlAutopurge:r,updateAgeOnGet:a,updateAgeOnHas:o,allowStale:h,dispose:l,onInsert:d,disposeAfter:u,noDisposeOnSet:p,noUpdateTTL:f,maxSize:m=0,maxEntrySize:b=0,sizeCalculation:I,fetchMethod:C,memoMethod:R,noDeleteOnFetchRejection:E,noDeleteOnStaleGet:g,allowStaleOnFetchRejection:w,allowStaleOnFetchAbort:A,ignoreFetchAbort:y}=t;if(e!==0&&!bs(e))throw new TypeError("max option must be a nonnegative integer");const F=e?dl(e):Array;if(!F)throw new Error("invalid max value: "+e);if(B(this,De,e),B(this,ue,m),this.maxEntrySize=b||_(this,ue),this.sizeCalculation=I,this.sizeCalculation){if(!_(this,ue)&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!="function")throw new TypeError("sizeCalculation set to non-function")}if(R!==void 0&&typeof R!="function")throw new TypeError("memoMethod must be a function if defined");if(B(this,mi,R),C!==void 0&&typeof C!="function")throw new TypeError("fetchMethod must be a function if specified");if(B(this,vi,C),B(this,vs,!!C),B(this,At,new Map),B(this,ht,new Array(e).fill(void 0)),B(this,z,new Array(e).fill(void 0)),B(this,Jt,new F(e)),B(this,pe,new F(e)),B(this,Gt,0),B(this,Pt,0),B(this,Ge,Tp.create(e)),B(this,St,0),B(this,fe,0),typeof l=="function"&&B(this,Ue,l),typeof d=="function"&&B(this,Hs,d),typeof u=="function"?(B(this,Pe,u),B(this,Mt,[])):(B(this,Pe,void 0),B(this,Mt,void 0)),B(this,ze,!!_(this,Ue)),B(this,Ci,!!_(this,Hs)),B(this,te,!!_(this,Pe)),this.noDisposeOnSet=!!p,this.noUpdateTTL=!!f,this.noDeleteOnFetchRejection=!!E,this.allowStaleOnFetchRejection=!!w,this.allowStaleOnFetchAbort=!!A,this.ignoreFetchAbort=!!y,this.maxEntrySize!==0){if(_(this,ue)!==0&&!bs(_(this,ue)))throw new TypeError("maxSize must be a positive integer if specified");if(!bs(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");D(this,N,Ao).call(this)}if(this.allowStale=!!h,this.noDeleteOnStaleGet=!!g,this.updateAgeOnGet=!!a,this.updateAgeOnHas=!!o,this.ttlResolution=bs(i)||i===0?i:1,this.ttlAutopurge=!!r,this.ttl=s||0,this.ttl){if(!bs(this.ttl))throw new TypeError("ttl must be a positive integer if specified");D(this,N,Br).call(this)}if(_(this,De)===0&&this.ttl===0&&_(this,ue)===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!_(this,De)&&!_(this,ue)){const S="LRU_CACHE_UNBOUNDED";(x=>!ho.has(x))(S)&&(ho.add(S),cl("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",S,fl))}}static unsafeExposeInternals(t){return{starts:_(t,Be),ttls:_(t,be),sizes:_(t,Ve),keyMap:_(t,At),keyList:_(t,ht),valList:_(t,z),next:_(t,Jt),prev:_(t,pe),get head(){return _(t,Gt)},get tail(){return _(t,Pt)},free:_(t,Ge),isBackgroundFetch:e=>{var s;return D(s=t,N,at).call(s,e)},backgroundFetch:(e,s,i,r)=>{var a;return D(a=t,N,Nn).call(a,e,s,i,r)},moveToTail:e=>{var s;return D(s=t,N,gi).call(s,e)},indexes:e=>{var s;return D(s=t,N,ls).call(s,e)},rindexes:e=>{var s;return D(s=t,N,us).call(s,e)},isStale:e=>{var s;return _(s=t,Ie).call(s,e)}}}get max(){return _(this,De)}get maxSize(){return _(this,ue)}get calculatedSize(){return _(this,fe)}get size(){return _(this,St)}get fetchMethod(){return _(this,vi)}get memoMethod(){return _(this,mi)}get dispose(){return _(this,Ue)}get onInsert(){return _(this,Hs)}get disposeAfter(){return _(this,Pe)}getRemainingTTL(t){return _(this,At).has(t)?1/0:0}*entries(){for(const t of D(this,N,ls).call(this))_(this,z)[t]===void 0||_(this,ht)[t]===void 0||D(this,N,at).call(this,_(this,z)[t])||(yield[_(this,ht)[t],_(this,z)[t]])}*rentries(){for(const t of D(this,N,us).call(this))_(this,z)[t]===void 0||_(this,ht)[t]===void 0||D(this,N,at).call(this,_(this,z)[t])||(yield[_(this,ht)[t],_(this,z)[t]])}*keys(){for(const t of D(this,N,ls).call(this)){const e=_(this,ht)[t];e===void 0||D(this,N,at).call(this,_(this,z)[t])||(yield e)}}*rkeys(){for(const t of D(this,N,us).call(this)){const e=_(this,ht)[t];e===void 0||D(this,N,at).call(this,_(this,z)[t])||(yield e)}}*values(){for(const t of D(this,N,ls).call(this))_(this,z)[t]===void 0||D(this,N,at).call(this,_(this,z)[t])||(yield _(this,z)[t])}*rvalues(){for(const t of D(this,N,us).call(this))_(this,z)[t]===void 0||D(this,N,at).call(this,_(this,z)[t])||(yield _(this,z)[t])}[(wa=Symbol.iterator,Aa=Symbol.toStringTag,wa)](){return this.entries()}find(t,e={}){for(const s of D(this,N,ls).call(this)){const i=_(this,z)[s],r=D(this,N,at).call(this,i)?i.__staleWhileFetching:i;if(r!==void 0&&t(r,_(this,ht)[s],this))return this.get(_(this,ht)[s],e)}}forEach(t,e=this){for(const s of D(this,N,ls).call(this)){const i=_(this,z)[s],r=D(this,N,at).call(this,i)?i.__staleWhileFetching:i;r!==void 0&&t.call(e,r,_(this,ht)[s],this)}}rforEach(t,e=this){for(const s of D(this,N,us).call(this)){const i=_(this,z)[s],r=D(this,N,at).call(this,i)?i.__staleWhileFetching:i;r!==void 0&&t.call(e,r,_(this,ht)[s],this)}}purgeStale(){let t=!1;for(const e of D(this,N,us).call(this,{allowStale:!0}))_(this,Ie).call(this,e)&&(D(this,N,_s).call(this,_(this,ht)[e],"expire"),t=!0);return t}info(t){const e=_(this,At).get(t);if(e===void 0)return;const s=_(this,z)[e],i=D(this,N,at).call(this,s)?s.__staleWhileFetching:s;if(i===void 0)return;const r={value:i};if(_(this,be)&&_(this,Be)){const a=_(this,be)[e],o=_(this,Be)[e];if(a&&o){const h=a-(ei.now()-o);r.ttl=h,r.start=Date.now()}}return _(this,Ve)&&(r.size=_(this,Ve)[e]),r}dump(){const t=[];for(const e of D(this,N,ls).call(this,{allowStale:!0})){const s=_(this,ht)[e],i=_(this,z)[e],r=D(this,N,at).call(this,i)?i.__staleWhileFetching:i;if(r===void 0||s===void 0)continue;const a={value:r};if(_(this,be)&&_(this,Be)){a.ttl=_(this,be)[e];const o=ei.now()-_(this,Be)[e];a.start=Math.floor(Date.now()-o)}_(this,Ve)&&(a.size=_(this,Ve)[e]),t.unshift([s,a])}return t}load(t){this.clear();for(const[e,s]of t){if(s.start){const i=Date.now()-s.start;s.start=ei.now()-i}this.set(e,s.value,s)}}set(t,e,s={}){var i,r,a,o,h,l,d;if(e===void 0)return this.delete(t),this;const{ttl:u=this.ttl,start:p,noDisposeOnSet:f=this.noDisposeOnSet,sizeCalculation:m=this.sizeCalculation,status:b}=s;let{noUpdateTTL:I=this.noUpdateTTL}=s;const C=_(this,qn).call(this,t,e,s.size||0,m);if(this.maxEntrySize&&C>this.maxEntrySize)return b&&(b.set="miss",b.maxEntrySizeExceeded=!0),D(this,N,_s).call(this,t,"set"),this;let R=_(this,St)===0?void 0:_(this,At).get(t);if(R===void 0)R=_(this,St)===0?_(this,Pt):_(this,Ge).length!==0?_(this,Ge).pop():_(this,St)===_(this,De)?D(this,N,Zn).call(this,!1):_(this,St),_(this,ht)[R]=t,_(this,z)[R]=e,_(this,At).set(t,R),_(this,Jt)[_(this,Pt)]=R,_(this,pe)[R]=_(this,Pt),B(this,Pt,R),Gr(this,St)._++,_(this,Li).call(this,R,C,b),b&&(b.set="add"),I=!1,_(this,Ci)&&((i=_(this,Hs))==null||i.call(this,e,t,"add"));else{D(this,N,gi).call(this,R);const E=_(this,z)[R];if(e!==E){if(_(this,vs)&&D(this,N,at).call(this,E)){E.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:g}=E;g===void 0||f||(_(this,ze)&&((r=_(this,Ue))==null||r.call(this,g,t,"set")),_(this,te)&&((a=_(this,Mt))==null||a.push([g,t,"set"])))}else f||(_(this,ze)&&((o=_(this,Ue))==null||o.call(this,E,t,"set")),_(this,te)&&((h=_(this,Mt))==null||h.push([E,t,"set"])));if(_(this,Zs).call(this,R),_(this,Li).call(this,R,C,b),_(this,z)[R]=e,b){b.set="replace";const g=E&&D(this,N,at).call(this,E)?E.__staleWhileFetching:E;g!==void 0&&(b.oldValue=g)}}else b&&(b.set="update");_(this,Ci)&&((l=this.onInsert)==null||l.call(this,e,t,e===E?"update":"replace"))}if(u===0||_(this,be)||D(this,N,Br).call(this),_(this,be)&&(I||_(this,jn).call(this,R,u,p),b&&_(this,ds).call(this,b,R)),!f&&_(this,te)&&_(this,Mt)){const E=_(this,Mt);let g;for(;g=E==null?void 0:E.shift();)(d=_(this,Pe))==null||d.call(this,...g)}return this}pop(){var t;try{for(;_(this,St);){const e=_(this,z)[_(this,Gt)];if(D(this,N,Zn).call(this,!0),D(this,N,at).call(this,e)){if(e.__staleWhileFetching)return e.__staleWhileFetching}else if(e!==void 0)return e}}finally{if(_(this,te)&&_(this,Mt)){const e=_(this,Mt);let s;for(;s=e==null?void 0:e.shift();)(t=_(this,Pe))==null||t.call(this,...s)}}}has(t,e={}){const{updateAgeOnHas:s=this.updateAgeOnHas,status:i}=e,r=_(this,At).get(t);if(r!==void 0){const a=_(this,z)[r];if(D(this,N,at).call(this,a)&&a.__staleWhileFetching===void 0)return!1;if(!_(this,Ie).call(this,r))return s&&_(this,qs).call(this,r),i&&(i.has="hit",_(this,ds).call(this,i,r)),!0;i&&(i.has="stale",_(this,ds).call(this,i,r))}else i&&(i.has="miss");return!1}peek(t,e={}){const{allowStale:s=this.allowStale}=e,i=_(this,At).get(t);if(i===void 0||!s&&_(this,Ie).call(this,i))return;const r=_(this,z)[i];return D(this,N,at).call(this,r)?r.__staleWhileFetching:r}async fetch(t,e={}){const{allowStale:s=this.allowStale,updateAgeOnGet:i=this.updateAgeOnGet,noDeleteOnStaleGet:r=this.noDeleteOnStaleGet,ttl:a=this.ttl,noDisposeOnSet:o=this.noDisposeOnSet,size:h=0,sizeCalculation:l=this.sizeCalculation,noUpdateTTL:d=this.noUpdateTTL,noDeleteOnFetchRejection:u=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:p=this.allowStaleOnFetchRejection,ignoreFetchAbort:f=this.ignoreFetchAbort,allowStaleOnFetchAbort:m=this.allowStaleOnFetchAbort,context:b,forceRefresh:I=!1,status:C,signal:R}=e;if(!_(this,vs))return C&&(C.fetch="get"),this.get(t,{allowStale:s,updateAgeOnGet:i,noDeleteOnStaleGet:r,status:C});const E={allowStale:s,updateAgeOnGet:i,noDeleteOnStaleGet:r,ttl:a,noDisposeOnSet:o,size:h,sizeCalculation:l,noUpdateTTL:d,noDeleteOnFetchRejection:u,allowStaleOnFetchRejection:p,allowStaleOnFetchAbort:m,ignoreFetchAbort:f,status:C,signal:R};let g=_(this,At).get(t);if(g===void 0){C&&(C.fetch="miss");const w=D(this,N,Nn).call(this,t,g,E,b);return w.__returned=w}{const w=_(this,z)[g];if(D(this,N,at).call(this,w)){const S=s&&w.__staleWhileFetching!==void 0;return C&&(C.fetch="inflight",S&&(C.returnedStale=!0)),S?w.__staleWhileFetching:w.__returned=w}const A=_(this,Ie).call(this,g);if(!I&&!A)return C&&(C.fetch="hit"),D(this,N,gi).call(this,g),i&&_(this,qs).call(this,g),C&&_(this,ds).call(this,C,g),w;const y=D(this,N,Nn).call(this,t,g,E,b),F=y.__staleWhileFetching!==void 0&&s;return C&&(C.fetch=A?"stale":"refresh",F&&A&&(C.returnedStale=!0)),F?y.__staleWhileFetching:y.__returned=y}}async forceFetch(t,e={}){const s=await this.fetch(t,e);if(s===void 0)throw new Error("fetch() returned undefined");return s}memo(t,e={}){const s=_(this,mi);if(!s)throw new Error("no memoMethod provided to constructor");const{context:i,forceRefresh:r,...a}=e,o=this.get(t,a);if(!r&&o!==void 0)return o;const h=s(t,o,{options:a,context:i});return this.set(t,h,a),h}get(t,e={}){const{allowStale:s=this.allowStale,updateAgeOnGet:i=this.updateAgeOnGet,noDeleteOnStaleGet:r=this.noDeleteOnStaleGet,status:a}=e,o=_(this,At).get(t);if(o!==void 0){const h=_(this,z)[o],l=D(this,N,at).call(this,h);return a&&_(this,ds).call(this,a,o),_(this,Ie).call(this,o)?(a&&(a.get="stale"),l?(a&&s&&h.__staleWhileFetching!==void 0&&(a.returnedStale=!0),s?h.__staleWhileFetching:void 0):(r||D(this,N,_s).call(this,t,"expire"),a&&s&&(a.returnedStale=!0),s?h:void 0)):(a&&(a.get="hit"),l?h.__staleWhileFetching:(D(this,N,gi).call(this,o),i&&_(this,qs).call(this,o),h))}a&&(a.get="miss")}delete(t){return D(this,N,_s).call(this,t,"delete")}clear(){return D(this,N,zr).call(this,"delete")}};De=new WeakMap,ue=new WeakMap,Ue=new WeakMap,Hs=new WeakMap,Pe=new WeakMap,vi=new WeakMap,mi=new WeakMap,St=new WeakMap,fe=new WeakMap,At=new WeakMap,ht=new WeakMap,z=new WeakMap,Jt=new WeakMap,pe=new WeakMap,Gt=new WeakMap,Pt=new WeakMap,Ge=new WeakMap,Mt=new WeakMap,Ve=new WeakMap,Be=new WeakMap,be=new WeakMap,ze=new WeakMap,vs=new WeakMap,te=new WeakMap,Ci=new WeakMap,N=new WeakSet,Br=function(){const n=new zn(_(this,De)),t=new zn(_(this,De));B(this,be,n),B(this,Be,t),B(this,jn,(i,r,a=ei.now())=>{if(t[i]=r!==0?a:0,n[i]=r,r!==0&&this.ttlAutopurge){const o=setTimeout(()=>{_(this,Ie).call(this,i)&&D(this,N,_s).call(this,_(this,ht)[i],"expire")},r+1);o.unref&&o.unref()}}),B(this,qs,i=>{t[i]=n[i]!==0?ei.now():0}),B(this,ds,(i,r)=>{if(n[r]){const a=n[r],o=t[r];if(!a||!o)return;i.ttl=a,i.start=o,i.now=e||s();const h=i.now-o;i.remainingTTL=a-h}});let e=0;const s=()=>{const i=ei.now();if(this.ttlResolution>0){e=i;const r=setTimeout(()=>e=0,this.ttlResolution);r.unref&&r.unref()}return i};this.getRemainingTTL=i=>{const r=_(this,At).get(i);if(r===void 0)return 0;const a=n[r],o=t[r];return!a||!o?1/0:a-((e||s())-o)},B(this,Ie,i=>{const r=t[i],a=n[i];return!!a&&!!r&&(e||s())-r>a})},qs=new WeakMap,ds=new WeakMap,jn=new WeakMap,Ie=new WeakMap,Ao=function(){const n=new zn(_(this,De));B(this,fe,0),B(this,Ve,n),B(this,Zs,t=>{B(this,fe,_(this,fe)-n[t]),n[t]=0}),B(this,qn,(t,e,s,i)=>{if(D(this,N,at).call(this,e))return 0;if(!bs(s)){if(!i)throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");if(typeof i!="function")throw new TypeError("sizeCalculation must be a function");if(s=i(e,t),!bs(s))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}return s}),B(this,Li,(t,e,s)=>{if(n[t]=e,_(this,ue)){const i=_(this,ue)-n[t];for(;_(this,fe)>i;)D(this,N,Zn).call(this,!0)}B(this,fe,_(this,fe)+n[t]),s&&(s.entrySize=e,s.totalCalculatedSize=_(this,fe))})},Zs=new WeakMap,Li=new WeakMap,qn=new WeakMap,ls=function*({allowStale:n=this.allowStale}={}){if(_(this,St))for(let t=_(this,Pt);D(this,N,cr).call(this,t)&&(!n&&_(this,Ie).call(this,t)||(yield t),t!==_(this,Gt));)t=_(this,pe)[t]},us=function*({allowStale:n=this.allowStale}={}){if(_(this,St))for(let t=_(this,Gt);D(this,N,cr).call(this,t)&&(!n&&_(this,Ie).call(this,t)||(yield t),t!==_(this,Pt));)t=_(this,Jt)[t]},cr=function(n){return n!==void 0&&_(this,At).get(_(this,ht)[n])===n},Zn=function(n){var t,e;const s=_(this,Gt),i=_(this,ht)[s],r=_(this,z)[s];return _(this,vs)&&D(this,N,at).call(this,r)?r.__abortController.abort(new Error("evicted")):(_(this,ze)||_(this,te))&&(_(this,ze)&&((t=_(this,Ue))==null||t.call(this,r,i,"evict")),_(this,te)&&((e=_(this,Mt))==null||e.push([r,i,"evict"]))),_(this,Zs).call(this,s),n&&(_(this,ht)[s]=void 0,_(this,z)[s]=void 0,_(this,Ge).push(s)),_(this,St)===1?(B(this,Gt,B(this,Pt,0)),_(this,Ge).length=0):B(this,Gt,_(this,Jt)[s]),_(this,At).delete(i),Gr(this,St)._--,s},Nn=function(n,t,e,s){const i=t===void 0?void 0:_(this,z)[t];if(D(this,N,at).call(this,i))return i;const r=new tr,{signal:a}=e;a==null||a.addEventListener("abort",()=>r.abort(a.reason),{signal:r.signal});const o={signal:r.signal,options:e,context:s},h=(p,f=!1)=>{const{aborted:m}=r.signal,b=e.ignoreFetchAbort&&p!==void 0;if(e.status&&(m&&!f?(e.status.fetchAborted=!0,e.status.fetchError=r.signal.reason,b&&(e.status.fetchAbortIgnored=!0)):e.status.fetchResolved=!0),m&&!b&&!f)return l(r.signal.reason);const I=d;return _(this,z)[t]===d&&(p===void 0?I.__staleWhileFetching?_(this,z)[t]=I.__staleWhileFetching:D(this,N,_s).call(this,n,"fetch"):(e.status&&(e.status.fetchUpdated=!0),this.set(n,p,o.options))),p},l=p=>{const{aborted:f}=r.signal,m=f&&e.allowStaleOnFetchAbort,b=m||e.allowStaleOnFetchRejection,I=b||e.noDeleteOnFetchRejection,C=d;if(_(this,z)[t]===d&&(!I||C.__staleWhileFetching===void 0?D(this,N,_s).call(this,n,"fetch"):m||(_(this,z)[t]=C.__staleWhileFetching)),b)return e.status&&C.__staleWhileFetching!==void 0&&(e.status.returnedStale=!0),C.__staleWhileFetching;if(C.__returned===C)throw p};e.status&&(e.status.fetchDispatched=!0);const d=new Promise((p,f)=>{var m;const b=(m=_(this,vi))==null?void 0:m.call(this,n,i,o);b&&b instanceof Promise&&b.then(I=>p(I===void 0?void 0:I),f),r.signal.addEventListener("abort",()=>{e.ignoreFetchAbort&&!e.allowStaleOnFetchAbort||(p(void 0),e.allowStaleOnFetchAbort&&(p=I=>h(I,!0)))})}).then(h,p=>(e.status&&(e.status.fetchRejected=!0,e.status.fetchError=p),l(p))),u=Object.assign(d,{__abortController:r,__staleWhileFetching:i,__returned:void 0});return t===void 0?(this.set(n,u,{...o.options,status:void 0}),t=_(this,At).get(n)):_(this,z)[t]=u,u},at=function(n){if(!_(this,vs))return!1;const t=n;return!!t&&t instanceof Promise&&t.hasOwnProperty("__staleWhileFetching")&&t.__abortController instanceof tr},dr=function(n,t){_(this,pe)[t]=n,_(this,Jt)[n]=t},gi=function(n){n!==_(this,Pt)&&(n===_(this,Gt)?B(this,Gt,_(this,Jt)[n]):D(this,N,dr).call(this,_(this,pe)[n],_(this,Jt)[n]),D(this,N,dr).call(this,_(this,Pt),n),B(this,Pt,n))},_s=function(n,t){var e,s,i,r;let a=!1;if(_(this,St)!==0){const o=_(this,At).get(n);if(o!==void 0)if(a=!0,_(this,St)===1)D(this,N,zr).call(this,t);else{_(this,Zs).call(this,o);const h=_(this,z)[o];if(D(this,N,at).call(this,h)?h.__abortController.abort(new Error("deleted")):(_(this,ze)||_(this,te))&&(_(this,ze)&&((e=_(this,Ue))==null||e.call(this,h,n,t)),_(this,te)&&((s=_(this,Mt))==null||s.push([h,n,t]))),_(this,At).delete(n),_(this,ht)[o]=void 0,_(this,z)[o]=void 0,o===_(this,Pt))B(this,Pt,_(this,pe)[o]);else if(o===_(this,Gt))B(this,Gt,_(this,Jt)[o]);else{const l=_(this,pe)[o];_(this,Jt)[l]=_(this,Jt)[o];const d=_(this,Jt)[o];_(this,pe)[d]=_(this,pe)[o]}Gr(this,St)._--,_(this,Ge).push(o)}}if(_(this,te)&&((i=_(this,Mt))!=null&&i.length)){const o=_(this,Mt);let h;for(;h=o==null?void 0:o.shift();)(r=_(this,Pe))==null||r.call(this,...h)}return a},zr=function(n){var t,e,s;for(const i of D(this,N,us).call(this,{allowStale:!0})){const r=_(this,z)[i];if(D(this,N,at).call(this,r))r.__abortController.abort(new Error("deleted"));else{const a=_(this,ht)[i];_(this,ze)&&((t=_(this,Ue))==null||t.call(this,r,a,n)),_(this,te)&&((e=_(this,Mt))==null||e.push([r,a,n]))}}if(_(this,At).clear(),_(this,z).fill(void 0),_(this,ht).fill(void 0),_(this,be)&&_(this,Be)&&(_(this,be).fill(0),_(this,Be).fill(0)),_(this,Ve)&&_(this,Ve).fill(0),B(this,Gt,0),B(this,Pt,0),_(this,Ge).length=0,B(this,fe,0),B(this,St,0),_(this,te)&&_(this,Mt)){const i=_(this,Mt);let r;for(;r=i==null?void 0:i.shift();)(s=_(this,Pe))==null||s.call(this,...r)}};let Ap=Rp;const ts=class{static get(n){return this._meshes.get(n)}static lockIn(n){Object.seal(n)}static add(n,t){this._meshes.set(n,t)}static delete(n){for(const t of n)this._meshes.delete(t)}static setCapacity(n){n!==this._capacity&&(this._meshes.clear(),this._meshes=this.setupMeshes(n),this._capacity=n)}static setupMeshes(n){const t=Math.max(n??this.computeCapacity(),1),e=this.getSizeCalculationEvent();return new Ap({maxSize:t,sizeCalculation:e})}static computeCapacity(){const n=globalThis.navigator&&"deviceMemory"in globalThis.navigator?globalThis.navigator.deviceMemory:null,t=n!==null?n:2,e=this.oneHundredMb*t;return Math.trunc(e)}static getDataSetMemory(n){let t=0;for(const e of n)t+=e.usedMemory;return Math.max(t,1)}static getSizeCalculationEvent(){return n=>Array.isArray(n)?this.getDataSetMemory(n):Math.max(n.usedMemory,1)}};c(ts,"oneHundredMb",1e8),c(ts,"_meshes",ts.setupMeshes()),c(ts,"_capacity"),c(ts,"_memoryAttributes",["positionBuffer","indexBuffer","normalBuffer"]),c(ts,"updateMeshMemory",n=>{n.usedMemory=0;for(const t of ts._memoryAttributes)n.usedMemory!==void 0&&n[t]&&(n.usedMemory+=n[t].byteLength);ts.lockIn(n)});let js=ts;const wp=class Gn{constructor(t){c(this,"meshes"),c(this,"tilesUpdated",!1),c(this,"_sampleAmount"),c(this,"_tileDimension"),c(this,"_tileBySample"),c(this,"_lodBySample"),c(this,"_virtualMeshes",new Map),c(this,"_meshConnection"),c(this,"_samples"),c(this,"_tileIdGenerator",new fa),c(this,"_tiles",new Map),c(this,"_tilesChanged",new Set),c(this,"_sizeByTile",new Map),c(this,"_samplesDimensions"),c(this,"_sampleLodClass"),c(this,"_sampleLodState"),c(this,"_sampleLodSize"),c(this,"_boxes"),c(this,"_items"),c(this,"_materials"),c(this,"_modelId"),c(this,"_lastView",{rotation:new T,location:new T}),c(this,"_params",{updateTime:16,updateSamples:64,updateviewOrientation:8*Math.PI/180,updateViewPosition:256,smallTileSize:.32,mediumTileSize:4,smallObjectSize:2,smallScreenSize:2,mediumScreenSize:4,largeScreenSize:16,tempTileDataSize:6,tileIdIncrement:1,tileSizeMultiplier:10,minTileDimension:32,tileDimensionFactor:8}),c(this,"_temp",{sample:new nr,representation:new ir,vector:new T,matrix:new rt,transform:new rt,boundingBox:new Et,sampleGeometry:{},box:new Et,raycastPoints:[],tileData:{positionCount:this._params.tempTileDataSize,objectClass:Wt.LINE,positionBuffer:new Float32Array(this._params.tempTileDataSize)},tileCenter:new T,tile:{objectClass:Wt.LINE,positionCount:6},viewDimension:0,pastFieldOfview:0}),c(this,"_currentSample",0),c(this,"_virtualPlanes",[]),c(this,"_changedSamples",0),c(this,"_virtualView"),this._modelId=t.modelId,this._boxes=t.boxes,this._items=t.items,this._materials=t.materials,this._meshConnection=new Cp(t.modelId,t.connection),this.meshes=t.model.meshes(),this._sampleAmount=this.meshes.samplesLength(),this._samples=new mp(this._sampleAmount),this._samplesDimensions=new Int32Array(this._sampleAmount),this._sampleLodClass=new Uint8Array(this._sampleAmount),this._sampleLodState=new Uint8Array(this._sampleAmount),this._sampleLodSize=new Float32Array(this._sampleAmount),this._tileDimension=this.computeTileSize(),this._tileBySample=new Array(this._sampleAmount),this._lodBySample=new Array(this._sampleAmount),this.init()}restart(){this.resetUpdateProcess(),this._meshConnection.clean()}fetchSample(t,e){this.fetchSampleAndRepresentation(t);const s=this.fetchCurrentMesh(),i=this.sampleTemplate(t);return i.geometries=this.sampleGeoms(i,e,s),i}dispose(){this._meshConnection.dispose();for(const[,t]of this._virtualMeshes)t.dispose()}generate(){for(const[,t]of this._virtualMeshes)t.setupTemplates();for(let t=0;t<this._sampleAmount;t++)this.generateSampleInTiles(t);this.setupTileVisibilityAndHighlight()}setupView(t){this._virtualView=t,js.setCapacity(t.meshThreshold),this.restart(),this.updateOrientationIfNeeded(),this.updatePositionIfNeeded(),this.setupViewPlanes()}updateVirtualMeshes(t){if(t&&this._virtualView){for(const e of t)this.updateItem(e);this.restart()}}getSampleTransform(t){return this.fetchSampleAndRepresentation(t),this.sampleTemplate(t).transform}async update(t){this.updateTiles(t),this.notifyUpdateFinished();for(const e of this._tilesChanged){const s=this._tiles.get(e);this._meshConnection.process({tileRequestClass:_t.UPDATE,modelId:this._modelId,tileId:e,objectClass:s.objectClass,material:s.materialId,tileData:this.getTileData(s),currentLod:s.lod})}this._tilesChanged.clear()}raycast(t,e,s,i){this._temp.raycastPoints=[];const r=t.representationClass(),a=this._virtualMeshes.get(r);return this.manageRaycast(a,t,e,s,i),this._temp.raycastPoints}init(){const t=new up(this._modelId,this.meshes),e=t.getRepresentation();this._virtualMeshes.set(e,t);const s=new Ep(this._modelId,this.meshes),i=s.getRepresentation();this._virtualMeshes.set(i,s),this.processSamplesDimension(),this.fetchSampleLodSize()}initSampleLod(t){this.fetchSampleAndRepresentation(t);const e=this.fetchCurrentMesh();this._sampleLodClass[t]=e.getLodClass(),this._sampleLodState[t]=Y.INVISIBLE}fetchSampleAndRepresentation(t){this.meshes.samples(t,this._temp.sample),this.meshes.representations(this._temp.sample.representation(),this._temp.representation)}fetchCurrentMesh(){const t=this._temp.representation.representationClass();return this._virtualMeshes.get(t)}fetchCurrentMaterial(){const t=this._temp.sample.material();return this._materials[t]}fetchSampleLodSize(){for(let t=0;t<this._sampleAmount;t++)this.initSampleLod(t),Xs.getBox(this._temp.representation,this._temp.box),this._sampleLodSize[t]=Do.getWidth(this._temp.box)}setupTileVisibilityAndHighlight(){for(const[,t]of this._tiles)t.visibilities=new Ri(t.size,!1),t.highlights=new Ri(t.size,0)}addLodToTile(t,e,s){t.getLodClass()!==Ps.AABB?t.getLodClass()===Ps.CUSTOM&&this.addCustomLodToTile(t,e,s):this.addBoxLodToTile(e,s)}addBoxLodToTile(t,e){this._lodBySample[t]=this.lodTileAppendSample(t,e)}notifyUpdateFinished(){const t=!this.tilesUpdated;this._changedSamples>=this._sampleAmount&&t&&(this._meshConnection.process({tileRequestClass:_t.FINISH,modelId:this._modelId}),this.tilesUpdated=!0)}updatePositionIfNeeded(){const t=this._params.updateViewPosition,e=this._virtualView.cameraPosition;e.distanceToSquared(this._lastView.location)>t&&(this._currentSample=0,this._lastView.location.copy(e))}updateCurrentSample(){this._currentSample++,this._currentSample>=this._sampleAmount&&(this._currentSample=0),this._changedSamples++}processSamplesDimension(){for(let t=0;t<this._sampleAmount;t++)this._samplesDimensions[t]=t;this._samplesDimensions.sort((t,e)=>this._boxes.dimensionOf(e)-this._boxes.dimensionOf(t))}setupViewPlanes(){this._virtualPlanes=[];for(const t of this._virtualView.cameraFrustum.planes)this._virtualPlanes.push(t);if(this._virtualView.clippingPlanes)for(const t of this._virtualView.clippingPlanes)this._virtualPlanes.push(t)}updateOrientationIfNeeded(){const t=this.getCurrentViewOrientation(),e=this._params.updateviewOrientation;t.angleTo(this._lastView.rotation)>e&&(this._currentSample=0,this._lastView.rotation.copy(t))}getCurrentViewOrientation(){return this._virtualView.cameraFrustum.planes[4].normal}resetUpdateProcess(){this._changedSamples=0,this.tilesUpdated=!1}manageRaycast(t,e,s,i,r){const a=gp.cast(t,e,s,i,r);if(a)for(const o of a)o.representationClass=t.getObjectClass(),this._temp.raycastPoints.push(o)}setTileShellBuffer(t){t.usedMemory!==void 0&&t.objectClass===Wt.SHELL&&(t.ids=new Float32Array(t.positionCount/3),t.usedMemory+=t.ids.byteLength)}getTileWhenSamplePut(t,e,s){let i=this._tiles.get(t);if(i===void 0){const r=e.lod||Y.GEOMETRY;i=this.newTile(e.objectClass,s,r),this._tiles.set(t,i)}return i}getPerspTrueDim(t,e){const s=Math.PI/180;return e*Math.tan(.5*t*s)}getTileHighlight(t,e){let s,i;const r=t.highlights;if(!r)return{highlightData:void 0,highlightIds:void 0};const a=r.size(o=>o!==0);if(a>0){i=new Uint16Array(a);const o=l=>l!==0,h=(l,d)=>i[l]=d;s=Ri.get(r,e,o,h)}return{highlightData:s,highlightIds:i}}setupTileSampleAttributes(t,e,s,i){const r=3*t.vertexLocation[e];for(let a=0;a<s.positionBuffer.length;a+=3)this._temp.vector.fromArray(s.positionBuffer,a),this._temp.vector.applyMatrix4(this._temp.matrix),this._temp.vector.toArray(t.positionBuffer,r+a);if(t.normalBuffer){const a=3*t.vertexLocation[e];for(let o=0;o<s.normalBuffer.length;o+=3)this._temp.vector.fromArray(s.normalBuffer,o),this._temp.vector.transformDirection(this._temp.matrix),this._temp.vector.multiplyScalar(Yi),this._temp.vector.toArray(t.normalBuffer,a+o)}if(t.indexBuffer){const a=t.indexLocation[e],o=t.vertexLocation[e];for(let h=0;h<s.indexCount;h++){const l=s.indexBuffer[h]+o;t.indexBuffer[h+a]=l}}if(t.faceIdBuffer&&s.faceIdBuffer){const a=100*i.sample,o=t.vertexLocation[e],h=o+s.positionCount/3;for(let l=o;l<h;l++)t.faceIdBuffer[l]=s.faceIdBuffer[l-o]+a}if(s.objectClass===Wt.SHELL){const a=t.vertexLocation[e],o=a+s.positionCount/3;t.ids.fill(this.itemId(i.sample),a,o)}}getTileVisibility(t,e){if(!t.visibilities)throw new Error("Fragments: Malformed tile!");if(!t.visibilities.fullOf(!1))return Ri.get(t.visibilities,e,s=>s)}memoryOverflow(){return Gn._graphicMemoryConsumed>this._virtualView.graphicThreshold}updateMesh(t){let e=this.fetchLodLevel(t);const s=this._sampleLodState[t];e=this.hideHighlightedLods(e,t),e!==s?this.updateVisible(s,e,t):this.updateSampleIfSeen(e,t)}tileLoadSample(t,e,s){const i=t.sampleLocation.get(e.sample),r=this.getSampleGeometries(e,s);this.setupTileLocation(t,r,e),this.fetchSampleTransform(t,e),this.setupTileSampleAttributes(t,i,r,e)}updateSampleIfSeen(t,e){t!==Y.INVISIBLE&&this.updateSample(e,t)}hideHighlightedLods(t,e){return t===Y.WIRES&&this._samples.getHighlight(e)&&(t=Y.INVISIBLE),t}updateVisible(t,e,s){t!==Y.INVISIBLE&&this.makeSampleInvisible(s,t);const i=e!==Y.INVISIBLE;i&&this.updateSample(s,e),this._samples.setVisible(s,i),this._sampleLodState[s]=e}makeInvisibleFromTile(t,e){const s=this._tiles.get(t);this.updateTileData(s,e,!1,0),this.deleteTileIfNeeded(s,t)}updateSample(t,e){const s=this.itemId(t),i=this._items.visible(s),r=this._items.getHighlight(s);this.hasChanged(t,e,i,r)&&this.setSample(t,i,r,e)}hasHighlightChanged(t,e){return e!==this._samples.getHighlight(t)}hasVisibleChanged(t,e){return e!==this._samples.visible(t)}newTile(t,e,s){const i={notVirtual:!1};return i.materialId=e,i.indexLocation=[],i.box=new Et,i.objectClass=t,i.lod=s,i.normalCount=0,i.indexCount=0,i.vertexLocation=[],i.size=0,i.geometriesLocation=[],i.positionCount=0,i.sampleLocation=new Map,i.faceIdBuffer=new Uint32Array(0),i}createLod(t){const e=Xs.boxSize(t),s=this._temp.tileData.positionBuffer;if(!s)throw new Error("Fragments: Malformed tiles!");return s[0]=e.start.x,s[1]=e.start.y,s[2]=e.start.z,s[3]=e.end.x,s[4]=e.end.y,s[5]=e.end.z,this._temp.tileData}sampleTemplate(t){const e=this._temp.sample,s=this._temp.representation;Xs.get(e,this.meshes,this._temp.transform),Xs.getBox(s,this._temp.boundingBox),this._temp.sampleGeometry.sample=t;const i=e.material();return this._temp.sampleGeometry.material=this._materials[i],this._temp.sampleGeometry.transform=this._temp.transform,this._temp.sampleGeometry.aabb=this._temp.boundingBox,delete this._temp.sampleGeometry.geometries,this._temp.sampleGeometry}makeSampleInvisible(t,e){const s=this.getTileIds(t,e);s&&Ae.forEach(s,i=>this.makeInvisibleFromTile(i,t))}setSample(t,e,s,i){this._samples.setVisible(t,e),this._samples.setHighlight(t,s);const r=this.getTileIds(t,i);r!==void 0&&Ae.forEach(r,a=>{this.updateTile(a,t,s,s===0)})}getTileIds(t,e){return e===Y.GEOMETRY?this._tileBySample[t]:this._lodBySample[t]}addBasicTileData(t,e,s){t.sampleLocation.set(e,t.size),t.size++,t.geometriesLocation.push(s),t.indexLocation.push(t.indexCount||0),t.vertexLocation.push((t.positionCount||0)/3)}buildNewVirtualTile(t,e){this.constructTile(t),this.loadTile(e,t),t.notVirtual=!0,delete t.indexBuffer,delete t.positionBuffer,delete t.normalBuffer,delete t.faceIdBuffer,delete t.ids}deleteTileIfNeeded(t,e){if(this.getShouldDeleteTile(t))return this.deleteGeometry(e),t.notVirtual=!1,void(Gn._graphicMemoryConsumed-=t.usedMemory);this._tilesChanged.add(e)}getShouldDeleteTile(t){if(!t.visibilities||!t.highlights)throw new Error("Fragments: Malformed tile!");const e=t.visibilities.fullOf(!1),s=t.highlights.fullOf(0),i=this.memoryOverflow();return e&&s&&i}checkTileMemoryOverflow(t,e){const s=this._tiles.get(t);return(s?s.positionCount:0)+e.positionCount>ni}updateTileData(t,e,s,i){if(!t.visibilities||!t.highlights)throw new Error("Fragments: Malformed tile!");const r=t.sampleLocation.get(e);t.visibilities.update(r,s),t.highlights.update(r,i)}getKeepUpdating(t,e){const s=this._params.updateTime,i=this._params.updateSamples,r=t<this._sampleAmount,a=performance.now()-e;return r&&(a<s||t<i)}computeTileSize(){const t=this._boxes.fullBox.getSize(this._temp.vector),e=Math.max(t.x,t.y,t.z)/this._params.tileDimensionFactor,s=Math.ceil(e);return Math.max(this._params.minTileDimension,s)}newTileId(t,e,s){this.logBufferOverflowIfNeeded(s);const i=s.lod||Y.GEOMETRY,r=this.generateTileCode(t,e,s,i),a=this._sizeByTile.get(r)||1;let o=r+a-1;return this.checkTileMemoryOverflow(o,s)&&(o+=this._params.tileIdIncrement,this._sizeByTile.set(r,a+1)),o}logBufferOverflowIfNeeded(t){t.positionCount/3>ni&&console.log("Fragments: Buffer overflow")}fetchLodLevel(t){const e=this._boxes.get(t);if(!Ms.collides(e,this._virtualPlanes))return Y.INVISIBLE;this.meshes.samples(t,this._temp.sample);const s=this._temp.sample.item();if(!this._items.visible(s))return Y.INVISIBLE;const i=this._virtualView.graphicQuality,r=this._boxes.dimensionOf(t),a=e.distanceToPoint(this._virtualView.cameraPosition),o=this.screenSize(r,a),h=r<this._params.smallObjectSize,l=!h,d=this._params.smallScreenSize*i,u=this._params.mediumScreenSize*i,p=this._params.largeScreenSize*i,f=o<u,m=h&&o<p,b=l&&f;if(h&&f||l&&o<d)return Y.INVISIBLE;if(m||b)return Y.WIRES;const I=this._sampleLodSize[t];return this.screenSize(I,a)<Math.max(u,this._params.mediumScreenSize)?Y.WIRES:Y.GEOMETRY}generateTileCode(t,e,s,i){this._tileIdGenerator.reset(),this.processTileDataId(s,e,i);const r=this.processTileSpatialId(t,i);return this.processTileDimensionId(r),this._tileIdGenerator.value}processTileDataId(t,e,s){this._tileIdGenerator.compute(t.objectClass!==void 0?t.objectClass:0),this._tileIdGenerator.compute(e),this._tileIdGenerator.compute(s)}deleteGeometry(t){this._meshConnection.process({tileRequestClass:_t.DELETE,modelId:this._modelId,tileId:t})}processTileSpatialId(t,e){const s=this._temp.tileCenter.x,i=this._temp.tileCenter.y,r=this._temp.tileCenter.z,a=this._boxes.get(t);a.getCenter(this._temp.tileCenter);const o=this.getTileDimension(e),h=s-s%o,l=i-i%o,d=r-r%o;return this._tileIdGenerator.compute(h),this._tileIdGenerator.compute(l),this._tileIdGenerator.compute(d),a}addCustomLodToTile(t,e,s){const i=this.meshData(t,!1,Y.WIRES);this._sampleLodSize[e]=i.lodThickness||0,this._lodBySample[e]=this.putSampleInTiles(e,s,i)}getTileLocations(t){return t.indexCount?t.indexLocation:t.vertexLocation}getTileDimension(t){let e=this._tileDimension;return t===Y.GEOMETRY&&(e*=this._params.tileSizeMultiplier),e}processTileDimensionId(t){const e=this.getTileDimensionClass(t);this._tileIdGenerator.compute(e)}tileAppend(t,e,s,i){this.addBasicTileData(t,s,i),this.tileAppendAttribute(t,e,"indexCount",!1),this.tileAppendAttribute(t,e,"positionCount",!1),this.tileAppendAttribute(t,e,"normalCount",!1),this.tileAppendAttribute(t,e,"materialId",!0)}putSampleInTiles(t,e,s){let i;return Ae.forEach(s,(r,a)=>{const o=this.newTileId(t,e,r);i=this.getTileIdsWhenSamplePut(i,o);const h=this.getTileWhenSamplePut(o,r,e);this.tileAppend(h,r,t,a)}),i}hasLodChanged(t,e){return e!==this._sampleLodState[t]}getTileIdsWhenSamplePut(t,e){return t===void 0?t=e:typeof t=="number"?t!==e&&(t=[t,e]):t.includes(e)||t.push(e),t}updateTile(t,e,s,i){const r=this._tiles.get(t);this.updateTileData(r,e,i,s),r.notVirtual?this._tilesChanged.add(t):this.buildNewVirtualTile(r,t)}getLodTileWhenPutSample(t,e){let s=this._tiles.get(t);if(!s){const i=this._temp.tile.objectClass;s=this.newTile(i,e,Y.WIRES),this._tiles.set(t,s)}return s}lodTileAppendSample(t,e){const s=Y.WIRES,i=this._temp.tile,r=this.generateTileCode(t,e,i,s),a=this.getLodTileWhenPutSample(r,e);return this.tileAppend(a,i,t,0),r}addSampleToTile(t,e,s){const i=this.meshData(t,!1,Y.GEOMETRY);this._tileBySample[e]=this.putSampleInTiles(e,s,i)}setTileBuffer(t,e,s){if(t.usedMemory===void 0)return;const i=t[`${e}Count`];if(i>0){const r=s?new Uint16Array(i):new Int16Array(i);t[`${e}Buffer`]=r,t.usedMemory+=r.byteLength}}updateTiles(t){const e=this._changedSamples<this._sampleAmount;if(this._virtualView===void 0||!e)return;let s=!0,i=0;for(;s;){const r=this._samplesDimensions[this._currentSample];this.updateMesh(r),this.updateCurrentSample(),i++,s=this.getKeepUpdating(i,t)}}sampleGeoms(t,e,s){return s.getLodClass()===Ps.AABB&&e===Y.WIRES?this.createLod(t.aabb):this.meshData(s,!0,e)}generateSampleInTiles(t){this.fetchSampleAndRepresentation(t);const e=this.fetchCurrentMaterial(),s=this.fetchCurrentMesh();this.addSampleToTile(s,t,e),this.addLodToTile(s,t,e)}buildSampleInTile(t,e,s,i,r){const a=t.geometriesLocation[e];if(this.tileLoadSample(t,s,a),i){const o=this._boxes.get(r);this._temp.vector.copy(t.location),this._temp.vector.negate(),o.translate(this._temp.vector),t.box.union(o)}}getSampleGeometries(t,e){return Array.isArray(t.geometries)?t.geometries[e]:t.geometries}constructTile(t){t.positionBuffer===void 0&&(t.positionBuffer=new Float32Array(t.positionCount),t.usedMemory=t.positionBuffer.byteLength,this.setTileBuffer(t,"index",!0),this.setTileBuffer(t,"normal",!1),this.setTileShellBuffer(t),t.faceIdBuffer=new Uint32Array(t.positionCount/3),t.usedMemory+=t.faceIdBuffer.byteLength);const e=!t.location;for(const[s,i]of t.sampleLocation){const r=this.fetchSample(s,t.lod);r&&r.geometries&&this.buildSampleInTile(t,i,r,e,s)}}fetchSampleTransform(t,e){this._temp.vector.copy(t.location),this._temp.vector.negate(),this._temp.matrix.identity(),this._temp.matrix.setPosition(this._temp.vector),this._temp.matrix.multiply(e.transform)}hasChanged(t,e,s,i){const r=this.hasLodChanged(t,e),a=this.hasVisibleChanged(t,s),o=this.hasHighlightChanged(t,i);return r||a||o}setupTileLocation(t,e,s){if(t.location)return;const i=new T;i.fromArray(e.positionBuffer),i.applyMatrix4(s.transform),t.location=i}getTileData(t){const e=this.getTileLocations(t),s=this.getTileVisibility(t,e),i=this.getTileHighlight(t,e),{highlightData:r,highlightIds:a}=i;return{visibilityData:s,highlightData:r,highlightIds:a}}updateMemoryOnTileLoad(t){Gn._graphicMemoryConsumed+=t.usedMemory}fetchTileMatrixOnLoad(t){t.location&&(this._temp.matrix.identity(),this._temp.matrix.setPosition(t.location))}updateItem(t){const e=this._boxes.sampleOf(t);if(e)for(const s of e)this.updateMesh(s)}screenSize(t,e){return t/this.getViewDimension(e)*this._virtualView.viewSize}getTileDimensionClass(t){const e=t.min.distanceToSquared(t.max),s=this._params.smallTileSize;return e>this._params.mediumTileSize?2:e>s?1:0}getViewDimension(t){if(this._virtualView.orthogonalDimension)return this._virtualView.orthogonalDimension;const e=this._virtualView.fov;return e!==this._temp.pastFieldOfview&&(this._temp.viewDimension=this.getPerspTrueDim(e,1),this._temp.pastFieldOfview=e),t*this._temp.viewDimension}loadTile(t,e){const s=this.getTileData(e);this.fetchTileMatrixOnLoad(e);const i=this.getFaceIds(e);this._meshConnection.process({tileRequestClass:_t.CREATE,modelId:this._modelId,objectClass:e.objectClass,tileId:t,itemId:void 0,tileData:s,indices:e.indexBuffer,positions:e.positionBuffer,normals:e.normalBuffer,faceIds:i,itemIds:e.ids,material:e.materialId,matrix:this._temp.matrix.clone(),aabb:e.box.clone(),currentLod:e.lod}),this.updateMemoryOnTileLoad(e)}getFaceIds(t){const e=new Wi,s=t.faceIdBuffer,i=new Float32Array(3*s.length);for(let r=0;r<s.length;r++){const a=s[r];e.set(0+a),i[3*r]=e.r,i[3*r+1]=e.g,i[3*r+2]=e.b}return i}meshData(t,e,s){const i=this._temp.representation.id(),r=t.getLodClass()===Ps.CUSTOM,a=s===Y.WIRES;return r&&a?t.fetchLod(i,e):t.fetchMeshes(i,e)}tileAppendAttribute(t,e,s,i){e[s]!==void 0&&(i?t[s]=e[s]:t[s]+=e[s])}itemId(t){return this.meshes.samples(t,this._temp.sample),this._temp.sample.item()}};c(wp,"_graphicMemoryConsumed",0);class Fp{constructor(){c(this,"_templates",new Map)}add(t,e){this._templates.set(t,e)}get(t){const e=this._templates.get(t);return Array.isArray(e)?this.getTemplateSet(e):{...e}}getTemplateSet(t){const e=[];for(const s of t){const i={...s};e.push(i)}return e}}const pl=class Ne{constructor(t,e){c(this,"_dataBuffer"),c(this,"_dataPosition"),this._dataBuffer=e||this.getDefaultData(),this._dataPosition=t||Ne._data.defaultPosition}set(t){let e=0;for(const s of Ne._data.points)for(const i of Ne._data.coords){const r=this.getPosition(i,s),a=t[e++];this.setValue(r,a)}}get(t,e){const s=this.getPosition(t,e);return this._dataBuffer[s]}clone(t){for(const e of Ne._data.points)for(const s of Ne._data.coords){const i=this.getPosition(s,e),r=t.get(s,e);this.setValue(i,r)}}combine(t,e){for(const s of Ne._data.points)for(const i of Ne._data.coords)this.save(i,s,t,e)}setValue(t,e){this._dataBuffer[t]=e}getDefaultData(){return new Float64Array(Ne._data.size)}getPosition(t,e){return Ne._data[e][t]+this._dataPosition}save(t,e,s,i){const r=this.getPosition(t,e),a=s.get(t,e),o=i.get(t,e),h=Math[e](a,o);this.setValue(r,h)}};c(pl,"_data",{size:6,defaultPosition:0,min:{x:0,y:2,z:4},max:{x:1,y:3,z:5},coords:["x","y","z"],points:["min","max"]});let kn=pl;const bl=class Yn{constructor(t,e){c(this,"box"),c(this,"data",0),this.box=new kn(t,e)}get size(){return this.data*Yn._data.factor}get isPoint(){return this.data>=Yn._data.threshold}transform(t,e,s){s||(t*=Yn._data.factor),this.data=t,this.box.clone(e)}};c(bl,"_data",{threshold:0,factor:-1});let Sp=bl;class yp{constructor(t){c(this,"_boxes"),c(this,"_min",new T),c(this,"_max",new T),this._boxes=t}inflate(t){const e=this._boxes.fullBox.min,s=this.getVector(t,e,"min"),i=this.getVector(t,e,"max");return new Et(s,i)}deflate(t,e){this.read(t);const s=[];s.push(this._min.x,this._min.y,this._min.z),s.push(this._max.x,this._max.y,this._max.z),e.set(s)}getVector(t,e,s){const i=t.get("x",s)+e.x,r=t.get("y",s)+e.y,a=t.get("z",s)+e.z;return new T(i,r,a)}read(t){const{min:e}=this._boxes.fullBox;this._min.subVectors(t.min,e),this._max.subVectors(t.max,e)}}class xp{constructor(t,e){c(this,"_data"),c(this,"_compressor"),this._data=e,this._compressor=t}frustumCollide(t,e,s=!1){const i=this.getFrustumPlanes(e,t),r=this.getFrustumOnCollide(i),a=this.getFrustumOnIncludes(i),o=this.newDefaultCallback(!0);return this.collide(r,a,o,s)}rayCollide(t,e){const s=this.getRayOnCollide(e),i=this.newDefaultCallback(!1),r=this.getRayOnSeen(t);return this.collide(s,i,r)}addPoint(t,e,s,i){t?i&&e.push(this.getPointData(s)):e.push(this.getPointData(s))}getPointData(t){return this.getPoint(t).data}getBounds(t){const e=this.getPoint(t);return this._compressor.inflate(e.box)}isPoint(t){return this.getPoint(t).isPoint}newDefaultCallback(t){return e=>t}groupSize(t){return this.getPoint(t).size}getPoint(t){return this._data.points[t]}getRayOnSeen(t){let e=this.newDefaultCallback(!0);return(t==null?void 0:t.length)>0&&(e=s=>Ms.collides(s,t)),e}getRayOnCollide(t){return e=>t.intersectsBox(e)}collide(t,e,s,i=!1){const r=this._data.points.length,a=[];let o=0;const h=(d,u)=>{const p=o+this.groupSize(o);for(;o<p;o++)this.isPoint(o)&&s(d)&&(i?u&&this.savePoint(o,a):this.savePoint(o,a))},l=()=>{const d=this.getBounds(o),u=e(d),p=this.isPoint(o),f=u||t(d);p&&f&&s(d)&&this.addPoint(i,a,o,u),f||p?(o++,u&&!p&&h(d,u)):o+=this.groupSize(o)};for(;o<r;)l();return a}getFrustumOnIncludes(t){return e=>Ms.isIncluded(e,t)}getFrustumOnCollide(t){return e=>Ms.collides(e,t)}getFrustumPlanes(t,e){const s=[];for(const i of t.planes)s.push(i);if(e)for(const i of e)s.push(i);return s}savePoint(t,e){const s=this.getPoint(t);e.push(s.data)}}class Op{constructor(t){c(this,"_boxes"),c(this,"_total",new T),c(this,"_change",new T),c(this,"_average",new T),c(this,"_tempCenterVector",new T),c(this,"_tempVectors",{x:new T,y:new T,z:new T}),this._boxes=t}sort(t,e,s){this.average(this._average,t,e,s),this.getDataToTotal(e,s,t);let i=this.anySort(e,s,t);return i=this.adjust(s,e,i),Math.round(i)}anySort(t,e,s){return this._total.x>this._total.y?this._total.x>this._total.z?this.sortDim("x",this._average.x,t,e,s):this.sortDim("z",this._average.z,t,e,s):this._total.y>this._total.z?this.sortDim("y",this._average.y,t,e,s):this.sortDim("z",this._average.z,t,e,s)}getDataToTotal(t,e,s){this._total.set(0,0,0);for(let i=t;i<e;i++){this._boxes.get(s[i]).getCenter(this._change).sub(this._average);const r=this._change.multiply(this._change);this._total.add(r)}}sortDim(t,e,s,i,r){let a=s;for(let o=s;o<i;o++)this.getValue(r,o,t)>e&&(this.exchange(o,a,r),a++);return a}exchange(t,e,s){const i=s[t];s[t]=s[e],s[e]=i}getValue(t,e,s){const i=this.getBox(t,e),r=this._tempVectors[s];return i.getCenter(r)[s]}average(t,e,s,i){const r=this.getBox(e,s);return r.getCenter(t),this.aggregate(s,i,e,r,t),t.divideScalar(i-s)}aggregate(t,e,s,i,r){for(let a=t+1;a<e;a++){const o=s[a],h=this._boxes.get(o).getCenter(this._tempCenterVector);r.add(h)}}adjust(t,e,s){const i=(e+t)/2,r=(t-e)/3;return(s<=e+r||s>=t-1-r)&&(s=i),s}getBox(t,e){const s=t[e];return this._boxes.get(s)}}class vp{constructor(t,e,s){c(this,"_data"),c(this,"_compressor"),c(this,"_boxes"),c(this,"_sorter"),this._data=s,this._compressor=e,this._boxes=t,this._sorter=new Op(t)}make(t,e,s=0,i=0,r=0,a=0){const o=s-i;return o===1?this.makePoint(t,i,e,a):o===2?this.makeGroup3(a,t,i,e):this.makeGroup(r,t,i,s,a,e)}makeGroup3(t,e,s,i){const r=this.makeBox(t+1,e,s),a=this.makeBox(t+2,e,s+1);return i.combine(r,a),this.newGroup(t,3,i),3}makeGroup(t,e,s,i,r,a){const o=this._data.limits.primary[t],h=this._data.limits.secondary[t],l=this._sorter.sort(e,s,i),d=this.make(e,o,l,s,t+1,r+1),u=r+d+1,p=this.make(e,h,i,l,t+1,u);a.combine(o,h);const f=d+p+1;return this.newGroup(r,f,a),f}makeBox(t,e,s){const i=this._data.points[t].box,r=e[s],a=this._boxes.get(r);return this._compressor.deflate(a,i),this.set(t,r),i}makePoint(t,e,s,i){const r=this._boxes.get(t[e]);return this._compressor.deflate(r,s),this.newPoint(i,t[e],s),1}newGroup(t,e,s){this.get(t).transform(e,s,!1)}get(t){return this._data.points[t]}newPoint(t,e,s){this.get(t).transform(e,s,!0)}set(t,e){this.get(t).data=e}}const uo=class Hn{constructor(t){c(this,"_compressor"),c(this,"_collider"),c(this,"_maker"),c(this,"_data"),c(this,"_boxes"),this._boxes=t,this._compressor=new yp(t),this._data=this.getData(),this._collider=new xp(this._compressor,this._data),this._maker=new vp(this._boxes,this._compressor,this._data),this.initData()}collideFrustum(t,e,s=!1){return this._collider.frustumCollide(t,e,s)}collideRay(t,e){return this._collider.rayCollide(t,e)}setupLimits(){for(let t=0;t<Hn._limitThreshold;t++)this._data.limits.primary.push(new kn),this._data.limits.secondary.push(new kn)}getPointBuffer(){const t=this._boxes.getCount(),e=new Uint32Array(t);for(let s=0;s<e.length;s++)e[s]=s;return e}getPointsAmount(t){return 2*t.length-1}initData(){const t=this.getPointBuffer(),e=this.getPointsAmount(t),s=e*Hn._boxSize,i=new Float64Array(s);for(let a=0;a<e;a++){const o=a*Hn._boxSize,h=new Sp(o,i);this._data.points.push(h)}this.setupLimits();const r=new kn;this._maker.make(t,r,t.length)}getData(){return{points:[],limits:{primary:[],secondary:[]}}}};c(uo,"_boxSize",6),c(uo,"_limitThreshold",32);class Lp{constructor(t){c(this,"onModelLoaded",new kt),c(this,"models"),c(this,"settings",{autoCoordinate:!0,maxUpdateRate:100,graphicsQuality:0}),c(this,"baseCoordinates",null),c(this,"_connection"),c(this,"_isDisposed",!1),c(this,"_autoRedrawInterval",null),c(this,"_lastUpdate",0);const e=this.newRequestEvent(),s=this.newUpdateEvent();this._connection=new Gu(e,t),this.models=new Uu(s),this.models.list.onItemDeleted.add(()=>{this.models.list.size===0&&(this.baseCoordinates=null)})}async load(t,e){const s=new Pu(e.modelId,this.models,this._connection);e.userData&&(s.object.userData=e.userData),s.frozen=!0,s.graphicsQuality=this.settings.graphicsQuality;try{if(this.models.list.set(s.modelId,s),await s._setup(t,e.raw,e.virtualModelConfig),this.settings.autoCoordinate){const r=await s.getCoordinates();if(this.baseCoordinates===null)this.baseCoordinates=r;else{const[a,o,h]=r,[l,d,u]=this.baseCoordinates,p=new T(l-a,d-o,u-h);s.object.position.add(p)}}}catch(r){throw this.models.list.delete(s.modelId),r}const{camera:i}=e;return i&&s.useCamera(i),s.frozen=!1,this.onModelLoaded.trigger(s),s}async dispose(){this._isDisposed=!0;const t=Array.from(this.models.list.values()),e=[];for(const s of t)e.push(s.dispose());await Promise.all(e),this.onModelLoaded.reset()}async disposeModel(t){const e=this.models.list.get(t);e&&await e.dispose()}async update(t=!1){if(this._isDisposed)return;const e=performance.now();if(e-this._lastUpdate<this.settings.maxUpdateRate)return;this._lastUpdate=e;const s=[];for(const i of this.models.list.values())s.push(i._refreshView());await Promise.all(s),t?await this.models.forceUpdateFinish():this.models.update()}async manageRequest(t){const e=this.models.list.get(t.modelId);e&&await e.handleRequest(t)}newUpdateEvent(){return()=>{this._autoRedrawInterval&&clearTimeout(this._autoRedrawInterval);const t=this.settings.maxUpdateRate+1;this._autoRedrawInterval=setTimeout(()=>{this.update()},t)}}newRequestEvent(){return t=>{this.manageRequest(t)}}}class Np{constructor(t,e){c(this,"_lengthUnitsFactor",1),c(this,"_attributesOffsets",[]),c(this,"_relationsMap",{}),c(this,"_guids",[]),c(this,"_guidsItems",[]),c(this,"_uniqueAttributes",new Set),c(this,"_uniqueRelNames",new Set),c(this,"_ifcApi",null),c(this,"wasm",{path:"/node_modules/web-ifc/",absolute:!1}),c(this,"expressIDs",[]),c(this,"classes",[]),this._serializer=t,this._builder=e}async getIfcApi(){if(!this._ifcApi){const t=new Vr;t.SetWasmPath(this.wasm.path,this.wasm.absolute),await t.Init(),t.SetLogLevel(_o.LOG_LEVEL_OFF),this._ifcApi=t}return this._ifcApi}async getSchema(t=0){const e=(await this.getIfcApi()).GetModelSchema(t);if(!e)throw new Error("Fragments: IFC Schema not found");return e.startsWith("IFC2X3")?"IFC2X3":e.startsWith("IFC4")&&e.replace("IFC4","")===""?"IFC4":e.startsWith("IFC4X")?"IFC4X3":e}async process(t){var e,s,i;const r=await this.getIfcApi();if(t.readFromCallback)r.OpenModelFromCallback(t.readCallback,{COORDINATE_TO_ORIGIN:!0});else{if(!t.bytes)throw new Error("Fragments: No data provided");await r.OpenModel(t.bytes,{COORDINATE_TO_ORIGIN:!0})}this._serializer.replaceStoreyElevation&&await this.setLengthUnitsFactor();const a=r.GetAllTypesOfModel(0).map(v=>v.typeID),o=await this.getSchema();if(!yd[o])throw new Error("Fragments: Model schema not recognized.");const h=t.geometryProcessedLocalIDs;await this.processItems(h);const l=new Set(h);(e=t.progressCallback)==null||e.call(t,.6,{process:"attributes",state:"start",entitiesProcessed:h.length});const d=new Set([...this._serializer.classes.abstract,...this._serializer.classes.elements]),u=a.filter(v=>d.has(v)),p=.15/u.length;for(const[v,M]of u.entries()){const V=r.GetLineIDsWithType(0,M);if(V.size()===0)continue;const nt=[];for(let ft=0;ft<V.size();ft++){const tt=V.get(ft);l.has(tt)||nt.push(tt)}nt.length!==0&&(await this.processItems(nt),(s=t.progressCallback)==null||s.call(t,p*(v+1)+.6,{process:"attributes",state:v+1===u.length?"finish":"inProgress",class:Ni[M],entitiesProcessed:nt.length}))}const f=new Set([...this._serializer.relations.keys()]),m=a.filter(v=>f.has(v)),b=.15/m.length;for(const[v,M]of m.entries()){const V=v===0?"start":v+1===m.length?"finish":"inProgress";await this.processRelations([M]),(i=t.progressCallback)==null||i.call(t,b*(v+1)+.75,{process:"relations",state:V,class:Ni[M]})}const{relIndicesVector:I,relsVector:C}=this.getRelationsVector(),{guidsVector:R,guidsItemsVector:E}=this.getGuidsVector(),g=await this.getMetadataOffset(),w=this.getAttributesVector(),A=this.getUniqueAttributesVector(),y=this.getRelNamesVector(),F=K.createLocalIdsVector(this._builder,this.expressIDs),S=this.getCategoriesVector(),x=await this.getSpatialStructureOffset();return this.clean(),{relIndicesVector:I,relsVector:C,guidsVector:R,guidsItemsVector:E,metadataOffset:g,attributesVector:w,localIdsVector:F,categoriesVector:S,spatialStrutureOffset:x,uniqueAttributesVector:A,relNamesVector:y}}async processItems(t){const e=await this.getIfcApi();for(let s=0;s<t.length;s++){const i=t[s];try{const r=await e.properties.getItemProperties(0,i);if(!r)continue;const a=Ni[r.type];this.classes.push(a),this.expressIDs.push(i),await this.serializeAttributes(i,r)}catch(r){console.log(`Problem reading properties for ${i}`),console.log(r),await new Promise(a=>{setTimeout(a,100)});continue}}}addRelation(t,e,s){this._relationsMap[t]||(this._relationsMap[t]={}),this._relationsMap[t][e]||(this._relationsMap[t][e]=[]);for(const i of s)this._relationsMap[t][e].push(i);this._serializer.includeRelationNames&&this._uniqueRelNames.add(e)}async getStoreyElevation(t,e){const s=await this.getIfcApi(),i=await s.properties.getItemProperties(0,t);let r,a;i!=null&&i.RelativePlacement&&"value"in i.RelativePlacement&&typeof i.RelativePlacement.value=="number"&&(r=await s.properties.getItemProperties(0,i.RelativePlacement.value)),r!=null&&r.Location&&"value"in r.Location&&typeof r.Location.value=="number"&&(a=await s.properties.getItemProperties(0,r.Location.value)),a!=null&&a.Coordinates&&Array.isArray(a.Coordinates)&&"value"in a.Coordinates[2]&&typeof a.Coordinates[2].value=="number"&&(e.value+=a.Coordinates[2].value),i!=null&&i.PlacementRelTo&&"value"in i.PlacementRelTo&&typeof i.PlacementRelTo.value=="number"&&await this.getStoreyElevation(i.PlacementRelTo.value,e)}async setLengthUnitsFactor(){var t,e,s;const i=await this.getIfcApi(),r=i.GetLineIDsWithType(0,xd);if(r.size()!==0)for(let a=0;a<r.size();a++){const o=r.get(a),h=await i.properties.getItemProperties(0,o);for(const l of h.Units){const d=await i.properties.getItemProperties(0,l.value);if(d.UnitType.value!=="LENGTHUNIT")continue;let u=1,p=1;d.Name.value==="METRE"&&(p=1),d.Name.value==="FOOT"&&(p=.3048),((t=d.Prefix)==null?void 0:t.value)==="MILLI"?u=.001:((e=d.Prefix)==null?void 0:e.value)==="CENTI"?u=.01:((s=d.Prefix)==null?void 0:s.value)==="DECI"&&(u=.1),this._lengthUnitsFactor=p*u}}}async serializeAttributes(t,e){const s=[];let i=null;if(this._serializer.replaceStoreyElevation&&e.type&&typeof e.type=="number"&&e.type===Ur&&e.Elevation&&"value"in e.Elevation){const o={value:0};e.ObjectPlacement&&"value"in e.ObjectPlacement&&typeof e.ObjectPlacement.value=="number"&&await this.getStoreyElevation(e.ObjectPlacement.value,o),e.Elevation.value=o.value*this._lengthUnitsFactor}for(const[o,h]of Object.entries(e)){if(typeof h=="number"||this._serializer.attributesToExclude.has(o)||h==null)continue;if(Array.isArray(h)){const u=h.filter(f=>f.type!==5);if(u.length>0){const f=[o,u.map(C=>C.value)],m="name"in u[0]&&u[0].name?u[0].name:u[0].constructor.name.toUpperCase();f.push(m!=="OBJECT"?m:"UNDEFINED");const b=JSON.stringify(f),I=this._builder.createSharedString(b);s.push(I)}const p=h.filter(f=>f.type===5).map(f=>f.value);this.addRelation(t,o,p);continue}const{value:l,type:d}=h;if(d===5){if(typeof l!="number")continue;this.addRelation(t,o,[l])}else{if(o==="GlobalId"&&typeof l=="string"){i=l;continue}const u=[o,l],p="name"in h&&h.name?h.name:h.constructor.name.toUpperCase();u.push(p!=="OBJECT"?p:"UNDEFINED");const f=JSON.stringify(u),m=this._builder.createSharedString(f);s.push(m),this._serializer.includeUniqueAttributes&&this._uniqueAttributes.add(f)}}const r=ss.createDataVector(this._builder,s),a=ss.createAttribute(this._builder,r);this._attributesOffsets.push(a),i&&(this._guids.push(i),this._guidsItems.push(t))}getAttributesVector(){return K.createAttributesVector(this._builder,this._attributesOffsets)}getUniqueAttributesVector(){const t=[];for(const e of this._uniqueAttributes){const s=this._builder.createSharedString(e);t.push(s)}return K.createUniqueAttributesVector(this._builder,t)}getRelNamesVector(){const t=[];for(const e of this._uniqueRelNames){const s=this._builder.createSharedString(e);t.push(s)}return K.createRelationNamesVector(this._builder,t)}getGuidsVector(){const t=[];for(const e of this._guids){const s=this._builder.createString(e);t.push(s)}return{guidsVector:K.createGuidsVector(this._builder,t),guidsItemsVector:K.createGuidsItemsVector(this._builder,this._guidsItems)}}async processRelations(t){const e=await this.getIfcApi();for(const s of t){const i=this._serializer.relations.get(s);if(!i)continue;const{forRelating:r,forRelated:a}=i,o=e.GetLineIDsWithType(0,s);if(o.size()!==0)for(let h=0;h<o.size();h++){const l=o.get(h),d=await e.properties.getItemProperties(0,l);if(!d)continue;const u=Object.keys(d),p=u.find(I=>I.startsWith("Relating")),f=u.find(I=>I.startsWith("Related"));if(!p||!f)continue;const m=d[p].value,b=d[f].map(({value:I})=>I);this.addRelation(m,r,b);for(const I of b)this.addRelation(I,a,[m])}}}getRelationsVector(t=!1){const e=[],s=[];for(const[r,a]of Object.entries(this._relationsMap)){if(t&&!this.expressIDs.includes(Number(r)))continue;const o=[];for(const[d,u]of Object.entries(a)){let p=u;if(t&&(p=u.filter(b=>this.expressIDs.includes(b)),p.length===0))continue;const f=JSON.stringify([d,...p]),m=this._builder.createSharedString(f);o.push(m)}if(t&&o.length===0)continue;s.push(Number(r));const h=ns.createDataVector(this._builder,o),l=ns.createRelation(this._builder,h);e.push(l)}const i=K.createRelationsVector(this._builder,e);return{relIndicesVector:K.createRelationsItemsVector(this._builder,s),relsVector:i}}getCategoriesVector(){const t=this.classes.map(e=>this._builder.createSharedString(e));return K.createCategoriesVector(this._builder,t)}async getMetadataOffset(){const t={schema:(await this.getIfcApi()).GetModelSchema(0)};return this._builder.createString(JSON.stringify(t))}getEntityDecomposition(t,e){var s;const i=[];for(const a of e){const o=(s=this._relationsMap[t])==null?void 0:s[a];if(!o)continue;const h={};for(const l of o){const d=this.expressIDs.indexOf(l);if(d===-1)continue;const u=this.classes[d];u&&(h[u]||(h[u]=[]),h[u].push(l))}for(const l in h){const d=h[l].map(m=>this.getEntityDecomposition(m,e)),u=ot.createChildrenVector(this._builder,d),p=this._builder.createSharedString(l);ot.startSpatialStructure(this._builder),ot.addCategory(this._builder,p),ot.addChildren(this._builder,u);const f=ot.endSpatialStructure(this._builder);i.push(f)}}const r=ot.createChildrenVector(this._builder,i);return ot.startSpatialStructure(this._builder),ot.addLocalId(this._builder,t),ot.addChildren(this._builder,r),ot.endSpatialStructure(this._builder)}async getSpatialStructureOffset(){const t=await this.getIfcApi(),e=Dr,s=[...t.GetLineIDsWithType(0,e)].map(a=>this.getEntityDecomposition(a,["IsDecomposedBy","ContainsElements"])),i=this._builder.createSharedString("IFCPROJECT"),r=ot.createChildrenVector(this._builder,s);return ot.startSpatialStructure(this._builder),ot.addCategory(this._builder,i),ot.addChildren(this._builder,r),ot.endSpatialStructure(this._builder)}clean(){var t;(t=this._ifcApi)==null||t.Dispose(),this._ifcApi=null,this._guids=[],this._guidsItems=[],this._attributesOffsets=[],this._relationsMap={},this._uniqueAttributes.clear(),this._uniqueRelNames.clear(),this.expressIDs=[],this.classes=[]}}function st(n,t){return Math.round(n*t)/t}class Pp{constructor(t,e,s,i){c(this,"x"),c(this,"y"),c(this,"z"),c(this,"hash"),c(this,"id"),this.x=st(t[3*e],i),this.y=st(t[3*e+1],i),this.z=st(t[3*e+2],i),this.hash=`${this.x}/${this.y}/${this.z}`,this.id=s}}class Mp{constructor(t){c(this,"list",new Map),c(this,"tempV1",new T),c(this,"tempV2",new T),c(this,"tempV3",new T),c(this,"precission"),this.precission=t}create(t,e){const s=new Pp(t,e,this.list.size,this.precission);return this.list.has(s.hash)||this.list.set(s.hash,s),this.list.get(s.hash)}get(){return Array.from(this.list.values()).map(t=>[t.x,t.y,t.z])}isValidTriangle(t,e,s,i){this.tempV1.set(t[3*e],t[3*e+1],t[3*e+2]),this.tempV2.set(t[3*s],t[3*s+1],t[3*s+2]),this.tempV3.set(t[3*i],t[3*i+1],t[3*i+2]);const r=1/this.precission*10,a=this.tempV1.distanceTo(this.tempV2)>r,o=this.tempV1.distanceTo(this.tempV3)>r,h=this.tempV2.distanceTo(this.tempV3)>r;return a&&o&&h}}class Hi{constructor(t,e){c(this,"p1"),c(this,"p2"),c(this,"hash"),this.p1=t,this.p2=e;const s=[this.p1,this.p2];s.sort((i,r)=>i.x-r.x||i.y-r.y||i.z-r.z),this.hash=`${s[0].hash}_${s[1].hash}`}}class Dp{constructor(t,e){c(this,"edges",new Map),c(this,"openEdges",new Set),c(this,"id"),c(this,"plane"),this.id=t,this.plane=e}add(t){if(this.edges.size!==0)for(const e of t)this.openEdges.has(e.hash)?this.openEdges.delete(e.hash):this.openEdges.add(e.hash),this.edges.set(e.hash,e);else for(const e of t)this.openEdges.add(e.hash),this.edges.set(e.hash,e)}match(t,e){if(e.id!==this.plane.id)return!1;for(const s of t)if(this.openEdges.has(s.hash))return!0;return!1}getOpenEdges(){const t=[];for(const e of this.openEdges)t.push(this.edges.get(e));return t}merge(t){for(const[e,s]of t.edges)this.edges.set(e,s);for(const e of t.openEdges)this.openEdges.has(e)?this.openEdges.delete(e):this.openEdges.add(e)}}class Up{constructor(){c(this,"list",new Map),c(this,"nextFaceID",0)}add(t,e){const s=this.match(t,e);if(s.length===0){const i=this.nextFaceID++,r=new Dp(i,e);return r.add(t),void this.list.set(r.id,r)}if(s.length!==1){if(s.length>1){const i=this.list.get(s[0]);i.add(t);for(let r=1;r<s.length;r++){const a=s[r],o=this.list.get(a);i.merge(o),this.list.delete(a)}}}else this.list.get(s[0]).add(t)}match(t,e){let s=[];for(const i of this.list.values())i.match(t,e)&&s.push(i.id);return s}}class Vp{constructor(t){c(this,"closed",!1),c(this,"openStartPoint",null),c(this,"openEndPoint",null),c(this,"plane"),c(this,"orderedPoints",[]),this.plane=t}getEdges(t=!1){const e=[];if(t)for(let s=this.orderedPoints.length-1;s>0;s--)e.push(new Hi(this.orderedPoints[s],this.orderedPoints[s-1]));else for(let s=0;s<this.orderedPoints.length-1;s++)e.push(new Hi(this.orderedPoints[s],this.orderedPoints[s+1]));return e}getIndices(){return this.orderedPoints.map(t=>t.id)}add(t){if(this.orderedPoints.length===0)return this.openStartPoint=t.p1.hash,this.openEndPoint=t.p2.hash,void this.orderedPoints.push(t.p1,t.p2);const e=this.match(t);if(e===0)throw new Error("Fragments: Edge doesn't match with any open point");if(e>2)throw new Error("Fragments: Edge matches with more than 2 open points");if(e===2)return this.closed=!0,this.openEndPoint=null,void(this.openStartPoint=null);this.openStartPoint===t.p1.hash?(this.orderedPoints.unshift(t.p2),this.openStartPoint=t.p2.hash):this.openEndPoint===t.p1.hash?(this.orderedPoints.push(t.p2),this.openEndPoint=t.p2.hash):this.openStartPoint===t.p2.hash?(this.orderedPoints.unshift(t.p1),this.openStartPoint=t.p1.hash):this.openEndPoint===t.p2.hash&&(this.orderedPoints.push(t.p1),this.openEndPoint=t.p1.hash)}match(t){if(this.closed)return 0;let e=0;return this.openStartPoint===t.p1.hash&&e++,this.openStartPoint===t.p2.hash&&e++,this.openEndPoint===t.p1.hash&&e++,this.openEndPoint===t.p2.hash&&e++,e}merge(t){if(t.closed||this.closed)throw new Error("Fragments: Cannot merge closed profiles");if(t.openStartPoint===this.openEndPoint&&t.openEndPoint===this.openStartPoint)throw new Error("Fragments: Cannot merge profiles that close each other");if(t.openEndPoint===this.openEndPoint&&t.openStartPoint===this.openStartPoint)throw new Error("Fragments: Cannot merge profiles that close each other");let e=!1;t.openEndPoint!==this.openStartPoint&&t.openEndPoint!==this.openEndPoint||(e=!0);const s=t.getEdges(e);for(const i of s)this.add(i)}getArea(){const t=this.orderedPoints.map(l=>[l.x,l.y,l.z]);let e=0,s=1;const i=Math.abs(this.plane.normal.x),r=Math.abs(this.plane.normal.y),a=Math.abs(this.plane.normal.z);i>=r&&i>=a?(e=1,s=2):r>=i&&r>=a?(e=0,s=2):(e=0,s=1);const o=[];for(const l of t)o.push(new He(l[e],l[s]));let h=0;for(let l=0,d=o.length;l<d;l++)h+=o[l].x*o[l===o.length-1?0:l+1].y*.5,h-=o[l===o.length-1?0:l+1].x*o[l].y*.5;return Math.abs(h)}}class Bp{constructor(t){c(this,"list",new Map),c(this,"plane"),c(this,"nextProfileID",0),this.plane=t}add(t){const e=this.match(t);if(e.length===0){const s=this.nextProfileID++,i=new Vp(this.plane);return i.add(t),void this.list.set(s,i)}if(e.length!==1){if(e.length>1){const s=this.list.get(e[0]);s.add(t);const i=this.list.get(e[1]);s.merge(i),this.list.delete(e[1])}}else this.list.get(e[0]).add(t)}getProfiles(){let t=null,e=0;for(const[r,a]of this.list){const o=a.getArea();o>e&&(e=o,t=r)}if(t===null)return null;const s=this.list.get(t).getIndices(),i=[];for(const[r,a]of this.list)r!==t&&i.push(a.getIndices());return{profile:s,holes:i}}match(t){const e=[];for(const[s,i]of this.list)i.match(t)>0&&e.push(s);return e}}function Il(n){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,r=Number.NEGATIVE_INFINITY,a=Number.NEGATIVE_INFINITY;for(let o=0;o<n.length;o+=3){const h=n[o],l=n[o+1],d=n[o+2];h<t&&(t=h),l<e&&(e=l),d<s&&(s=d),h>i&&(i=h),l>r&&(r=l),d>a&&(a=d)}return{min:{x:t,y:e,z:s},max:{x:i,y:r,z:a}}}class zp{constructor(t,e,s){c(this,"normal"),c(this,"constant"),c(this,"id"),c(this,"faces",[]);const i=st(t.normal.x,s),r=st(t.normal.y,s),a=st(t.normal.z,s),o=st(t.constant,e);this.normal=new T(i,r,a),this.constant=o;const h="||";this.id=`${i}${h}${r}${h}${a}${h}${o}`}}function Gp(n){const{position:t,normals:e,index:s,raw:i}=n,r=t.length/3>3e3,a=Il(t);if(i||r)return function(I,C,R){const E=new Map,g=new Map,w=(y,F,S)=>{const x=`${y},${F},${S}`;if(E.has(x))return E.get(x)[0];const v=E.size;return E.set(x,[v,y,F,S]),v};for(let y=0;y<I.length-2;y+=3){const F=I[y],S=I[y+1],x=I[y+2],v=C[3*F],M=C[3*F+1],V=C[3*F+2],nt=C[3*S],ft=C[3*S+1],tt=C[3*S+2],jt=C[3*x],je=C[3*x+1],Ut=C[3*x+2],mt=w(v,M,V),se=w(nt,ft,tt),qt=w(jt,je,Ut);g.set(g.size,[mt,se,qt])}const A=[];for(const[,[,y,F,S]]of E)A.push([y,F,S]);return{bbox:R,type:gs.SHELL,profiles:g,holes:new Map,points:A}}(s,t,a);const o=new Yt,h=new T,l=new T,d=new Map;for(let I=0;I<s.length-2;I+=3){const C=s[I];h.set(e[3*C],e[3*C+1],e[3*C+2]),l.set(t[3*C],t[3*C+1],t[3*C+2]),o.setFromNormalAndCoplanarPoint(h,l);const R=new zp(o,1e3,1e7);d.has(R.id)||d.set(R.id,R),d.get(R.id).faces.push(I)}const u=new Mp(1e6),p=new Up;for(const[,I]of d)for(const C of I.faces){const R=s[C],E=s[C+1],g=s[C+2];if(!u.isValidTriangle(t,R,E,g))continue;const w=u.create(t,R),A=u.create(t,E),y=u.create(t,g),F=[new Hi(w,A),new Hi(A,y),new Hi(y,w)];p.add(F,I)}const f=new Map,m=new Map;let b=0;for(const[,I]of p.list){const C=new Bp(I.plane),R=I.getOpenEdges();for(const g of R)C.add(g);const E=C.getProfiles();f.set(b,(E==null?void 0:E.profile)||[]),m.set(b,(E==null?void 0:E.holes)||[]),b++}return{bbox:a,type:gs.SHELL,profiles:f,holes:m,points:u.get()}}class kp{read(t){try{const e=t.GetAllAlignments(0),s=[];for(const i of e){const r={absolute:[],horizontal:[],vertical:[]};s.push(r);let a=0;for(let o=0;o<i.horizontal.length;o++){const h=i.curve3D[0].points,l=i.horizontal[o],d=[],u=[],p=this.getCurveType(l.data[1]),f=[],m=[];for(const C of l.points){const{x:R,y:E,z:g}=h[a++];f.push([R,E,g]),m.push([C.x,C.y])}f.reverse(),m.reverse();for(const[C,R,E]of f)d.push(C,R,E);for(const[C,R]of m)u.push(C,0,-R);const b=new Float32Array(d),I=new Float32Array(u);r.absolute.push({points:b,type:p}),r.horizontal.push({points:I,type:p})}for(let o=0;o<i.vertical.length;o++){const h=i.vertical[o],l=[],d=this.getCurveType(h.data[1]),u=[];for(const f of h.points)u.push([f.x,f.y]);u.reverse();for(const[f,m]of u)l.push(f,m,0);const p=new Float32Array(l);r.vertical.push({points:p,type:d})}}return s}catch(e){return console.error(e),[]}}getCurveType(t){if(t.includes("CIRCULARARC"))return ke.ELLIPSE_ARC;if(t.includes("LINE")||t.includes("GRADIENT"))return ke.LINES;if(t.includes("CLOTHOID"))return ke.CLOTHOID;if(t.includes("PARABOLICARC"))return ke.PARABOLA;throw new Error(`Fragments: Unknown curve type: ${t}`)}}class Yp{constructor(t){c(this,"_ifcAPI",null),c(this,"wasm",{path:"../../../../node_modules/web-ifc/",absolute:!1}),c(this,"_tempObject1",new Mr),c(this,"_tempObject2",new Mr),c(this,"_tempMatrix1",new rt),c(this,"_previousGeometries",new Map),c(this,"_previousGeometriesIDs",new Map),c(this,"_previousGeometriesScales",new Map),c(this,"_previousLocalTransforms",new Map),c(this,"_problematicGeometries",new Set),c(this,"_problematicGeometriesHashes",new Set),c(this,"_coordinatesInitialized",!1),c(this,"_civilReader",new kp),c(this,"_maxId",0),c(this,"_rawCategories",new Set([Io,bo])),c(this,"distanceThreshold",1e5),c(this,"scene",null),c(this,"isolatedMeshes",null),c(this,"onElementLoaded",()=>{}),c(this,"onGeometryLoaded",()=>{}),c(this,"onLocalTransformLoaded",()=>{}),c(this,"onMaxIdFound",()=>{}),c(this,"onCoordinatesLoaded",()=>{}),c(this,"onAlignmentsLoaded",()=>{}),this._serializer=t}async load(t){var e,s,i;(e=t.progressCallback)==null||e.call(t,0,{process:"conversion",state:"start"}),this._previousGeometriesIDs.clear(),this._ifcAPI=new Vr,this._ifcAPI.SetWasmPath(this.wasm.path,this.wasm.absolute),await this._ifcAPI.Init();let r=0;if(t.readFromCallback&&t.readCallback)r=this._ifcAPI.OpenModelFromCallback(t.readCallback,{COORDINATE_TO_ORIGIN:!0});else{if(!t.bytes)throw new Error("Fragments: No data provided");r=await this._ifcAPI.OpenModel(t.bytes,{COORDINATE_TO_ORIGIN:!0})}this._ifcAPI.SetLogLevel(_o.LOG_LEVEL_OFF),this._maxId=this._ifcAPI.GetMaxExpressID(r),this.onLocalTransformLoaded({id:0,data:[0,0,0,1,0,0,0,1,0]});const a=new T,o=l=>{if(this._ifcAPI===null)throw new Error("Fragments: IfcAPI not initialized");if(!this._coordinatesInitialized){const F=this._ifcAPI.GetCoordinationMatrix(r);this._tempMatrix1.fromArray(F);const S=this.decompose(this._tempMatrix1);this.onCoordinatesLoaded(S),this._coordinatesInitialized=!0}const d=this._ifcAPI.GetLine(0,l.expressID),u={id:l.expressID,type:d.type,guid:d.GlobalId.value,geometries:[]},p=l.geometries.size(),f=l.geometries.get(0).flatTransformation,{transformWithoutScale:m}=this.removeScale(f);if(a.set(0,0,0),a.applyMatrix4(m),a.x>this.distanceThreshold||a.y>this.distanceThreshold||a.z>this.distanceThreshold)return void console.log(`Object ${u.id} is more than ${this.distanceThreshold} meters away from the origin and will be skipped.`);for(let F=0;F<p;F++)u.type===po?this.loadCircleExtrusionGeometry(r,u,l,F,m.elements):this.loadShellGeometry(r,u,l,F,m.elements);const{dxx:b,dxy:I,dxz:C,dyx:R,dyy:E,dyz:g,px:w,py:A,pz:y}=this.decompose(m);u.geometries.length>0&&this.onElementLoaded({element:u,position:[w,A,y],xDirection:[b,I,C],yDirection:[R,E,g]})};if((s=this.isolatedMeshes)!=null&&s.size)this._ifcAPI.StreamMeshes(r,Array.from(this.isolatedMeshes),o);else{const l=this._ifcAPI.GetAllTypesOfModel(r).map(u=>u.typeID).filter(u=>this._serializer.classes.elements.has(u)),d=.5/l.length;for(const[u,p]of l.entries()){const f=u===0?"start":u+1===l.length?"finish":"inProgress",m=this._ifcAPI.GetLineIDsWithType(r,p),b=[];for(let I=0;I<m.size();I++)b.push(m.get(I));b.length>0&&(this._ifcAPI.StreamMeshes(r,b,o),(i=t.progressCallback)==null||i.call(t,d*(u+1),{process:"geometries",state:f,class:Ni[p],entitiesProcessed:b.length}))}}const h=this._civilReader.read(this._ifcAPI);this.onAlignmentsLoaded(h),this.onMaxIdFound(this._maxId),this._ifcAPI.Dispose(),this._ifcAPI=null,this._ifcAPI=new Vr,this._ifcAPI.SetWasmPath(this.wasm.path,this.wasm.absolute),await this._ifcAPI.Init(),this._previousGeometries.clear(),this._previousGeometriesIDs.clear(),this._previousGeometriesScales.clear(),this._maxId=0,this._previousLocalTransforms.clear(),this._problematicGeometries.clear(),this._problematicGeometriesHashes.clear()}loadCircleExtrusionGeometry(t,e,s,i,r){if(this._ifcAPI===null)throw new Error("Fragments: IfcAPI not initialized");const a=s.geometries.get(i),o=a.flatTransformation,{units:h}=this.removeScale(o),{x:l,y:d,z:u,w:p}=a.color,f={id:a.geometryExpressID,color:[l,d,u,p],localTransformID:null};e.geometries.push(f);const{transformWithoutScale:m}=this.removeScale(a.flatTransformation);if(this._previousGeometriesIDs.has(f.id))return this.getLocalTransform(r,m,f),void(f.id=this._previousGeometriesIDs.get(f.id));this.getLocalTransform(r,m,f);const b=this._ifcAPI.GetGeometry(t,f.id),I=b.GetSweptDiskSolid(),C=[],R=[],E=I.axis.size();for(let M=0;M<E;M++){const V=I.axis.get(M),nt=[];for(let tt=0;tt<V.arcSegments.size();tt++)nt.push(V.arcSegments.get(tt));C.push(nt);const ft=[];for(let tt=0;tt<V.points.size();tt++){const jt=V.points.get(tt);ft.push({x:jt.x*h.x,y:jt.y*h.y,z:jt.z*h.z})}R.push(ft)}const g=[],w=[],A=[],y=[];for(let M=0;M<R.length;M++){const V=R[M],nt=C[M],ft=V.length;for(let tt=0;tt<ft-1;tt++){let jt=-1,je=-1;for(let Ut=0;Ut<nt.length;Ut+=2)if(nt[Ut]===tt){jt=tt,je=nt[Ut+1];break}if(jt===-1){const Ut=[],mt=V[tt],se=V[tt+1],qt=mt.x,Ce=mt.y,Z=mt.z,de=se.x,ct=se.y,Zt=se.z;g.push(A.length),Ut.push(qt,Ce,Z,de,ct,Zt),A.push(Ut),w.push(bt.WIRE)}else{const Ut=[],mt=jt,se=Math.round((jt+je)/2),qt=je,Ce=V[mt],Z=V[se],de=V[qt],ct=this.computeCircleCurveProperties(Ce,Z,de),Zt=Ce.x-ct.center.x,qe=Ce.y-ct.center.y,Ze=Ce.z-ct.center.z;let Vt=Math.sqrt(Zt*Zt+qe*qe+Ze*Ze);Vt===0&&(Vt=1);const ln=Zt/Vt,hn=qe/Vt,cn=Ze/Vt,li=Z.x-ct.center.x,hi=Z.y-ct.center.y,ci=Z.z-ct.center.z;let Rs=Math.sqrt(li*li+hi*hi+ci*ci);Rs===0&&(Rs=1);const or=li/Rs,lr=hi/Rs,dn=ci/Rs;let Bt=this.crossProduct({x:ln,y:hn,z:cn},{x:or,y:lr,z:dn});Vt=Math.sqrt(Bt.x*Bt.x+Bt.y*Bt.y+Bt.z*Bt.z),Vt===0&&(Vt=1),Bt={x:Bt.x/Vt,y:Bt.y/Vt,z:Bt.z/Vt},g.push(y.length),Ut.push(ct.center.x,ct.center.y,ct.center.z,ct.radius,ct.angle,ln,hn,cn,Bt.x,Bt.y,Bt.z),y.push(Ut),w.push(bt.CIRCLE_CURVE),tt=qt-1}}}const F=this.getGeometryBuffers(t,a);if(F===null)return console.log(`Zero length geometry: ${f.id}`),e.geometries.pop(),void this._problematicGeometries.add(f.id);const{position:S}=F;for(let M=0;M<S.length-2;M+=3)S[M]*=h.x,S[M+1]*=h.y,S[M+2]*=h.z;const x=Il(S),v=I.profileRadius*h.x;this._previousGeometriesIDs.set(f.id,f.id),this.onGeometryLoaded({id:f.id,geometry:{type:gs.CIRCLE_EXTRUSION,indicesArray:g,typesArray:w,segments:A,circleCurveData:y,radius:v,bbox:x}}),b.delete()}loadShellGeometry(t,e,s,i,r){if(this._ifcAPI===null)throw new Error("Fragments: IfcAPI not initialized");const a=s.geometries.get(i),o=a.flatTransformation,{units:h}=this.removeScale(o);if(this._problematicGeometries.has(a.geometryExpressID))return void console.log(` Problematic geometry: ${a.geometryExpressID}`);const{x:l,y:d,z:u,w:p}=a.color,f={id:a.geometryExpressID,color:[l,d,u,p],localTransformID:null};e.geometries.push(f);const{transformWithoutScale:m}=this.removeScale(a.flatTransformation);if(this._previousGeometriesIDs.has(f.id)){const Z=this.getScaleHash(h);if(this._previousGeometriesScales.get(f.id)===Z)return this.getLocalTransform(r,m,f),void(f.id=this._previousGeometriesIDs.get(f.id));const de=++this._maxId;this._previousGeometriesScales.set(de,Z),f.id=de}const b=this.getGeometryBuffers(t,a);if(b===null)return console.log(`Zero length geometry: ${f.id}`),e.geometries.pop(),void this._problematicGeometries.add(f.id);const{position:I,normals:C,index:R}=b;for(let Z=0;Z<I.length-2;Z+=3)I[Z]*=h.x,I[Z+1]*=h.y,I[Z+2]*=h.z;const E=I.length/3,g=R.length/3;let w=0,A=0;const y=new ji,F=new T,S=new T,x=new T,v=this.getVolume(R,I),M=new T;for(let Z=0;Z<R.length-2;Z+=3){const de=R[Z],ct=R[Z+1],Zt=R[Z+2];F.set(I[3*de],I[3*de+1],I[3*de+2]),S.set(I[3*ct],I[3*ct+1],I[3*ct+2]),x.set(I[3*Zt],I[3*Zt+1],I[3*Zt+2]),M.add(F),M.add(S),M.add(x),y.set(F,S,x);const qe=y.getArea();qe>w&&(w=qe),A+=qe}M.divideScalar(R.length),F.set(I[0],I[1],I[2]),S.set(I[3],I[4],I[5]),x.set(I[6],I[7],I[8]);const V=1e4,nt=st(A,V),ft=st(w,V),tt=st(v,V),jt=st(F.x,V),je=st(F.y,V),Ut=st(F.z,V),mt=`${E}-${g}-${nt}-${ft}-${tt}-${st(M.x,V)}-${st(M.x,V)}-${st(M.x,V)}-${jt}-${je}-${Ut}`;if(this._problematicGeometriesHashes.has(mt))return console.log(`Problematic geometry: ${f.id}`),e.geometries.pop(),this._problematicGeometries.add(f.id),void this._problematicGeometriesHashes.add(mt);const se=!this._previousGeometries.has(mt),qt=f.id;if(se)this._previousGeometries.set(mt,qt),this._previousGeometriesIDs.set(qt,qt);else{const Z=this._previousGeometries.get(mt);if(Z===void 0)throw new Error("Fragments: Previous geometry not found");this._previousGeometriesIDs.set(qt,Z),f.id=Z}this.getLocalTransform(r,m,f);const Ce=this._rawCategories.has(e.type);if(se)try{const Z=Gp({position:I,normals:C,index:R,raw:Ce});this.onGeometryLoaded({id:f.id,geometry:Z})}catch{console.error(`Fragments: Problematic geometry: ${f.id}`),e.geometries.pop(),this._problematicGeometries.add(f.id),this._problematicGeometriesHashes.add(mt)}}getScaleHash(t){return`${t.x}-${t.y}-${t.z}`}getLocalTransform(t,e,s){this._tempObject1.position.set(0,0,0),this._tempObject1.rotation.set(0,0,0),this._tempObject1.scale.set(1,1,1),this._tempObject1.updateMatrix(),this._tempMatrix1.fromArray(t),this._tempObject1.applyMatrix4(this._tempMatrix1),this._tempObject2.position.set(0,0,0),this._tempObject2.rotation.set(0,0,0),this._tempObject2.scale.set(1,1,1),this._tempObject2.updateMatrix(),this._tempObject2.applyMatrix4(e),this._tempObject1.attach(this._tempObject2);const{px:i,py:r,pz:a,dxx:o,dxy:h,dxz:l,dyx:d,dyy:u,dyz:p}=this.decompose(this._tempObject2.matrix);if(this._tempObject2.removeFromParent(),!(i===0&&r===0&&a===0&&o===1&&h===0&&l===0&&d===0&&u===1&&p===0)){const f=`${i}-${r}-${a}-${o}-${h}-${l}-${d}-${u}-${p}`,m=this._previousLocalTransforms.get(f);if(m)s.localTransformID=m.id;else{const b={id:this._previousLocalTransforms.size+1,data:[i,r,a,o,h,l,d,u,p]};this._previousLocalTransforms.set(f,b),s.localTransformID=b.id,this.onLocalTransformLoaded(b)}}}removeScale(t){const e=new rt().fromArray(t),s=new T,i=new Co,r=new T;e.decompose(s,i,r);const a=r,o=new rt;return o.compose(s,i,new T(1,1,1)),{units:a,transformWithoutScale:o}}decompose(t){return{dxx:st(t.elements[0],1e3),dxy:st(t.elements[1],1e3),dxz:st(t.elements[2],1e3),dyx:st(t.elements[4],1e5),dyy:st(t.elements[5],1e5),dyz:st(t.elements[6],1e5),dzx:st(t.elements[8],1e5),dzy:st(t.elements[9],1e5),dzz:st(t.elements[10],1e5),px:st(t.elements[12],1e5),py:st(t.elements[13],1e5),pz:st(t.elements[14],1e5)}}getVolume(t,e){let s=0;const i=new T,r=new T,a=new T;for(let o=0;o<t.length-2;o+=3){const h=3*t[o],l=3*t[o+1],d=3*t[o+2];i.set(e[h],e[h+1],e[h+2]),r.set(e[l],e[l+1],e[l+2]),a.set(e[d],e[d+1],e[d+2]),s+=this.getSignedVolumeOfTriangle(i,r,a)}return Math.abs(s)}getSignedVolumeOfTriangle(t,e,s){return 1/6*(-(s.x*e.y*t.z)+e.x*s.y*t.z+s.x*t.y*e.z-t.x*s.y*e.z-e.x*t.y*s.z+t.x*e.y*s.z)}getGeometryBuffers(t,e){if(!this._ifcAPI)throw new Error("Fragments: IfcAPI not initialized");const s=this._ifcAPI.GetGeometry(t,e.geometryExpressID),i=this._ifcAPI.GetIndexArray(s.GetIndexData(),s.GetIndexDataSize()),r=this._ifcAPI.GetVertexArray(s.GetVertexData(),s.GetVertexDataSize());if(i.length===0||r.length===0)return s.delete(),null;const a=new Float32Array(r.length/2),o=new Float32Array(r.length/2);for(let h=0;h<r.length;h+=6)a[h/2]=r[h],a[h/2+1]=r[h+1],a[h/2+2]=r[h+2],o[h/2]=r[h+3],o[h/2+1]=r[h+4],o[h/2+2]=r[h+5];return s.delete(),{position:a,normals:o,index:i}}crossProduct(t,e){return{x:t.y*e.z-t.z*e.y,y:t.z*e.x-t.x*e.z,z:t.x*e.y-t.y*e.x}}computeCircleCurveProperties(t,e,s){function i(b,I){return{x:b.x-I.x,y:b.y-I.y,z:b.z-I.z}}function r(b){return Math.sqrt(b.x*b.x+b.y*b.y+b.z*b.z)}const a=i(e,t),o=i(s,e),h=this.crossProduct(a,o),l=function(b,I,C){const R=I.x-b.x,E=I.y-b.y,g=I.z-b.z,w=C.x-b.x,A=C.y-b.y,y=C.z-b.z,F=.5*(R**2+E**2+g**2),S=.5*(w**2+A**2+y**2),x=R*A-E*w,v=E*y-g*A,M=g*w-R*y,V=F*w-S*R,nt=F*A-S*E,ft=F*y-S*g,tt=x**2+v**2+M**2;if(tt===0)throw new Error("Fragments: Points are collinear, no unique circle exists.");return{x:b.x+(x*nt-M*ft)/tt,y:b.y+(v*ft-x*V)/tt,z:b.z+(M*V-v*nt)/tt}}(t,e,s),d=i(t,l),u=i(s,l),p=r(i(l,t)),f=i(t,l),m=r(f);return f.x/=m,f.y/=m,f.z/=m,{center:l,radius:p,normal:h,initialTangent:f,angle:180*Math.acos((d.x*u.x+d.y*u.y+d.z*u.z)/(r(d)*r(u)))/Math.PI}}}class Hp{constructor(t){c(this,"wasm",{path:"../../../../node_modules/web-ifc/",absolute:!1}),this._serializer=t}async process(t){const{builder:e}=t;let s=0;const i=[];let r={dxx:1,dxy:0,dxz:0,dyx:0,dyy:1,dyz:0,px:0,py:0,pz:0};const a=[],o=[],h=[],l=[],d=new Map,u=new Map,p=new Map,f=new Yp(this._serializer);f.wasm=this.wasm,f.onGeometryLoaded=L=>{a.push(L)},f.onElementLoaded=L=>{h.push(L)},f.onLocalTransformLoaded=L=>{l.push(L)},f.onCoordinatesLoaded=L=>{r=L},f.onMaxIdFound=L=>{s=L},f.onAlignmentsLoaded=L=>{for(const k of L)o.push(k)},await f.load(t);const m=[];let b=0;$.startGlobalTransformsVector(e,h.length);const I=new Map,C=[];for(let L=0;L<h.length;L++){const k=h[h.length-1-L];m.push(b++);const{position:U,xDirection:P,yDirection:H}=k,[et,W,Ct]=U,[zt,Xt,$t]=P,[Vs,Bs,di]=H;i.push(h[L].element.id);const ui=h.length-1-L,fi=k.element.type,As=Ni[fi];I.has(As)||I.set(As,I.size),rs.createTransform(e,et,W,Ct,zt,Xt,$t,Vs,Bs,di),I.get(As),C.unshift(k.element.id),d.set(k.element.id,ui)}const R=e.endVector(),E=[];for(let L=0;L<a.length;L++){const k=a[L];if(k.geometry.type!==gs.SHELL)continue;const{points:U,profiles:P,holes:H}=k.geometry,et=65e3,W=U.length>et,Ct=W?Dt.BIG:Dt.NONE;It.startPointsVector(e,U.length);for(let ie=0;ie<U.length;ie++){const[ye,ge,Te]=U[U.length-1-ie];xt.createFloatVector(e,ye,ge,Te)}const zt=e.endVector(),Xt=[],$t=[],Vs=[],Bs=[];for(const[,ie]of P){if(W){const Te=he.createIndicesVector(e,ie),$e=he.createBigShellProfile(e,Te);Vs.push($e);continue}const ye=ce.createIndicesVector(e,ie),ge=ce.createShellProfile(e,ye);Xt.push(ge)}const di=It.createBigProfilesVector(e,Vs),ui=It.createProfilesVector(e,Xt);for(const[ie,ye]of H)if(W)for(const ge of ye){const Te=ae.createIndicesVector(e,ge),$e=ae.createBigShellHole(e,Te,ie);Bs.push($e)}else for(const ge of ye){const Te=oe.createIndicesVector(e,ge),$e=oe.createShellHole(e,Te,ie);$t.push($e)}const fi=It.createBigHolesVector(e,Bs),As=It.createHolesVector(e,$t),Xe=It.createShell(e,ui,As,zt,di,fi,Ct);E.push(Xe)}const g=$.createShellsVector(e,E),w=[];for(let L=0;L<a.length;L++){const k=a[L];if(k.geometry.type!==gs.CIRCLE_EXTRUSION)continue;const U=[],{radius:P,indicesArray:H,typesArray:et,segments:W,circleCurveData:Ct}=k.geometry;it.startCircleCurvesVector(e,Ct.length);for(let Xe=0;Xe<Ct.length;Xe++){const[ie,ye,ge,Te,$e,hr,El,ml,Cl,gl,Tl]=Ct[Xe];sr.createCircleCurve(e,$e/360*2*Math.PI,ie,ye,ge,Te,Cl,gl,Tl,hr,El,ml)}const zt=e.endVector();it.startWiresVector(e,W.length);for(let Xe=0;Xe<W.length;Xe++){const[ie,ye,ge,Te,$e,hr]=W[Xe];ua.createWire(e,ie,ye,ge,Te,$e,hr)}const Xt=e.endVector(),$t=it.createOrderVector(e,H),Vs=it.createPartsVector(e,et);it.startWireSetsVector(e,0);const Bs=e.endVector();it.startAxis(e),it.addCircleCurves(e,zt),it.addOrder(e,$t),it.addWires(e,Xt),it.addWireSets(e,Bs),it.addParts(e,Vs);const di=it.endAxis(e);U.push(di);const ui=yt.createAxesVector(e,U),fi=yt.createRadiusVector(e,[P]);yt.startCircleExtrusion(e),yt.addAxes(e,ui),yt.addRadius(e,fi);const As=yt.endCircleExtrusion(e);w.push(As)}const A=$.createCircleExtrusionsVector(e,w);$.startRepresentationsVector(e,a.length);const y=new Map;for(let L=0;L<a.length;L++){const k=a.length-1-L,U=a[k].geometry.type;let P=y.get(U);P===void 0&&(P=-1),y.set(U,P+1)}const F=new T,S=new T;for(let L=0;L<a.length;L++){const k=a.length-1-L,U=a[k],{bbox:P}=U.geometry;u.set(U.id,k);const H=U.geometry.type,et=y.get(H);if(et===void 0)throw new Error("Fragments: Malformed geometry definition");y.set(H,et-1),F.set(P.min.x,P.min.y,P.min.z),S.set(P.max.x,P.max.y,P.max.z),F.distanceTo(S)>999999&&(console.log(`Infinity bounding box: ${U.id}`),P.min.x=0,P.min.y=0,P.min.z=0,P.max.x=.1,P.max.y=.1,P.max.z=.1),ir.createRepresentation(e,et,P.min.x,P.min.y,P.min.z,P.max.x,P.max.y,P.max.z,U.geometry.type)}const x=e.endVector();let v=0;for(const L of h)for(const k of L.element.geometries){const U=k.color.toString();if(!p.has(U)){const P=k.color.map(H=>255*H);p.set(U,{id:v++,color:P})}}$.startMaterialsVector(e,p.size);const M=Array.from(p.keys());for(let L=0;L<M.length;L++){const k=M[M.length-1-L],{color:U}=p.get(k),[P,H,et,W]=U;yo.createMaterial(e,P,H,et,W,xo.ONE,0)}const V=e.endVector();let nt=0;for(const L of h)nt+=L.element.geometries.length;$.startSamplesVector(e,nt);for(let L=0;L<h.length;L++){const k=h[h.length-1-L],U=d.get(k.element.id),P=k.element.geometries;for(let H=0;H<P.length;H++){const et=P[P.length-H-1],W=u.get(et.id),Ct=p.get(et.color.toString()).id,zt=et.localTransformID||0;nr.createSample(e,U,Ct,W,zt)}}const ft=e.endVector();$.startLocalTransformsVector(e,l.length);for(let L=0;L<l.length;L++){const k=l[l.length-1-L],[U,P,H,et,W,Ct,zt,Xt,$t]=k.data;rs.createTransform(e,U,P,H,et,W,Ct,zt,Xt,$t)}const tt=e.endVector(),jt=$.createMeshesItemsVector(e,m),je=rs.createTransform(e,r.px,r.py,r.pz,r.dxx,r.dxy,r.dxz,r.dyx,r.dyy,r.dyz);$.startMeshes(e),$.addCoordinates(e,je),$.addGlobalTransforms(e,R),$.addShells(e,g),$.addRepresentations(e,x),$.addSamples(e,ft),$.addLocalTransforms(e,tt),$.addMaterials(e,V),$.addCircleExtrusions(e,A),$.addMeshesItems(e,jt);const Ut=$.endMeshes(e),mt=[],se=new Map,qt=new Map,Ce=new Map;let Z=0;for(let L=0;L<o.length;L++){const k=L,U=o[k],P=[];se.set(k,P);const H=[];qt.set(k,H);const et=[];Ce.set(k,et);for(let W=0;W<U.absolute.length;W++){const Ct=U.absolute[U.absolute.length-1-W],{points:zt}=Ct,Xt=Rt.createPointsVector(e,zt);Rt.startGeometryLines(e),Rt.addPoints(e,Xt);const $t=Rt.endGeometryLines(e);mt.push($t),P.push(Z++)}for(let W=0;W<U.horizontal.length;W++){const Ct=U.horizontal[U.horizontal.length-1-W],{points:zt}=Ct,Xt=Rt.createPointsVector(e,zt);Rt.startGeometryLines(e),Rt.addPoints(e,Xt);const $t=Rt.endGeometryLines(e);mt.push($t),H.push(Z++)}for(let W=0;W<U.vertical.length;W++){const Ct=U.vertical[U.vertical.length-1-W],{points:zt}=Ct,Xt=Rt.createPointsVector(e,zt);Rt.startGeometryLines(e),Rt.addPoints(e,Xt);const $t=Rt.endGeometryLines(e);mt.push($t),et.push(Z++)}}const de=q.createLinesVector(e,mt);let ct=Z;q.startRepresentationsVector(e,ct);const Zt=[];ct--;for(let L=0;L<o.length;L++){const k=o.length-1-L,U=o[k];for(let P=0;P<U.absolute.length;P++){const H=U.absolute[U.absolute.length-1-P],{type:et}=H;Zt.unshift(s++);const W=ct--;Pn.createGeometryRepresentation(e,W,et)}for(let P=0;P<U.horizontal.length;P++){const H=U.horizontal[U.horizontal.length-1-P],{type:et}=H;Zt.unshift(s++);const W=ct--;Pn.createGeometryRepresentation(e,W,et)}for(let P=0;P<U.vertical.length;P++){const H=U.vertical[U.vertical.length-1-P],{type:et}=H;Zt.unshift(s++);const W=ct--;Pn.createGeometryRepresentation(e,W,et)}}const qe=e.endVector();let Ze=Z;const Vt=[];q.startSamplesVector(e,Ze),Ze--;for(let L=0;L<o.length;L++){const k=o.length-1-L,U=o[k];for(let P=0;P<U.absolute.length;P++){const H=Ze--;Vt.unshift(s++),Mn.createGeometrySample(e,H,0)}for(let P=0;P<U.horizontal.length;P++){const H=Ze--;Vt.unshift(s++),Mn.createGeometrySample(e,H,0)}for(let P=0;P<U.vertical.length;P++){const H=Ze--;Vt.unshift(s++),Mn.createGeometrySample(e,H,0)}}const ln=e.endVector();q.startTransformsVector(e,1),rs.createTransform(e,0,0,0,1,0,0,0,1,0);const hn=e.endVector(),cn=[s++];q.startWallsVector(e,0);const li=e.endVector();q.startRepresentationsSamplesVector(e,0);const hi=e.endVector(),ci=q.createRepresentationIdsVector(e,Zt),Rs=q.createSampleIdsVector(e,Vt),or=q.createRepresentationsSamplesVector(e,cn);q.startGeometries(e),q.addSamples(e,ln),q.addSampleIds(e,Rs),q.addRepresentations(e,qe),q.addRepresentationIds(e,ci),q.addTransforms(e,hn),q.addTransformIds(e,or),q.addRepresentationsSamples(e,hi),q.addLines(e,de),q.addWalls(e,li);const lr=q.endGeometries(e),dn=[];for(let L=0;L<o.length;L++){const k=se.get(L),U=qt.get(L),P=Ce.get(L);if(k===void 0||U===void 0||P===void 0)throw new Error("Fragments: Malformed alignment definition");const H=re.createAbsoluteVector(e,k),et=re.createHorizontalVector(e,U),W=re.createVerticalVector(e,P),Ct=re.createAlignment(e,H,et,W);dn.push(Ct)}const Bt=K.createAlignmentsVector(e,dn);return{modelMesh:Ut,localIDs:i,maxLocalID:s,modelGeometries:lr,modelAlignments:Bt}}}const On={base:new Set([Dr,Ea,ma,Ur]),materials:new Set([Ed,md,Cd,gd,Td,Rd,Ad,wd,Fd,Sd]),properties:new Set([ld,hd,cd,dd,ud,fd,pd,bd,Id,_d]),elements:new Set([Dr,Ea,ma,Ur,Nl,Pl,Ml,Dl,Ul,Vl,Bl,zl,Gl,kl,Yl,Hl,Wl,jl,ql,Zl,Xl,$l,Ql,Kl,Jl,th,eh,sh,ih,nh,rh,ah,oh,lh,hh,ch,dh,uh,fh,po,ph,bh,Ih,_h,Eh,mh,Ch,gh,Th,Rh,Ah,wh,Fh,Sh,yh,xh,Oh,vh,Lh,Nh,Ph,Mh,Dh,Uh,Vh,Bh,zh,Gh,kh,Yh,Hh,Wh,jh,qh,Zh,Xh,$h,Qh,Kh,Jh,tc,ec,sc,ic,nc,rc,ac,oc,lc,hc,cc,dc,uc,fc,pc,bc,Ic,_c,Ec,mc,Cc,gc,Tc,Rc,Ac,wc,Fc,Sc,yc,xc,Oc,vc,Lc,Nc,Pc,Mc,Dc,Uc,Vc,Bc,zc,Gc,kc,Yc,Hc,Wc,jc,qc,Zc,Xc,$c,Qc,Kc,Jc,td,ed,sd,id,bo,Io,nd,rd,ad,od])};class Wp{constructor(){c(this,"_builder",null),c(this,"wasm",{path:"/node_modules/web-ifc/",absolute:!1}),c(this,"attributesToExclude",new Set(["Representation","ObjectPlacement","CompositionType","OwnerHistory"])),c(this,"relations",new Map([[wl,{forRelating:"DefinesOcurrence",forRelated:"IsDefinedBy"}],[Fl,{forRelated:"HasAssociations",forRelating:"AssociatedTo"}],[Sl,{forRelated:"Decomposes",forRelating:"IsDecomposedBy"}],[yl,{forRelated:"ContainedInStructure",forRelating:"ContainsElements"}]])),c(this,"classes",{elements:new Fa([...On.elements]),abstract:new Fa([...On.base,...On.materials,...On.properties])}),c(this,"includeUniqueAttributes",!1),c(this,"includeRelationNames",!1),c(this,"replaceStoreyElevation",!0)}get builder(){if(!this._builder)throw new Error("Fragments: Builder not initialized");return this._builder}async process(t){var e;this._builder=new da(1024);const s=new Hp(this);s.wasm=this.wasm;const i={...t,builder:this.builder},r=await s.process(i),{modelMesh:a,maxLocalID:o,localIDs:h,modelGeometries:l,modelAlignments:d}=r,u=new Np(this,this.builder);u.wasm=this.wasm;const p={...t,geometryProcessedLocalIDs:h},f=await u.process(p),{relIndicesVector:m,relsVector:b,guidsVector:I,guidsItemsVector:C,metadataOffset:R,localIdsVector:E,spatialStrutureOffset:g,attributesVector:w,categoriesVector:A,uniqueAttributesVector:y,relNamesVector:F}=f,S=t.id??fo.generateUUID(),x=this.builder.createString(S);K.startModel(this.builder),K.addMeshes(this.builder,a),K.addMetadata(this.builder,R),K.addAttributes(this.builder,w),K.addUniqueAttributes(this.builder,y),K.addRelationNames(this.builder,F),K.addLocalIds(this.builder,E),K.addCategories(this.builder,A),K.addRelationsItems(this.builder,m),K.addRelations(this.builder,b),K.addGuidsItems(this.builder,C),K.addGuids(this.builder,I),K.addSpatialStructure(this.builder,g),K.addGuid(this.builder,x),K.addMaxLocalId(this.builder,o),K.addGeometries(this.builder,l),K.addAlignments(this.builder,d);const v=K.endModel(this.builder);this.builder.finish(v);const M=this.builder.asUint8Array();this.clean();const V=t.raw?M:Yf.deflate(M);return(e=t.progressCallback)==null||e.call(t,1,{process:"conversion",state:"finish"}),V}clean(){var t;(t=this._builder)==null||t.clear(),this._builder=null}}const on=new vd,jp=on.get(Ld),qp=document.getElementById("viewer"),os=jp.create();os.scene=new Nd(on);os.renderer=new Pd(on,qp);os.camera=new Md(on);on.init();os.scene.setup();const oi=new Dd;oi.showPanel(2);document.body.append(oi.dom);oi.dom.style.left="0px";oi.dom.style.zIndex="unset";os.renderer.onBeforeUpdate.add(()=>oi.begin());os.renderer.onAfterUpdate.add(()=>oi.end());const Zp="../../../../FragmentsModels/src/multithreading/fragments-thread.ts",ra=new Lp(Zp);os.camera.controls.addEventListener("control",()=>ra.update());Ud.init();const er=document.getElementById("json-viewer"),Xp=document.getElementById("expand-btn");Xp.addEventListener("click",()=>{er.expanded=!0});const $p=document.getElementById("collapse-btn");$p.addEventListener("click",()=>{er.expanded=!1});const Qp=document.getElementById("load-file-btn"),Kp=document.getElementById("load-wall-btn"),Jp=document.getElementById("download-btn");let Ks=null,Lr=null;async function _l(n,t){Ks&&Ks.dispose();const s=await(await fetch(n)).arrayBuffer(),i=new Uint8Array(s),a=await new Wp().process({bytes:i,raw:!0});Ks=await ra.load(a,{modelId:performance.now().toString(),camera:os.camera.three,raw:!0}),os.scene.three.add(Ks.object),await ra.update(!0);const o=new Vd(a),h=K.getRootAsModel(o);Lr={},kr(h,Lr),er.data={},er.data=Lr,window.dispatchEvent(new Event("resize"))}Qp.addEventListener("click",()=>{const n=document.createElement("input");n.type="file",n.accept=".ifc",n.onchange=t=>{var s;const e=(s=t.target.files)==null?void 0:s[0];if(e){const i=URL.createObjectURL(e);_l(i),URL.revokeObjectURL(i)}},n.click()});Kp.addEventListener("click",()=>{_l("/resources/ifc/just_wall.ifc")});Jp.addEventListener("click",async()=>{if(!Ks)return;const n=await Ks.getBuffer(!0),t=document.createElement("a"),e=new File([n],"small_test.frag"),s=URL.createObjectURL(e);t.href=s,t.download=e.name,t.click(),URL.revokeObjectURL(s)});
