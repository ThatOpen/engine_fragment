var le=Object.defineProperty;var ce=(g,t,e)=>t in g?le(g,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):g[t]=e;var a=(g,t,e)=>(ce(g,typeof t!="symbol"?t+"":t,e),e);import{V as y,cN as rt,j as K,d9 as Y,s as bt,o as et,da as W,T as $t,db as ct,dc as Ot,dd as Yt,d3 as Ut,de as Tt,df as st,dg as de,dh as vt,di as Xt,dj as pt,dk as Qt,dl as gt,cL as $,dm as dt,dn as he,cs as ue,dp as Gt,dq as nt,i as it,dr as fe,cF as wt,cC as Z,ds as V,dt as me,c$ as pe,du as Zt,dv as O,cM as Rt,dw as Mt,dx as yt,cI as Kt,cB as Jt,dy as ge,cD as Ct,cS as I,O as we,dz as ye,dA as L}from"./virtual-memory-controller-CWnYvOUm.js";class k{constructor(){a(this,"enabled",!0);a(this,"trigger",t=>{if(!this.enabled)return;const e=this.handlers.slice(0);for(const s of e)s(t)});a(this,"handlers",[])}add(t){this.handlers.push(t)}remove(t){this.handlers=this.handlers.filter(e=>e!==t)}reset(){this.handlers.length=0}}class Lt extends Map{constructor(e){super(e);a(this,"onItemSet",new k);a(this,"onItemUpdated",new k);a(this,"onItemDeleted",new k);a(this,"onBeforeDelete",new k);a(this,"onCleared",new k);a(this,"guard",()=>!0)}set eventsEnabled(e){this.onItemSet.enabled=e,this.onItemUpdated.enabled=e,this.onItemDeleted.enabled=e,this.onBeforeDelete.enabled=e,this.onCleared.enabled=e}clear(){for(const[e,s]of this)this.onBeforeDelete.trigger({key:e,value:s});super.clear(),this.onCleared.trigger()}set(e,s){const n=this.has(e);if(!(this.guard??(()=>!0))(e,s))return this;const o=super.set(e,s);return n?(this.onItemUpdated||(this.onItemUpdated=new k),this.onItemUpdated.trigger({key:e,value:s})):(this.onItemSet||(this.onItemSet=new k),this.onItemSet.trigger({key:e,value:s})),o}delete(e){const s=this.get(e);if(!s)return!1;this.onBeforeDelete.trigger({key:e,value:s});const n=super.delete(e);return n&&this.onItemDeleted.trigger(e),n}getKey(e){for(const[s,n]of this)if(n===e)return s}update(e){const s=this.getKey(e);s&&this.set(s,e)}deleteIf(e){for(const[s,n]of this)e(n,s)&&this.delete(s)}replaceKey(e,s,n=!1){const i=this.get(e);return!i||this.get(s)&&!n?!1:(this.eventsEnabled=!1,this.delete(e),this.eventsEnabled=!0,this.set(s,i),!0)}dispose(){this.clear(),this.onItemSet.reset(),this.onItemDeleted.reset(),this.onItemUpdated.reset(),this.onCleared.reset(),this.onBeforeDelete.reset()}}class _e{constructor(t,e,s,n){a(this,"x");a(this,"y");a(this,"z");a(this,"hash");a(this,"id");this.x=R.round(t[e*3],n),this.y=R.round(t[e*3+1],n),this.z=R.round(t[e*3+2],n),this.hash=`${this.x}/${this.y}/${this.z}`,this.id=s}}class Ie{constructor(t){a(this,"list",new Map);a(this,"tempV1",new y);a(this,"tempV2",new y);a(this,"tempV3",new y);a(this,"precission");this.precission=t}create(t,e){const s=new _e(t,e,this.list.size,this.precission);return this.list.has(s.hash)||this.list.set(s.hash,s),this.list.get(s.hash)}get(){return Array.from(this.list.values()).map(t=>[t.x,t.y,t.z])}isValidTriangle(t,e,s,n){this.tempV1.set(t[e*3],t[e*3+1],t[e*3+2]),this.tempV2.set(t[s*3],t[s*3+1],t[s*3+2]),this.tempV3.set(t[n*3],t[n*3+1],t[n*3+2]);const i=1/this.precission*10,r=this.tempV1.distanceTo(this.tempV2)>i,o=this.tempV1.distanceTo(this.tempV3)>i,c=this.tempV2.distanceTo(this.tempV3)>i;return r&&o&&c}}class ve{constructor(t,e){a(this,"edges",new Map);a(this,"openEdges",new Set);a(this,"id");a(this,"plane");this.id=t,this.plane=e}add(t){if(this.edges.size===0){for(const e of t)this.openEdges.add(e.hash),this.edges.set(e.hash,e);return}for(const e of t)this.openEdges.has(e.hash)?this.openEdges.delete(e.hash):this.openEdges.add(e.hash),this.edges.set(e.hash,e)}match(t,e){if(e.id!==this.plane.id)return!1;for(const s of t)if(this.openEdges.has(s.hash))return!0;return!1}getOpenEdges(){const t=[];for(const e of this.openEdges)t.push(this.edges.get(e));return t}merge(t){for(const[e,s]of t.edges)this.edges.set(e,s);for(const e of t.openEdges)this.openEdges.has(e)?this.openEdges.delete(e):this.openEdges.add(e)}}class Me{constructor(){a(this,"list",new Map);a(this,"nextFaceID",0)}add(t,e){const s=this.match(t,e);if(s.length===0){const n=this.nextFaceID++,i=new ve(n,e);i.add(t),this.list.set(i.id,i);return}if(s.length===1){this.list.get(s[0]).add(t);return}if(s.length>1){const n=this.list.get(s[0]);n.add(t);for(let i=1;i<s.length;i++){const r=s[i],o=this.list.get(r);n.merge(o),this.list.delete(r)}}}match(t,e){let s=[];for(const n of this.list.values())n.match(t,e)&&s.push(n.id);return s}}class ot{constructor(t,e){a(this,"p1");a(this,"p2");a(this,"hash");this.p1=t,this.p2=e;const s=[this.p1,this.p2];s.sort((n,i)=>n.x-i.x||n.y-i.y||n.z-i.z),this.hash=`${s[0].hash}_${s[1].hash}`}}class be{constructor(t){a(this,"closed",!1);a(this,"openStartPoint",null);a(this,"openEndPoint",null);a(this,"plane");a(this,"orderedPoints",[]);this.plane=t}getEdges(t=!1){const e=[];if(t)for(let s=this.orderedPoints.length-1;s>0;s--)e.push(new ot(this.orderedPoints[s],this.orderedPoints[s-1]));else for(let s=0;s<this.orderedPoints.length-1;s++)e.push(new ot(this.orderedPoints[s],this.orderedPoints[s+1]));return e}getIndices(){return this.orderedPoints.map(t=>t.id)}add(t){if(this.orderedPoints.length===0){this.openStartPoint=t.p1.hash,this.openEndPoint=t.p2.hash,this.orderedPoints.push(t.p1,t.p2);return}const e=this.match(t);if(e===0)throw new Error("Fragments: Edge doesn't match with any open point");if(e>2)throw new Error("Fragments: Edge matches with more than 2 open points");if(e===2){this.closed=!0,this.openEndPoint=null,this.openStartPoint=null;return}this.openStartPoint===t.p1.hash?(this.orderedPoints.unshift(t.p2),this.openStartPoint=t.p2.hash):this.openEndPoint===t.p1.hash?(this.orderedPoints.push(t.p2),this.openEndPoint=t.p2.hash):this.openStartPoint===t.p2.hash?(this.orderedPoints.unshift(t.p1),this.openStartPoint=t.p1.hash):this.openEndPoint===t.p2.hash&&(this.orderedPoints.push(t.p1),this.openEndPoint=t.p1.hash)}match(t){if(this.closed)return 0;let e=0;return this.openStartPoint===t.p1.hash&&e++,this.openStartPoint===t.p2.hash&&e++,this.openEndPoint===t.p1.hash&&e++,this.openEndPoint===t.p2.hash&&e++,e}merge(t){if(t.closed||this.closed)throw new Error("Fragments: Cannot merge closed profiles");if(t.openStartPoint===this.openEndPoint&&t.openEndPoint===this.openStartPoint)throw new Error("Fragments: Cannot merge profiles that close each other");if(t.openEndPoint===this.openEndPoint&&t.openStartPoint===this.openStartPoint)throw new Error("Fragments: Cannot merge profiles that close each other");let e=!1;(t.openEndPoint===this.openStartPoint||t.openEndPoint===this.openEndPoint)&&(e=!0);const s=t.getEdges(e);for(const n of s)this.add(n)}getArea(){const t=this.orderedPoints.map(d=>[d.x,d.y,d.z]);let e=0,s=1;const n=Math.abs(this.plane.normal.x),i=Math.abs(this.plane.normal.y),r=Math.abs(this.plane.normal.z);n>=i&&n>=r?(e=1,s=2):i>=n&&i>=r?(e=0,s=2):(e=0,s=1);const o=[];for(const d of t)o.push(new rt(d[e],d[s]));let c=0;for(let d=0,u=o.length;d<u;d++){const l=o[d].x,f=o[d===o.length-1?0:d+1].y,p=o[d===o.length-1?0:d+1].x,h=o[d].y;c+=l*f*.5,c-=p*h*.5}return Math.abs(c)}}class xe{constructor(t){a(this,"list",new Map);a(this,"plane");a(this,"nextProfileID",0);this.plane=t}add(t){const e=this.match(t);if(e.length===0){const s=this.nextProfileID++,n=new be(this.plane);n.add(t),this.list.set(s,n);return}if(e.length===1){this.list.get(e[0]).add(t);return}if(e.length>1){const s=this.list.get(e[0]);s.add(t);const n=this.list.get(e[1]);s.merge(n),this.list.delete(e[1])}}getProfiles(){let t=null,e=0;for(const[i,r]of this.list){const o=r.getArea();o>e&&(e=o,t=i)}if(t===null)return null;const s=this.list.get(t).getIndices(),n=[];for(const[i,r]of this.list)i!==t&&n.push(r.getIndices());return{profile:s,holes:n}}match(t){const e=[];for(const[s,n]of this.list)n.match(t)>0&&e.push(s);return e}}class Ee{constructor(t,e,s){a(this,"normal");a(this,"constant");a(this,"id");a(this,"faces",[]);const n=R.round(t.normal.x,s),i=R.round(t.normal.y,s),r=R.round(t.normal.z,s),o=R.round(t.constant,e);this.normal=new y(n,i,r),this.constant=o;const c="||";this.id=`${n}${c}${i}${c}${r}${c}${o}`}}const at=class at{static round(t,e){return Math.round(t*e)/e}static getAABB(t){let e=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,n=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,r=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let c=0;c<t.length;c+=3){const d=t[c],u=t[c+1],l=t[c+2];d<e&&(e=d),u<s&&(s=u),l<n&&(n=l),d>i&&(i=d),u>r&&(r=u),l>o&&(o=l)}return{min:{x:e,y:s,z:n},max:{x:i,y:r,z:o}}}static transformFromMatrix(t,e={position:[0,0,0],xDirection:[1,0,0],yDirection:[0,1,0]}){const s=t.elements[12],n=t.elements[13],i=t.elements[14],r=t.elements[0],o=t.elements[1],c=t.elements[2],d=t.elements[4],u=t.elements[5],l=t.elements[6];return e.position[0]=s,e.position[1]=n,e.position[2]=i,e.xDirection[0]=r,e.xDirection[1]=o,e.xDirection[2]=c,e.yDirection[0]=d,e.yDirection[1]=u,e.yDirection[2]=l,e}static matrixFromTransform(t){const e=new K,[s,n,i]=t.position,[r,o,c]=t.xDirection,[d,u,l]=t.yDirection,f=new y(r,o,c),p=new y(d,u,l),{x:h,y:m,z:w}=f.cross(p);return e.fromArray([r,o,c,0,d,u,l,0,h,m,w,0,s,n,i,1]),e}static bboxFromCircleExtrusion(t){const e=new Y,s=[];for(const u of t.axes)for(const l of u.wires)for(let f=0;f<l.length-2;f+=3){const p=l[f],h=l[f+1],m=l[f+2];s.push(new y(p,h,m))}e.setFromPoints(s);const n=e.min.x,i=e.min.y,r=e.min.z,o=e.max.x,c=e.max.y,d=e.max.z;return[n,i,r,o,c,d]}static representationFromGeometry(t,e={bbox:[0,0,0,0,0,0],representationClass:et.SHELL,geometry:{points:[],type:bt.NONE,profiles:new Map,holes:new Map,bigHoles:new Map,bigProfiles:new Map,profilesFaceIds:[]}},s={threshold:3e3,precision:1e6,normalPrecision:1e7,planePrecision:1e3}){const i=t.getAttribute("position").array,o=t.getAttribute("normal").array,d=t.index.array,u=at.getShellData({position:i,normals:o,index:d,raw:!1,settings:s}),{min:l,max:f}=u.bbox;if(e.bbox=[l.x,l.y,l.z,f.x,f.y,f.z],e.representationClass===et.CIRCLE_EXTRUSION)throw new Error("Circle extrusions can't be represented as shells");const p=e.geometry,h=u.points,m=h.length>at.ushortMaxValue;return p.type=m?bt.BIG:bt.NONE,p.points=h,p.profilesFaceIds=u.profilesFaceIds,m?(p.profiles=new Map,p.holes=new Map,p.bigHoles=u.holes,p.bigProfiles=u.profiles):(p.profiles=u.profiles,p.holes=u.holes,p.bigHoles=new Map,p.bigProfiles=new Map),e}static getRawShellData(t,e,s){const n=new Map,i=new Map,r=(d,u,l)=>{const f=`${d},${u},${l}`;if(n.has(f))return n.get(f)[0];const p=n.size;return n.set(f,[p,d,u,l]),p};for(let d=0;d<t.length-2;d+=3){const u=t[d],l=t[d+1],f=t[d+2],p=e[u*3],h=e[u*3+1],m=e[u*3+2],w=e[l*3],_=e[l*3+1],M=e[l*3+2],x=e[f*3],v=e[f*3+1],S=e[f*3+2],b=r(p,h,m),T=r(w,_,M),B=r(x,v,S);i.set(i.size,[b,T,B])}const o=[];for(const[,[,d,u,l]]of n)o.push([d,u,l]);const c={bbox:s,type:et.SHELL,profiles:i,holes:new Map,points:o,profilesFaceIds:[]};for(let d=0;d<i.size;d++)c.profilesFaceIds.push(0);return c}static getShellData(t){const{position:e,normals:s,index:n,raw:i,settings:r}=t,{threshold:o,precision:c,normalPrecision:d,planePrecision:u}=r,f=e.length/3>o,p=this.getAABB(e);if(i||f)return this.getRawShellData(n,e,p);const h=new W,m=new y,w=new y,_=new Map;for(let C=0;C<n.length-2;C+=3){const E=n[C];m.set(s[E*3],s[E*3+1],s[E*3+2]),w.set(e[E*3],e[E*3+1],e[E*3+2]),h.setFromNormalAndCoplanarPoint(m,w);const z=new Ee(h,u,d);_.has(z.id)||_.set(z.id,z),_.get(z.id).faces.push(C)}const M=new Ie(c),x=new Me;for(const[,C]of _)for(const E of C.faces){const z=n[E],F=n[E+1],ht=n[E+2];if(!M.isValidTriangle(e,z,F,ht))continue;const zt=M.create(e,z),Bt=M.create(e,F),Ft=M.create(e,ht),ie=new ot(zt,Bt),re=new ot(Bt,Ft),oe=new ot(Ft,zt),ae=[ie,re,oe];x.add(ae,C)}const v=new Map,S=new Map;let b=0;for(const[,C]of x.list){const E=new xe(C.plane),z=C.getOpenEdges();if(z.length===0)return console.log("No open edges found. Using raw geometry."),this.getRawShellData(n,e,p);for(const ht of z)E.add(ht);const F=E.getProfiles();v.set(b,(F==null?void 0:F.profile)||[]),S.set(b,(F==null?void 0:F.holes)||[]),b++}let T=0;const B=new Map,X=new Map;for(const[C,E]of v)E.length&&(B.set(C,T),X.set(T,E),T++);const j=new Map;for(const[C,E]of S)if(E.length){const z=B.get(C);j.set(z,E)}const H={bbox:p,type:et.SHELL,profiles:X,holes:j,points:M.get(),profilesFaceIds:[]};return this.computeShellFaceIds(H),H}static computeShellFaceIds(t){const s=new Map;let n=0;const i=new Map,r=new Map,o=new Map,c=new y,d=new y,u=new y,l=new y,f=new $t,p=t.profiles.size;for(let m=0;m<p;m++){const w=t.profiles.get(m),_=w.length;for(let S=0;S<_;S++){const b=w[S],B=S===_-1?w[0]:w[S+1],X=Math.min(b,B),j=Math.max(b,B),H=X+this.makeDecimal(j);r.has(m)?r.get(m).push(H):r.set(m,[H]),i.has(H)?i.get(H).push(m):i.set(H,[m])}let M=0,x=1,v=2;for(;v<_;){const S=w[M],b=w[x],T=w[v];if(c.set(t.points[S][0],t.points[S][1],t.points[S][2]),d.set(t.points[b][0],t.points[b][1],t.points[b][2]),u.set(t.points[T][0],t.points[T][1],t.points[T][2]),f.set(c,d,u),f.getNormal(l),l.x!==0||l.y!==0||l.z!==0)break;M++,x++,v++}o.set(m,[l.x,l.y,l.z])}for(const[m,w]of r){let _=s.get(m);_===void 0&&(_=n++,s.set(m,_));const[M,x,v]=o.get(m);for(const S of w){const b=i.get(S);for(const T of b){if(T===m)continue;const[B,X,j]=o.get(T),C=Math.abs(M*B+x*X+v*j)<.4;if(s.has(T)){if(!C){const E=s.get(T);for(const[z,F]of s)F===E&&s.set(z,_)}}else{const E=C?n++:_;s.set(T,E)}}}}for(let m=0;m<t.profiles.size;m++)if(!s.has(m))throw new Error(`Face id not found for profile ${m}`);const h=Array.from(s.keys()).sort((m,w)=>m-w);for(const m of h){const w=s.get(m);t.profilesFaceIds.push(w)}}static makeDecimal(t){let e=1;for(;e<=t;)e*=10;return t/e}};a(at,"ushortMaxValue",65e3);let R=at;class te{static transform(t,e,s=new ct){for(let n=0;n<s.planes.length;n++){const i=s.planes[n],r=t.planes[n];i.copy(r),i.applyMatrix4(e)}return s}static isIncluded(t,e){return Ot.collides(t,e,!0)}static collides(t,e){return Ot.collides(t,e,!1)}}class Se{constructor(){a(this,"int");a(this,"float");a(this,"buffer");a(this,"s1",4);a(this,"s2",8);const{intBuffer:t,floatBuffer:e,buffer:s}=this.newBuffers();this.int=t,this.float=e,this.buffer=s}newBuffers(){const t=new Int32Array(1),e=t.buffer,s=new Float32Array(e),n=new Uint8Array(e);return{intBuffer:t,floatBuffer:s,buffer:n}}}class At{static check(t){const e=Number.isInteger(t),s=t<this._max,n=t>this._min;return e&&s&&n}}a(At,"_max",2147483647),a(At,"_min",-2147483648);const It=class It{constructor(){a(this,"_core",new Se);a(this,"_handlers");a(this,"_result",-1);a(this,"handleObject",t=>{const e=Object.keys(t);for(const s of e)t.hasOwnProperty(s)&&this.compute(t[s])});a(this,"handleString",t=>{const e=t.length;for(let s=0;s<e;++s){const n=t.codePointAt(s);this._core.int[0]=n,this.update()}});a(this,"handleBoolean",t=>{t?this._core.int[0]=1:this._core.int[0]=0,this.update()});a(this,"handleNumber",t=>{const s=At.check(t)?this._core.int:this._core.float;s[0]=t,this.update()});this._handlers=this.newHandlers()}get value(){return~this._result}fromMaterialData(t){const{modelId:e,objectClass:s,currentLod:n,templateId:i,...r}=t;this.reset(),this.compute(e),this.compute(s),this.compute(r),this.compute(n),this.compute(i!==void 0)}generate(t){this.reset();for(const e of t)this.compute(e);return this.value}compute(t){return this.getHandler(t)(t),this}reset(){return this._result=-1,this}getHandler(t){const e=typeof t,s=this._handlers[e];if(!s)throw new Error("Fragments: Unsupported input type");return s}newHandlers(){return{number:this.handleNumber,boolean:this.handleBoolean,string:this.handleString,object:this.handleObject}}update(){for(let t=0;t<this._core.s1;++t){this._result^=this._core.buffer[t];for(let e=0;e<this._core.s2;++e)this._result&1?this._result=this._result>>1^It._polynomial:this._result>>=1}}};a(It,"_polynomial",2197175160);let Dt=It;const Q=class Q{constructor(t,e){a(this,"_first");this._first=this.newData(t,e)}static getComplementary(t,e){let s=0;const n=t.position.length;s=this.makeBufferComplementary(n,t,s,e),s!==1/0&&e(s,1/0)}static get(t,e,s,n){const{filtered:i,position:r,size:o}=this.getData(t,s);return this.setAllBufferData(i,e,r,o,n),{position:r,size:o}}fullOf(t){const e=this._first.following,s=this._first.data;return e===null&&s===t}update(t,e){const s=this.getBufferData(t);if(!(s.data===e)){const{a:i,c:r,b:o}=this.newBuffers(t,s,e);this.setupInputData(s,i,r),this.setupUpdateBuffers(i,o,r)}}size(t){let e=0,s=this._first;for(;s!==null;)this.doesFilterPass(t,s)&&e++,s=s.following;return e}static setAllBufferData(t,e,s,n,i){for(let r=0;r<t.length;++r){const o=t[r];this.transform(o,e),this.setBuffers(s,n,r),i&&i(r,o.data)}}static makeBufferComplementary(t,e,s,n){for(let i=0;i<t;++i){const r=this.getBuffers(e,i),{position:o,size:c}=r;o>s&&n(s,o-s),s=o+c}return s}static setBuffers(t,e,s){t[s]=this._tempData.position,this._tempData.size===1/0?e[s]=this._inf:e[s]=this._tempData.size}add(t,e,s){if(!Q._stash.length)return this.newData(e,s,t);const i=Q._stash.pop();if(!i)throw new Error("Fragments: No stash found");return i.position=t,i.size=e,i.data=s,i}remove(t){t&&(t.following=null,t.past=null,Q._stash.push(t))}static getData(t,e){const s=t.filter(e),n=s.length,i=new Uint32Array(n),r=new Uint32Array(n);return{filtered:s,position:i,size:r}}filter(t){const e=[];let s=this._first;for(;s!==null;)this.doesFilterPass(t,s)&&e.push(s),s=s.following;return e}static transform(t,e){const s=this.getTempData(),n=t.position+t.size,i=n===e.length;if(s.position=e[t.position],i)s.size=1/0;else{const r=e[n];s.size=r-s.position}return s}static getBuffers(t,e){const s=t.position[e],n=t.size[e]===this._inf;let i;return n?i=1/0:i=t.size[e],{position:s,size:i}}static getTempData(){return this._tempData?this._tempData:{position:0,size:0}}doesFilterPass(t,e){return!t||t(e.data)}setupUpdateBuffers(t,e,s){this.chainBuffers(t,e,s),this.setupFirstBuffer(t,e),this.setupLastBuffer(s,e),this.setupMiddleBufferStart(e),this.setupMiddleBufferEnd(e)}setupMiddleBufferEnd(t){var e;if(((e=t.following)==null?void 0:e.data)===t.data){if(!t.following)return;const s=t.following.size+t.size,n=t.following.following;t.size=s,this.remove(t.following),t.following=n,t.following&&(t.following.past=t)}}setupFirstBuffer(t,e){t.size||(t.past?t.past.following=e:this._first=e,e.past=t.past,this.remove(t))}setupMiddleBufferStart(t){var e;if(((e=t.past)==null?void 0:e.data)===t.data){if(!t.past)return;t.size=t.past.size+t.size,t.position=t.past.position;const s=t.past.past;this.remove(t.past),t.past=s,t.past?t.past.following=t:this._first=t}}chainBuffers(t,e,s){t.following=e,e.past=t,e.following=s,s.past=e}setupLastBuffer(t,e){t.size||(t.following&&(t.following.past=e),e.following=t.following,this.remove(t))}newBuffers(t,e,s){const n=t-e.position,i=this.add(e.position,n,e.data),r=this.add(t,1,s),o=e.size-i.size-1,c=this.add(t+1,o,e.data);return{a:i,c,b:r}}setupInputData(t,e,s){t.past?(t.past.following=e,e.past=t.past):this._first=e,t.following&&(t.following.past=s,s.following=t.following),this.remove(t)}newData(t,e,s=0){return{position:s,size:t,past:null,following:null,data:e}}getBufferData(t){let e=this._first;for(;;){const s=e===null,n=e.position<=t,i=t<e.position+e.size;if(s||n&&i)return e;e=e.following}}};a(Q,"_stash",[]),a(Q,"_tempData",{position:0,size:0}),a(Q,"_inf",4294967295);let Pt=Q;class ee{static estimateCapacity(){const t=this.capacityFactor,e=window.screen.width,s=window.screen.height,n=window.devicePixelRatio;return Math.trunc(e*s*n*n*t)}}a(ee,"capacityFactor",200);const Nt=new Y,ut=new y;class se extends Yt{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";const t=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],e=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],s=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(s),this.setAttribute("position",new Ut(t,3)),this.setAttribute("uv",new Ut(e,2))}applyMatrix4(t){const e=this.attributes.instanceStart,s=this.attributes.instanceEnd;return e!==void 0&&(e.applyMatrix4(t),s.applyMatrix4(t),e.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const s=new Tt(e,6,1);return this.setAttribute("instanceStart",new st(s,3,0)),this.setAttribute("instanceEnd",new st(s,3,3)),this.instanceCount=this.attributes.instanceStart.count,this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const s=new Tt(e,6,1);return this.setAttribute("instanceColorStart",new st(s,3,0)),this.setAttribute("instanceColorEnd",new st(s,3,3)),this}fromWireframeGeometry(t){return this.setPositions(t.attributes.position.array),this}fromEdgesGeometry(t){return this.setPositions(t.attributes.position.array),this}fromMesh(t){return this.fromWireframeGeometry(new de(t.geometry)),this}fromLineSegments(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Y);const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;t!==void 0&&e!==void 0&&(this.boundingBox.setFromBufferAttribute(t),Nt.setFromBufferAttribute(e),this.boundingBox.union(Nt))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new vt),this.boundingBox===null&&this.computeBoundingBox();const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(t!==void 0&&e!==void 0){const s=this.boundingSphere.center;this.boundingBox.getCenter(s);let n=0;for(let i=0,r=t.count;i<r;i++)ut.fromBufferAttribute(t,i),n=Math.max(n,s.distanceToSquared(ut)),ut.fromBufferAttribute(e,i),n=Math.max(n,s.distanceToSquared(ut));this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}}gt.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new rt(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}};pt.line={uniforms:Qt.merge([gt.common,gt.fog,gt.line]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};class J extends Xt{constructor(t){super({type:"LineMaterial",uniforms:Qt.clone(pt.line.uniforms),vertexShader:pt.line.vertexShader,fragmentShader:pt.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,this.setValues(t)}get color(){return this.uniforms.diffuse.value}set color(t){this.uniforms.diffuse.value=t}get worldUnits(){return"WORLD_UNITS"in this.defines}set worldUnits(t){t===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}get linewidth(){return this.uniforms.linewidth.value}set linewidth(t){this.uniforms.linewidth&&(this.uniforms.linewidth.value=t)}get dashed(){return"USE_DASH"in this.defines}set dashed(t){t===!0!==this.dashed&&(this.needsUpdate=!0),t===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}get dashScale(){return this.uniforms.dashScale.value}set dashScale(t){this.uniforms.dashScale.value=t}get dashSize(){return this.uniforms.dashSize.value}set dashSize(t){this.uniforms.dashSize.value=t}get dashOffset(){return this.uniforms.dashOffset.value}set dashOffset(t){this.uniforms.dashOffset.value=t}get gapSize(){return this.uniforms.gapSize.value}set gapSize(t){this.uniforms.gapSize.value=t}get opacity(){return this.uniforms.opacity.value}set opacity(t){this.uniforms&&(this.uniforms.opacity.value=t)}get resolution(){return this.uniforms.resolution.value}set resolution(t){this.uniforms.resolution.value.copy(t)}get alphaToCoverage(){return"USE_ALPHA_TO_COVERAGE"in this.defines}set alphaToCoverage(t){this.defines&&(t===!0!==this.alphaToCoverage&&(this.needsUpdate=!0),t===!0?this.defines.USE_ALPHA_TO_COVERAGE="":delete this.defines.USE_ALPHA_TO_COVERAGE)}}const xt=new dt,Vt=new y,jt=new y,A=new dt,D=new dt,U=new dt,Et=new y,St=new K,P=new he,Ht=new y,ft=new Y,mt=new vt,G=new dt;let N,tt;function kt(g,t,e){return G.set(0,0,-t,1).applyMatrix4(g.projectionMatrix),G.multiplyScalar(1/G.w),G.x=tt/e.width,G.y=tt/e.height,G.applyMatrix4(g.projectionMatrixInverse),G.multiplyScalar(1/G.w),Math.abs(Math.max(G.x,G.y))}function Te(g,t){const e=g.matrixWorld,s=g.geometry,n=s.attributes.instanceStart,i=s.attributes.instanceEnd,r=Math.min(s.instanceCount,n.count);for(let o=0,c=r;o<c;o++){P.start.fromBufferAttribute(n,o),P.end.fromBufferAttribute(i,o),P.applyMatrix4(e);const d=new y,u=new y;N.distanceSqToSegment(P.start,P.end,u,d),u.distanceTo(d)<tt*.5&&t.push({point:u,pointOnLine:d,distance:N.origin.distanceTo(u),object:g,face:null,faceIndex:o,uv:null,uv1:null})}}function Re(g,t,e){const s=t.projectionMatrix,i=g.material.resolution,r=g.matrixWorld,o=g.geometry,c=o.attributes.instanceStart,d=o.attributes.instanceEnd,u=Math.min(o.instanceCount,c.count),l=-t.near;N.at(1,U),U.w=1,U.applyMatrix4(t.matrixWorldInverse),U.applyMatrix4(s),U.multiplyScalar(1/U.w),U.x*=i.x/2,U.y*=i.y/2,U.z=0,Et.copy(U),St.multiplyMatrices(t.matrixWorldInverse,r);for(let f=0,p=u;f<p;f++){if(A.fromBufferAttribute(c,f),D.fromBufferAttribute(d,f),A.w=1,D.w=1,A.applyMatrix4(St),D.applyMatrix4(St),A.z>l&&D.z>l)continue;if(A.z>l){const x=A.z-D.z,v=(A.z-l)/x;A.lerp(D,v)}else if(D.z>l){const x=D.z-A.z,v=(D.z-l)/x;D.lerp(A,v)}A.applyMatrix4(s),D.applyMatrix4(s),A.multiplyScalar(1/A.w),D.multiplyScalar(1/D.w),A.x*=i.x/2,A.y*=i.y/2,D.x*=i.x/2,D.y*=i.y/2,P.start.copy(A),P.start.z=0,P.end.copy(D),P.end.z=0;const m=P.closestPointToPointParameter(Et,!0);P.at(m,Ht);const w=ue.lerp(A.z,D.z,m),_=w>=-1&&w<=1,M=Et.distanceTo(Ht)<tt*.5;if(_&&M){P.start.fromBufferAttribute(c,f),P.end.fromBufferAttribute(d,f),P.start.applyMatrix4(r),P.end.applyMatrix4(r);const x=new y,v=new y;N.distanceSqToSegment(P.start,P.end,v,x),e.push({point:v,pointOnLine:x,distance:N.origin.distanceTo(v),object:g,face:null,faceIndex:f,uv:null,uv1:null})}}}class Ce extends ${constructor(t=new se,e=new J({color:Math.random()*16777215})){super(t,e),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const t=this.geometry,e=t.attributes.instanceStart,s=t.attributes.instanceEnd,n=new Float32Array(2*e.count);for(let r=0,o=0,c=e.count;r<c;r++,o+=2)Vt.fromBufferAttribute(e,r),jt.fromBufferAttribute(s,r),n[o]=o===0?0:n[o-1],n[o+1]=n[o]+Vt.distanceTo(jt);const i=new Tt(n,2,1);return t.setAttribute("instanceDistanceStart",new st(i,1,0)),t.setAttribute("instanceDistanceEnd",new st(i,1,1)),this}raycast(t,e){const s=this.material.worldUnits,n=t.camera;n===null&&!s&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const i=t.params.Line2!==void 0&&t.params.Line2.threshold||0;N=t.ray;const r=this.matrixWorld,o=this.geometry,c=this.material;tt=c.linewidth+i,o.boundingSphere===null&&o.computeBoundingSphere(),mt.copy(o.boundingSphere).applyMatrix4(r);let d;if(s)d=tt*.5;else{const l=Math.max(n.near,mt.distanceToPoint(N.origin));d=kt(n,l,c.resolution)}if(mt.radius+=d,N.intersectsSphere(mt)===!1)return;o.boundingBox===null&&o.computeBoundingBox(),ft.copy(o.boundingBox).applyMatrix4(r);let u;if(s)u=tt*.5;else{const l=Math.max(n.near,ft.distanceToPoint(N.origin));u=kt(n,l,c.resolution)}ft.expandByScalar(u),N.intersectsBox(ft)!==!1&&(s?Te(this,e):Re(this,n,e))}onBeforeRender(t){const e=this.material.uniforms;e&&e.resolution&&(t.getViewport(xt),this.material.uniforms.resolution.value.set(xt.z,xt.w))}}class ne extends se{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(t){const e=t.length-3,s=new Float32Array(2*e);for(let n=0;n<e;n+=3)s[2*n]=t[n],s[2*n+1]=t[n+1],s[2*n+2]=t[n+2],s[2*n+3]=t[n+3],s[2*n+4]=t[n+4],s[2*n+5]=t[n+5];return super.setPositions(s),this}setColors(t){const e=t.length-3,s=new Float32Array(2*e);for(let n=0;n<e;n+=3)s[2*n]=t[n],s[2*n+1]=t[n+1],s[2*n+2]=t[n+2],s[2*n+3]=t[n+3],s[2*n+4]=t[n+4],s[2*n+5]=t[n+5];return super.setColors(s),this}setFromPoints(t){const e=t.length-1,s=new Float32Array(6*e);for(let n=0;n<e;n++)s[6*n]=t[n].x,s[6*n+1]=t[n].y,s[6*n+2]=t[n].z||0,s[6*n+3]=t[n+1].x,s[6*n+4]=t[n+1].y,s[6*n+5]=t[n+1].z||0;return super.setPositions(s),this}fromLine(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}}class Ae extends Ce{constructor(t=new ne,e=new J({color:Math.random()*16777215})){super(t,e),this.isLine2=!0,this.type="Line2"}}class De{constructor(t){a(this,"model");a(this,"_endpointsMaterials",{interior:new Gt({color:15658734,size:8,sizeAttenuation:!1,depthTest:!1}),exterior:new Gt({color:16777215,size:16,sizeAttenuation:!1,depthTest:!1})});a(this,"_absoluteAlignments",new nt);a(this,"_horizontalAlignments",new nt);a(this,"_verticalAlignments",new nt);a(this,"_alignmentMaterials",new Map([[it.NONE,new J({color:16777215,linewidth:5,depthTest:!1})],[it.LINES,new J({color:16711935,linewidth:5,depthTest:!1})],[it.CLOTHOID,new J({color:16711680,linewidth:5,depthTest:!1})],[it.ELLIPSE_ARC,new J({color:65535,linewidth:5,depthTest:!1})],[it.PARABOLA,new J({color:255,linewidth:5,depthTest:!1})]]));this.model=t}async getAlignments(){return this._absoluteAlignments.children.length||await this.constructAlignments(),this._absoluteAlignments}async getHorizontalAlignments(){return this._horizontalAlignments.children.length||await this.constructAlignments(),this._horizontalAlignments}async getVerticalAlignments(){return this._verticalAlignments.children.length||await this.constructAlignments(),this._verticalAlignments}async getAlignmentStyles(){return{...this._alignmentMaterials,...this._endpointsMaterials}}async constructAlignments(){const t=await this.model.threads.invoke(this.model.modelId,"getAlignments");for(const e of t)this.constructLine(e.absolute,this._absoluteAlignments),this.constructLine(e.horizontal,this._horizontalAlignments),this.constructLine(e.vertical,this._verticalAlignments)}constructLine(t,e){if(!t.length)return;const s=[],n=[],i=new nt;e.add(i);const r=t[0].points,o=t[t.length-1].points;n.push(o[0],o[1],o[2]),n.push(r[r.length-3],r[r.length-2],r[r.length-1]);for(const u of t){const l=u.points;s.push(l[0],l[1],l[2]),s.push(l[l.length-3],l[l.length-2],l[l.length-1]);const f=new ne;f.setPositions(l);const p=this._alignmentMaterials.get(u.type),h=new Ae(f,p);i.add(h),h.renderOrder=1,h.userData.points=l}const{interior:c,exterior:d}=this._endpointsMaterials;this.constructPoints(s,c,i),this.constructPoints(n,d,i)}constructPoints(t,e,s){const n=new fe,i=new wt,r=new Float32Array(t),o=new Z(r,3);i.setAttribute("position",o),n.geometry=i,n.material=e,s.add(n),n.renderOrder=2}dispose(){this._absoluteAlignments.removeFromParent();for(const t of this._absoluteAlignments.children){const e=t;e.geometry.dispose(),e.geometry=void 0,e.material=void 0}for(const t of Object.values(this._alignmentMaterials))t.dispose();this._alignmentMaterials={}}}class Pe{async setup(t,e,s,n,i){const r=this.getCreateModelMessage(t,s,n,i),o=this.formatModelData(s),c=await t.threads.fetch(r,o);this.updateBox(e,c)}formatModelData(t){if(t instanceof ArrayBuffer)return[t]}updateBox(t,e){t.min.copy(e.boundingBox.min),t.max.copy(e.boundingBox.max)}getCreateModelMessage(t,e,s,n){return{class:V.CREATE_MODEL,modelId:t.modelId,modelData:e,raw:s,config:n}}}class Le{async getBoxes(t,e){const s=this.getIndividualBoxesIds(e),n=this.getBoxRequest(t,s),i=await t.threads.fetch(n);return this.getAllBoxes(i,t)}async getMergedBox(t,e){const s=this.getBoxRequest(t,[e]),{boxes:n}=await t.threads.fetch(s),[i]=n;return this.getAbsoluteBox(i,t)}getAbsoluteBox(t,e){const s=new Y;return s.copy(t),s.applyMatrix4(e.object.matrixWorld),s}getIndividualBoxesIds(t){if(!t)return;const e=[];for(const s of t)e.push([s]);return e}getAllBoxes(t,e){const s=t.boxes,n=[];for(const i of s){const r=new Y;r.copy(i),r.applyMatrix4(e.object.matrixWorld),n.push(r)}return n}getBoxRequest(t,e){return{class:V.FETCH_BOXES,modelId:t.modelId,localIds:e}}}class qe{constructor(){a(this,"_coordinationMatrices",new Map)}async getCoordinationMatrix(t){let e=this._coordinationMatrices.get(t.modelId);if(e)return e;e=new K,this._coordinationMatrices.set(t.modelId,e);const[s,n,i,r,o,c,d,u,l]=await this.getCoordinates(t),f=new y(r,o,c),p=new y(d,u,l),h=new y().crossVectors(f,p);return e.set(r,d,h.x,s,o,u,h.y,n,c,l,h.z,i,0,0,0,1),e}async getCoordinates(t){const e=t.modelId;return t.threads.invoke(e,"getCoordinates")}async getPositions(t,e){const s=[e],n=await t.threads.invoke(t.modelId,"getPositions",s);return this.getAbsolutePositions(n,t)}getAbsolutePositions(t,e){const s=[];for(const n of t){const{x:i,y:r,z:o}=n,c=new y(i,r,o);c.applyMatrix4(e.object.matrixWorld),s.push(c)}return s}}class ze extends Map{constructor(e,s){super(s);a(this,"tracker",null);a(this,"localId");a(this,"guard",()=>!0);this.localId=e}get object(){const e={};for(const[s,n]of this.entries())e[s]=n.value;return e}set(e,s){if(!(this.guard??(()=>!0))(e,s))return this;const r=s.type!==void 0?s:{value:s.value,type:this.getType(e)};if(!this.tracker)return super.set(e,r);if(this.localId===null)return console.warn("Item attributes are missing a valid localId. Changes can't be tracked."),super.set(e,r);let o=this.tracker.get(this.localId);return o||(o={type:"modified",added:{},deleted:[],modified:{}},this.tracker.set(this.localId,o)),o.type==="added"?o.data[e]=r:o.type==="modified"&&(this.has(e)?o.modified[e]=r:o.deleted.includes(e)?(o.deleted=o.deleted.filter(c=>c!==e),o.modified[e]=r):o.added[e]=r),super.set(e,r)}setValue(e,s){return this.set(e,{value:s,type:this.getType(e)})}setType(e,s){const n=this.getValue(e);return n?this.set(e,{value:n,type:s}):this}delete(e){if(!this.tracker)return super.delete(e);const s=this.get("localId");if(s===void 0||typeof s!="number")return console.warn("Item attributes are missing a valid localId. Changes can't be tracked."),e==="localId"?!1:super.delete(e);if(e==="localId"||!this.has(e))return!1;let n=this.tracker.get(s);return n||(n={type:"modified",added:{},deleted:[],modified:{}},this.tracker.set(s,n)),n.type==="added"?delete n.data[e]:n.type==="modified"&&(e in n.added?delete n.added[e]:(e in n.modified&&delete n.modified[e],n.deleted.push(e))),super.delete(e)}getValue(e){const s=this.get(e);return s?s.value:null}getType(e){var s;return(s=this.get(e))==null?void 0:s.type}}class Be extends Map{constructor(e,s){super(s);a(this,"tracker",null);a(this,"localId");a(this,"guard",()=>!0);a(this,"onItemsRequested",null);this.localId=e}get itemChanges(){if(!this.tracker)return null;if(!this.localId)return console.warn("Item relations can't be tracked."),null;let e=this.tracker.get(this.localId);return e||(e={type:"modified",added:{},deleted:new Set,removed:{},modified:{}},this.tracker.set(this.localId,e)),e}set(e,s){const n=this.has(e);if(!(this.guard??(()=>!0))(e,s))return this;const o=this.itemChanges;return o?(n?o.modified[e]=s:o.added[e]=s,super.set(e,s)):super.set(e,s)}add(e,s){var o;const n=this.has(e);let i=this.get(e);if(!i)return i=new Set([s]),this.set(e,i),!0;if(!i||i.has(s))return!1;const r=this.itemChanges;if(!r)return i.add(s),!0;if(n)if((o=r.removed[e])!=null&&o.has(s))r.removed[e].delete(s),r.removed[e].size===0&&delete r.removed[e];else{let c=r.modified[e];c||(c=new Set,r.modified[e]=c),c.add(s)}else{let c=r.added[e];c||(c=new Set,r.added[e]=c),c.add(s)}return i.add(s),!0}remove(e,s){var r;const n=this.get(e);if(!n||!n.has(s))return!1;const i=this.itemChanges;if(!i)return n.delete(s);if((r=i.modified[e])!=null&&r.has(s))i.modified[e].delete(s),i.modified[e].size===0&&delete i.modified[e];else{let o=i.removed[e];o||(o=new Set,i.removed[e]=o),o.add(s)}return n.delete(s)}delete(e){if(!this.has(e))return!1;const s=this.itemChanges;return s?(s.deleted.add(e),super.delete(e)):super.delete(e)}async getItems(e){if(!this.onItemsRequested)return null;const s=this.get(e);return s?await this.onItemsRequested([...s]):null}}class Fe{constructor(t,e){a(this,"model");a(this,"localId");a(this,"_indices",null);a(this,"_transform",null);a(this,"_normals",null);a(this,"_positions",null);a(this,"_vertices",null);a(this,"_triangles",null);a(this,"_position",null);a(this,"_box",null);this.model=t,this.localId=e}async get(){const[t]=await this.model.threads.invoke(this.model.modelId,"getItemsGeometry",[[this.localId]]);for(const e of t){e.transform=new K().fromArray(e.transform.elements);const{indices:s,normals:n,positions:i,transform:r}=e;this._indices||(this._indices=[]),this._normals||(this._normals=[]),this._positions||(this._positions=[]),this._transform||(this._transform=[]),this._indices.push(s),this._normals.push(n),this._positions.push(i),this._transform.push(r)}return t}async getIndices(){return this._indices!==null?this._indices:(await this.get(),this._indices)}async getTransform(){return this._transform!==null?this._transform:(await this.get(),this._transform)}async getNormals(){return this._normals!==null?this._normals:(await this.get(),this._normals)}async getPositions(){return this._positions!==null?this._positions:(await this.get(),this._positions)}async getVertices(){if(this._vertices)return this._vertices;const t=await this.getPositions(),e=await this.getTransform();if(!t||!e)return this._vertices;this._vertices=[];for(let s=0;s<t.length;s++){const n=t[s],i=e[s];if(!n||!i)continue;const r=[];this._vertices.push(r);const o=Object.keys(n).length/3,c=[];for(let d=0;d<o;d++){const u=n[d*3],l=n[d*3+1],f=n[d*3+2];if(typeof u!="number"||typeof l!="number"||typeof f!="number")continue;const p=`${u},${l},${f}`;if(c.includes(p))continue;c.push(p);const h=new y(u,l,f);h.applyMatrix4(i),r.push(h)}}return this._vertices}async getTriangles(){if(this._triangles)return this._triangles;const t=await this.getIndices(),e=await this.getPositions(),s=await this.getTransform();if(!t||!e||!s)return this._triangles;this._triangles=[];for(let n=0;n<t.length;n++){const i=t[n],r=e[n],o=s[n];if(!i||!r||!o)continue;const c=[];this._triangles.push(c);for(let d=0;d<i.length;d+=3){const u=i[d],l=i[d+1],f=i[d+2],p=new y(r[u*3],r[u*3+1],r[u*3+2]),h=new y(r[l*3],r[l*3+1],r[l*3+2]),m=new y(r[f*3],r[f*3+1],r[f*3+2]);p.applyMatrix4(o),h.applyMatrix4(o),m.applyMatrix4(o),c.push(new $t(p,h,m))}}return this._triangles}async getPosition(){if(!this._position){if(this.localId===null)return null;this._position=await this.model.getPositions([this.localId])}return this._position}async getBox(){if(!this._box){if(this.localId===null)return null;this._box=await this.model.getBoxes([this.localId])}return this._box}async setVisibility(t){await this.model.setVisible([this.localId],t)}async getVisibility(){const[t]=await this.model.getVisible([this.localId]);return t}}class Oe{constructor(t,e){a(this,"model");a(this,"_localId",null);a(this,"_attributes",null);a(this,"_relations",null);a(this,"_guid",null);a(this,"_category",null);a(this,"_geometry",null);this.model=t,typeof e=="number"&&(this._localId=e),typeof e=="string"&&(this._guid=e)}async getLocalId(){if(!this._localId)if(this._guid)[this._localId]=await this.model.threads.invoke(this.model.modelId,"getLocalIdsByGuids",[[this._guid]]);else throw new Error("Fragments: Item localId couldn't be get.");return this._localId}async getAttributes(){if(this._attributes)return this._attributes;const t=await this.getLocalId();if(t===null)return null;const e=await this.model.threads.invoke(this.model.modelId,"getItemAttributes",[t]);if(this._attributes=new ze(t),!e){const n=this.model.attrsChanges.get(t);if(!(n&&n.type==="added"))return null;this._attributes.localId=t;for(const[i,r]of Object.entries(n.data))this._attributes.set(i,r);return this._attributes}const s=this.model.attrsChanges.get(t);if(s&&s.type==="modified")for(const[n,i]of Object.entries(s.added))this._attributes.set(n,i);for(const n in e){const{value:i,type:r}=e[n];(s==null?void 0:s.type)==="modified"&&s.deleted.includes(n)||((s==null?void 0:s.type)==="modified"&&n in s.modified?this._attributes.set(n,s.modified[n]):this._attributes.set(n,{value:i,type:r}))}return this._attributes.tracker=this.model.attrsChanges,this._attributes}async getRelations(){if(this._relations)return this._relations;const t=await this.getLocalId();if(t===null)return null;const e=await this.model.threads.invoke(this.model.modelId,"getItemRelations",[t]);if(!e)return null;this._relations=new Be(t),this._relations.onItemsRequested=async n=>{const i=[];for(const r of n){const o=this.model.getItem(r);o&&i.push(o)}return i};const s=this.model.relsChanges.get(t);if(s&&s.type==="modified")for(const[n,i]of Object.entries(s.added))this._relations.set(n,i);for(const[n,i]of Object.entries(e))if(!((s==null?void 0:s.type)==="modified"&&s.deleted.has(n)))if((s==null?void 0:s.type)==="modified"&&n in s.modified){const r=new Set([...s.modified[n],...i]);this._relations.set(n,new Set(r))}else this._relations.set(n,new Set(i));return this._relations.tracker=this.model.relsChanges,this._relations}async getGuid(){if(!this._guid){const t=await this.getLocalId();if(t===null)return null;[this._guid]=await this.model.threads.invoke(this.model.modelId,"getGuidsByLocalIds",[[t]])}return this._guid}async getCategory(){if(!this._category){const t=await this.getLocalId();if(t===null)return null;this._category=await this.model.threads.invoke(this.model.modelId,"getItemCategory",[t])}return this._category}async getGeometry(){if(this._geometry)return this._geometry;const t=await this.getLocalId();return t===null?null:new Fe(this.model,t)}async getData(t=[]){var o;const e=await this.getLocalId();if(e==null)return{};t.push(e);const s=(o=await this.getAttributes())==null?void 0:o.object,n=await this.getRelations(),i={};if(n)for(const c of n.keys()){const d=[];i[c]=d;const u=await n.getItems(c);if(u)for(const l of u){const f=await l.getLocalId();if(!f||t.find(h=>h===f)!==void 0)continue;t.push(f);const p=await l.getData(t);p&&d.push(p)}}return{...s,...i}}}class Ue{getItem(t,e){return new Oe(t,e)}async getItemsData(t,e,s){return t.threads.invoke(t.modelId,"getItemsData",[e,s])}async getItemsChildren(t,e){return t.threads.invoke(t.modelId,"getItemsChildren",[e])}}class Ge{constructor(){a(this,"getClippingPlanesEvent",()=>[]);a(this,"currentCamera",null);a(this,"_tempMatrix",new K);a(this,"_tempVec",new y);a(this,"_tempFrustum",new ct);a(this,"_updateCameraPositionEvent",()=>{});a(this,"_updateCameraFrustumEvent",()=>{});a(this,"_updateFOVEvent",()=>{});a(this,"_updateOrthoSizeEvent",()=>{})}async refreshView(t,e){const s=this.setup(e,t),n=te.transform(this._tempFrustum,this._tempMatrix),i=this.newViewRequest(n,s,t);await t.threads.fetch(i)}useCamera(t){const e=new K;this.setCameraPosition(t),this.setCameraFrustum(t,e),this.setFov(t),this.setOrtho(),this.currentCamera=t}getOrthoSize(){let t=this._updateOrthoSizeEvent();if(t){const e=this._tempMatrix.getMaxScaleOnAxis();t*=e}return t}setup(t,e){return t.requests.clean(e.modelId),this._tempMatrix.copy(e.object.matrixWorld).invert(),this._updateCameraPositionEvent(this._tempVec),this._updateCameraFrustumEvent(this._tempFrustum),this._updateFOVEvent()}newViewRequest(t,e,s){const n=this.newView(t,e,s),i={};return i.class=V.REFRESH_VIEW,i.modelId=s.modelId,i.cameraFrustum=t,i.view=n,i}newView(t,e,s){const n={};return n.cameraFrustum=t,n.cameraPosition=this._tempVec.applyMatrix4(this._tempMatrix),n.fov=e,n.orthogonalDimension=this.getOrthoSize(),n.viewSize=Math.max(window.innerWidth,window.innerHeight),n.graphicThreshold=ee.estimateCapacity(),n.graphicQuality=s.graphicsQuality*-1.5+2,n.clippingPlanes=this.getPlanes(),n.modelPlacement=s.object.matrixWorld,n}setOrtho(){this._updateOrthoSizeEvent=()=>{}}setFov(t){this._updateFOVEvent=()=>{if(t instanceof me)return t.fov}}getPlanes(){const t=[],e=this.getClippingPlanesEvent();for(const s of e){const n=s.clone();n.applyMatrix4(this._tempMatrix),t.push(n)}return t}setCameraPosition(t){this._updateCameraPositionEvent=e=>{e.copy(t.position)}}setCameraFrustum(t,e){this._updateCameraFrustumEvent=s=>{t.updateProjectionMatrix(),t.updateWorldMatrix(!0,!0);const{projectionMatrix:n,matrixWorldInverse:i}=t;e.multiplyMatrices(n,i),s.setFromProjectionMatrix(e)}}}class Ne{constructor(){a(this,"_caster",new pe);a(this,"_ray",new Zt);a(this,"_frustum",new ct);a(this,"_inverseTransform",new K);a(this,"_t",new W);a(this,"_r",new W);a(this,"_b",new W);a(this,"_l",new W);a(this,"_n",new W);a(this,"_f",new W);a(this,"_tl",new y);a(this,"_tr",new y);a(this,"_bl",new y);a(this,"_br",new y);a(this,"_tln",new y);a(this,"_brn",new y);a(this,"_tlp",new rt);a(this,"_brp",new rt);a(this,"distance",10)}async raycast(t,e){const{frustum:s,ray:n}=this.getRayAndFrustum(e),i=this.getRequest(t,s,n);if(!i)return null;const r=await t.threads.fetch(i);if(r.results&&r.results.length){const[o]=r.results;return this.getResult({hit:o,frustum:s,ray:n,model:t})}return null}async rectangleRaycast(t,e,s){const n=this.getFrustum(s),i=this.getRequest(t,n);if(!i)return null;i.fullyIncluded=s.fullyIncluded;const r=await t.threads.fetch(i);return r.localIds&&r.localIds.length?this.newRectangleCastResponse(r,e):null}async raycastWithSnapping(t,e){const{frustum:s,ray:n}=this.getRayAndFrustum(e),i=this.getRequest(t,s,n);if(!i)return null;i.snappingClass=e.snappingClasses;const r=await t.threads.fetch(i);return r.results?this.newRaycastSnapResult(r,s,n,t):null}screenRectToFrustum(t,e,s,n){return this.screenToCast(t,s,this._tlp),this.screenToCast(e,s,this._brp),this.setVectors(n),this.setPlanes(n),this.newFrustum()}screenToCasterPoint(t,e,s){const n=this.screenToCast(t,e);return this._caster.setFromCamera(n,s),this._caster.ray.clone()}setPlanes(t){this.setBasePoints(),t.getWorldDirection(this._n.normal),this.setEnds(t)}setVectors(t){this.setVector(this._tl,this._tlp,this._tlp,1,t),this.setVector(this._tr,this._brp,this._tlp,1,t),this.setVector(this._bl,this._tlp,this._brp,1,t),this.setVector(this._br,this._brp,this._brp,1,t),this.setVector(this._tln,this._tlp,this._tlp,0,t),this.setVector(this._brn,this._brp,this._brp,0,t)}newFrustum(){return new ct(this._t,this._b,this._l,this._r,this._f,this._n)}setEnds(t){this._n.constant=t.position.length(),this._f.normal=this._n.normal,this._f.constant=1/0}screenToCast(t,e,s=new rt){const n=e.getBoundingClientRect(),i=n.width/e.clientWidth,r=n.height/e.clientHeight,o=(t.x-n.left)/i,c=(t.y-n.top)/r;return s.x=o/e.clientWidth*2-1,s.y=-(c/e.clientHeight)*2+1,s}setVector(t,e,s,n,i){t.set(e.x,s.y,n),t.unproject(i)}setPlane(t,e,s,n){t.setFromCoplanarPoints(e,s,n)}setBasePoints(){this.setPlane(this._t,this._tln,this._tl,this._tr),this.setPlane(this._r,this._brn,this._tr,this._br),this.setPlane(this._b,this._brn,this._br,this._bl),this.setPlane(this._l,this._tln,this._bl,this._tl)}setupRay(t,e){t&&(this._ray.copy(t),this._ray.applyMatrix4(this._inverseTransform),e.ray=this._ray)}setupMatrix(t){this._inverseTransform.copy(t.matrixWorld),this._inverseTransform.invert()}getRequest(t,e,s){const{object:n,box:i,modelId:r}=t;return e.intersectsBox(i)?this.newCastRequest(n,r,s,e):null}getRayAndFrustum(t){this.updateCamera(t.camera);const{bottomLeft:e,topRight:s}=this.getCorners(t.mouse),n=this.screenToCasterPoint(t.mouse,t.dom,t.camera),i=this.screenRectToFrustum(e,s,t.dom,t.camera);return{ray:n,frustum:i}}getFrustum(t){return this.updateCamera(t.camera),this.screenRectToFrustum(t.topLeft,t.bottomRight,t.dom,t.camera)}getCorners(t){const e=t.clone().subScalar(this.distance),s=t.clone().addScalar(this.distance);return{bottomLeft:e,topRight:s}}getResult(t){const{hit:e,frustum:s,ray:n,model:i}=t,r={};return this.setPoint(i,e,r),this.setNormal(i,e,r),this.setDistance(i,e,r),this.setRayDistance(i,e,r),this.setBasicHitData(i,e,r,n,s),this.setSnapEdge(i,e,r,"snappedEdgeP1"),this.setSnapEdge(i,e,r,"snappedEdgeP2"),r.facePoints=e.facePoints,r.faceIndices=e.faceIndices,r}updateCamera(t){t.updateProjectionMatrix(),t.updateWorldMatrix(!0,!0)}newCastRequest(t,e,s,n){this.setupMatrix(t);const i={};return i.class=V.RAYCAST,i.modelId=e,this.setupRay(s,i),te.transform(n,this._inverseTransform,this._frustum),i.frustum=this._frustum,i}setSnapEdge(t,e,s,n){if(e[n]){const i=new y;i.copy(e[n]),i.applyMatrix4(t.object.matrixWorld),s[n]=i}else s[n]=void 0}setNormal(t,e,s){if(e.normal){const n=new y;n.copy(e.normal),n.transformDirection(t.object.matrixWorld),n.normalize(),s.normal=n;return}s.normal=void 0}setDistance(t,e,s){const n=Math.sqrt(e.cameraSquaredDistance),i=t.object.matrixWorld.getMaxScaleOnAxis();s.distance=n*i}setPoint(t,e,s){const n=new y;n.copy(e.point),n.applyMatrix4(t.object.matrixWorld),s.point=n}newRaycastSnapResult(t,e,s,n){const i=[];for(const r of t.results){const o=this.getResult({hit:r,frustum:e,ray:s,model:n});i.push(o)}return i}newRectangleCastResponse(t,e){return{localIds:t.localIds,fragments:e.list.get(t.modelId)}}setRayDistance(t,e,s){if(e.raySquaredDistance!==void 0){const n=t.object.matrixWorld.getMaxScaleOnAxis(),i=Math.sqrt(e.raySquaredDistance);s.rayDistance=i*n;return}s.rayDistance=void 0}setBasicHitData(t,e,s,n,i){s.itemId=e.itemId,s.localId=e.localId,s.object=t.object,s.fragments=t,s.ray=n,s.frustum=i,s.representationClass=e.representationClass,s.snappingClass=e.snappingClass}}class Ve{async resetVisible(t){await t.threads.invoke(t.modelId,"resetVisible")}async getItemsByVisibility(t,e){return t.threads.invoke(t.modelId,"getItemsByVisibility",[e])}async getVisible(t,e){return t.threads.invoke(t.modelId,"getVisible",[e])}}class Wt extends ${constructor(e,s){super(e,s);a(this,"geometry");a(this,"material");this.geometry=e,this.material=s,O.setupLodMeshResize(this)}}class je extends Yt{constructor(){super();a(this,"isLODGeometry",!0);O.setupLodAttributes(this)}isFiltered(){return!!this.getItemFilter()}computeBoundingBox(){this.boundingBox||(this.boundingBox=new Y),O.computeLodBox(this)}applyMatrix4(e){return this.applyTransformToBuffers(e),this.updateBounds(),this}computeBoundingSphere(){this.boundingSphere||(this.boundingSphere=new vt),O.computeLodSphere(this)}getItemFilter(){return O.getInstancedAttribute(this,"itemFilter")}getItemLast(){return O.getInterAttribute(this,"itemLast")}getItemFirst(){return O.getInterAttribute(this,"itemFirst")}applyTransformToBuffers(e){this.getItemFirst().applyMatrix4(e),this.getItemLast().applyMatrix4(e)}updateBounds(){this.boundingBox&&this.computeBoundingBox(),this.boundingSphere&&this.computeBoundingSphere()}}class He extends Xt{constructor(e){super(O.newLodMaterialParams(e));a(this,"isLodMaterial",!0);a(this,"isLineMaterial",!0);this.clipping=!0,this.lights=!1,this.needsUpdate=!0}get lodSize(){return this.uniforms.lodSize.value}set lodColor(e){this.uniforms.lodColor.value=e}set lodSize(e){this.uniforms.lodSize.value.copy(e)}get lodColor(){return this.uniforms.lodColor.value}}class qt{constructor(){a(this,"list",new Lt);a(this,"_modelMaterialMapping",new Map);a(this,"_definitions",new Map);a(this,"_idGenerator",new Dt);a(this,"white",4294967295)}static resetColors(t){for(const e of t){if(!(e&&e.color))continue;const{color:s}=e;if(s.isColor)continue;const{r:n,g:i,b:r}=s;e.color=new Rt(n,i,r)}}dispose(t){this._definitions.delete(t);const e=this._modelMaterialMapping.get(t);if(e){for(const s of e){const n=this.list.get(s);n&&(n.dispose(),this.list.delete(s))}this._modelMaterialMapping.delete(t)}}get(t,e){const{modelId:s,objectClass:n,currentLod:i,templateId:r}=e;if(!(s&&n!==void 0&&i!==void 0))throw new Error("Fragments: material definition information is missing to create the material.");this._idGenerator.fromMaterialData({modelId:s,objectClass:n,currentLod:i,templateId:r,...t});const{value:o}=this._idGenerator;return this.getUniqueMaterial(o,t,e)}addDefinitions(t,e){const s=this._definitions.get(t);s?s.push(...e):this._definitions.set(t,e)}createHighlights(t,e){const{tileData:{highlightData:s,highlightIds:n},modelId:i,material:r}=e,{geometry:o}=t,c=t.material.slice(0,2),d=new Map,u=this._definitions.get(i);if(!u)return c;for(let l=0;l<s.position.length;l++){const f=n[l];this.processHighlight(d,f,u,r,e,c);const p=s.position[l],h=s.size[l],w=h===this.white?1/0:h;o.addGroup(p,w,d.get(n[l]))}return c}getFromRequest(t){const{material:e,modelId:s}=t,n=this._definitions.get(s),i=n==null?void 0:n[e];if(!i)throw new Error(`Fragments: Missing mesh material for index ${e}`);return this.get(i,t)}newLODMaterial(t,e){const{data:s}=t,n=new Rt(s.color);e.currentLod===Mt.WIRES&&n.multiplyScalar(.85);const i={color:n,...this.getParameters(s)},r=new He(i);return r.userData={customId:s.customId},r}getParameters(t){const{opacity:e,transparent:s}=t,n=e<1;return{opacity:e,transparent:s||n,clipIntersection:!1}}new(t,e){const{objectClass:s,templateId:n}=e;let i;if(s===yt.SHELL)i=new Kt({color:t.color,transparent:t.opacity<1,opacity:t.opacity,userData:{customId:t.customId,localId:t.localId},depthTest:t.depthTest??!0,side:t.renderedFaces===1?Jt:ge});else if(s===yt.LINE)i=this.newLODMaterial({data:t,instancing:n!==void 0},e);else throw new Error("Fragments: Unsupported object class");return i}addMaterialToModel(t,e){let s=this._modelMaterialMapping.get(t);s||(s=new Set,this._modelMaterialMapping.set(t,s)),s.add(e)}processHighlight(t,e,s,n,i,r){if(!t.has(e)){const o=s[n],c=s[e],d={...o,...c},u=this.get(d,i);r.push(u),t.set(e,r.length-1)}}getUniqueMaterial(t,e,s){const n=s.modelId,i=this.list.get(t);if(i)return i;const r=this.new(e,s);return this.list.set(t,r),this.addMaterialToModel(n,t),this.list.get(t)}}class ke{async getHighlight(t,e){const s=await t.threads.invoke(t.modelId,"getHighlight",[e]);return qt.resetColors(s),s}async highlight(t,e,s){await t.threads.invoke(t.modelId,"highlight",[e,s])}async getHighlightItemIds(t){return t.threads.invoke(t.modelId,"getHighlightItemIds")}async resetHighlight(t,e){await t.threads.invoke(t.modelId,"resetHighlight",[e])}}class We{async getSection(t,e,s){const n=[e,s];return await t.threads.invoke(t.modelId,"getSection",n)}}class $e{async dispose(t,e,s){e.list.delete(t.modelId),await this.requestModelDelete(t),t.threads.delete(t.modelId),t.object.removeFromParent(),this.deleteAllTiles(t),e.materials.dispose(t.modelId),s.dispose()}async getBuffer(t,e){return t.threads.invoke(t.modelId,"getBuffer",[e])}async getCategories(t){return t.threads.invoke(t.modelId,"getCategories")}async getMaxLocalId(t){return t.threads.invoke(t.modelId,"getMaxLocalId")}async getLocalIdsByGuids(t,e){return t.threads.invoke(t.modelId,"getLocalIdsByGuids",[e])}async getSpatialStructure(t){return t.threads.invoke(t.modelId,"getSpatialStructure")}async getItemsWithGeometry(t){return(await t.threads.invoke(t.modelId,"getItemsWithGeometry",[])).map(n=>t.getItem(n))}async getItemsWithGeometryCategories(t){return t.threads.invoke(t.modelId,"getItemsWithGeometryCategories",[])}async getItemsIdsWithGeometry(t){return t.threads.invoke(t.modelId,"getItemsWithGeometry",[])}async getItemsOfCategories(t,e){const s=[e];return await t.threads.invoke(t.modelId,"getItemsOfCategories",s)}async getItemsByQuery(t,e,s){const n=[e,s];return await t.threads.invoke(t.modelId,"getItemsByQuery",n)}async getMetadata(t){return t.threads.invoke(t.modelId,"getMetadata",[])}async getGuidsByLocalIds(t,e){return t.threads.invoke(t.modelId,"getGuidsByLocalIds",[e])}async requestModelDelete(t){await t.threads.fetch({class:V.DELETE_MODEL,modelId:t.modelId})}deleteAllTiles(t){for(const[e]of t.tiles)t.tiles.delete(e)}}class Ye{async getSequenced(t,e,s,n){const i=[e,s,n];return await t.threads.invoke(t.modelId,"getSequenced",i)}}class Xe{constructor(t,e){a(this,"_deltaModels",{});a(this,"_fragments");a(this,"_connection");this._fragments=t,this._connection=e}async edit(t,e,s={removeRedo:!0}){const n=this._fragments.models.list.get(t);if(!n)throw new Error(`Model ${t} not found`);const i=this._deltaModels[t]||[];this._deltaModels[t]=null,s.removeRedo&&n._setRequests({undoneRequests:[]});const{deltaModelBuffer:r,ids:o}=await n._edit(e);for(let u=0;u<e.length;u++)e[u].localId===void 0&&(e[u].localId=o[u]);const c=await this.load(r,n);this._deltaModels[t]=[c],n.deltaModelId=c.modelId;const d=[];for(const u of i)d.push(u.dispose());return await Promise.all(d),o}async save(t){const e=this._fragments.models.list.get(t);if(!e)return console.log(`Model ${t} not found`),null;const s=e.object.parent,n=await e._getRequests(),i=e.camera||void 0,r=await e._save();await e.dispose();const o=await this._fragments.load(r,{modelId:t,raw:!0,camera:i});return await o._setRequests({undoneRequests:n.undoneRequests}),s&&s.add(o.object),n}async reset(t){const e=this._fragments.models.list.get(t);if(!e){console.log(`Model ${t} not found`);return}await e._reset(),await this.disposeDeltaModels(t)}async getRequests(t){const e=this._fragments.models.list.get(t);if(!e)throw new Error(`Model ${t} not found`);return e._getRequests()}async selectRequest(t,e){const s=this._fragments.models.list.get(t);if(!s)throw new Error(`Model ${t} not found`);return s._selectRequest(e)}async _update(t){const e=this._deltaModels[t];if(e){const s=[];for(const n of e)s.push(n._refreshView());await Promise.all(s)}}async disposeDeltaModels(t){const e=this._deltaModels[t];if(e){for(const s of e)await s.dispose();this._deltaModels[t]=[]}}async load(t,e){const s=Ct.DELTA_MODEL_ID,n=`${e.modelId}${s}${performance.now()}`,i=new _t(n,this._fragments.models,this._connection,this._fragments.editor);i._setDeltaModel(e.modelId),i.frozen=!0,i.graphicsQuality=this._fragments.settings.graphicsQuality;try{this._fragments.models.list.set(i.modelId,i),await i._setup(t,!0),e.object.add(i.object)}catch(o){throw this._fragments.models.list.delete(i.modelId),o}const r=e.camera;return r&&i.useCamera(r),i.frozen=!1,i}}class Qe{constructor(t){a(this,"_nextTempIds",{});a(this,"_requests",{});a(this,"_fragments");this._fragments=t}getRequests(t){const e=this.getModelRequests(t);this._requests[t]=this.newRequests();const{create:s,update:n,remove:i,relations:{create:r,update:o,remove:c}}=e,d=Object.values(s),u=Object.values(n),l=Object.values(i),f=Object.values(r),p=Object.values(o),h=Object.values(c),m=[...l,...d,...u,...f,...p,...h];return m.length>0?m:null}createMaterial(t,e){const s=this.getNextTempId(t),n={r:e.color.r*255,g:e.color.g*255,b:e.color.b*255,a:e.opacity*255,renderedFaces:e.side===Jt?1:0,stroke:0};return this.addRequest(t,s,"create",{type:I.CREATE_MATERIAL,tempId:s,data:n}),s}createLocalTransform(t,e){const s=this.getNextTempId(t),n=R.transformFromMatrix(e);return this.addRequest(t,s,"create",{type:I.CREATE_LOCAL_TRANSFORM,tempId:s,data:n}),s}createShell(t,e){const s=this.getNextTempId(t),n=R.representationFromGeometry(e);return this.addRequest(t,s,"create",{type:I.CREATE_REPRESENTATION,tempId:s,data:n}),s}createCircleExtrusion(t,e){const s=R.bboxFromCircleExtrusion(e),n=this.getNextTempId(t);return this.addRequest(t,n,"create",{type:I.CREATE_REPRESENTATION,tempId:n,data:{representationClass:et.CIRCLE_EXTRUSION,bbox:s,geometry:e}}),n}createGlobalTransform(t,e,s){const n=this.getNextTempId(t),i=R.transformFromMatrix(e);return this.addRequest(t,n,"create",{type:I.CREATE_GLOBAL_TRANSFORM,tempId:n,data:{itemId:s,...i}}),n}createSample(t,e){const{localTransform:s,representation:n,material:i,globalTransform:r}=e,o=this.getNextTempId(t);return this.addRequest(t,o,"create",{type:I.CREATE_SAMPLE,tempId:o,data:{localTransform:s,representation:n,material:i,item:r}}),o}createItem(t,e){const s=this.getNextTempId(t);return this.addRequest(t,s,"create",{type:I.CREATE_ITEM,tempId:s,data:e}),s}setItem(t,e){const s=e._localId;if(!s)throw new Error("No local id provided for the item to set");const n=s.value,i=Ct.itemDataToRawItemData(e);this.addRequest(t,s.value,"update",{type:I.UPDATE_ITEM,localId:n,data:i})}async relate(t,e,s,n){const i=this._fragments.models.list.get(t);if(!i)throw new Error(`Model ${t} not found`);const o=(await i.getRelations([e])).get(e);if(!o){this.addRelationRequest(t,e,"create",{type:I.CREATE_RELATION,localId:e,data:{data:{[s]:n}}});return}if(!o.data[s])o.data[s]=n;else{const c=new Set(o.data[s]);for(const d of n)c.add(d);o.data[s]=Array.from(c)}this.addRelationRequest(t,e,"update",{type:I.UPDATE_RELATION,localId:e,data:o})}async unrelate(t,e,s,n){const i=this._fragments.models.list.get(t);if(!i)throw new Error(`Model ${t} not found`);const o=(await i.getRelations([e])).get(e);if(!o||!o.data[s])return;const c=new Set(o.data[s]);for(const d of n)c.delete(d);o.data[s]=Array.from(c),this.addRelationRequest(t,e,"update",{type:I.UPDATE_RELATION,localId:e,data:o})}async get(t,e){const s=this._fragments.models.list.get(t);if(!s)throw new Error(`Model ${t} not found`);return s._getElements(e)}async create(t,e){for(const o of e){const{attributes:c,samples:d,globalTransform:u}=o,l=this.getNextTempId(t),f=Ct.itemDataToRawItemData(c);this.addRequest(t,l,"create",{type:I.CREATE_ITEM,tempId:l,data:f});const p=this.createGlobalTransform(t,u,l);for(const h of d){const{localTransform:m,representation:w,material:_}=h;let M;typeof m!="number"&&typeof m!="string"?M=this.createLocalTransform(t,m):M=m;let x;typeof w!="number"&&typeof w!="string"?x=this.createShell(t,w):x=w;let v;typeof _!="number"&&typeof _!="string"?v=this.createMaterial(t,_):v=_,this.createSample(t,{localTransform:M,representation:x,material:v,globalTransform:p})}}const s=this.getRequests(t);if(!s)return console.log("Something went wrong, no requests sent"),null;const n=[];for(let o=0;o<s.length;o++)s[o].type===I.CREATE_ITEM&&n.push(o);const i=await this._fragments.editor.edit(t,s),r=n.map(o=>i[o]);return this.get(t,r)}delete(t,e){for(const s of e){s.delete();const n=s.getRequests();if(n)for(const i of n){const r=i.localId;r&&this.addRequest(t,r,"remove",i)}}}async applyChanges(t,e=[]){const s=[];for(const i of e){const r=i.getRequests();r&&s.push(...r)}const n=this.getRequests(t);return n&&s.push(...n),s.length>0?this._fragments.editor.edit(t,s):[]}async deleteData(t,e){const s=this._fragments.models.list.get(t);if(!s)throw new Error(`Model ${t} not found`);const n=e.filterInUse??!0,{itemIds:i,materialIds:r,localTransformIds:o,representationIds:c,sampleIds:d}=e,u=new Set,l=new Set,f=new Set,p=new Set;if(n){const h=await s.getSamples();for(const m of h.values())u.add(m.material),l.add(m.localTransform),f.add(m.item),p.add(m.representation)}if(r)for(const h of r){if(n&&u.has(h)){console.log(`Material ${h} is used, skipping`);continue}if(this.isBeingCreated(t,h)){delete this._requests[t].create[h];continue}this.addRequest(t,h,"remove",{type:I.DELETE_MATERIAL,localId:h})}if(o)for(const h of o){if(n&&l.has(h)){console.log(`Local transform ${h} is used, skipping`);continue}if(this.isBeingCreated(t,h)){delete this._requests[t].create[h];continue}this.addRequest(t,h,"remove",{type:I.DELETE_LOCAL_TRANSFORM,localId:h})}if(c)for(const h of c){if(n&&p.has(h)){console.log(`Representation ${h} is used, skipping`);continue}if(this.isBeingCreated(t,h)){delete this._requests[t].create[h];continue}this.addRequest(t,h,"remove",{type:I.DELETE_REPRESENTATION,localId:h})}if(d)for(const h of d){if(this.isBeingCreated(t,h)){delete this._requests[t].create[h];continue}this.addRequest(t,h,"remove",{type:I.DELETE_SAMPLE,localId:h})}if(i)for(const h of i){if(this.isBeingCreated(t,h)){delete this._requests[t].create[h];continue}this.addRequest(t,h,"remove",{type:I.DELETE_ITEM,localId:h})}}getNextTempId(t){return this._nextTempIds[t]||(this._nextTempIds[t]=0),(this._nextTempIds[t]++).toString()}addRelationRequest(t,e,s,n){const o=this.getModelRequests(t).relations[s],c=e;o[c]=n}addRequest(t,e,s,n){const r=this.getModelRequests(t)[s],o=e;r[o]=n}getModelRequests(t){return this._requests[t]||(this._requests[t]=this.newRequests()),this._requests[t]}isBeingCreated(t,e){return this._requests[t]?this._requests[t].create[e]!==void 0:!1}newRequests(){return{update:{},create:{},remove:{},relations:{create:{},update:{},remove:{}}}}}class Ze{constructor(t,e){a(this,"onEdit",new k);a(this,"_editHelper");a(this,"_elementsHelper");this._editHelper=new Xe(t,e),this._elementsHelper=new Qe(t)}async edit(t,e,s={removeRedo:!0}){const n=await this._editHelper.edit(t,e,s);return this.onEdit.trigger(),n}async save(t){return this._editHelper.save(t)}async reset(t){await this._editHelper.reset(t)}async getModelRequests(t){return this._editHelper.getRequests(t)}async selectRequest(t,e){return this._editHelper.selectRequest(t,e)}clearElementsRequests(t){return this._elementsHelper.getRequests(t)}createMaterial(t,e){return this._elementsHelper.createMaterial(t,e)}createLocalTransform(t,e){return this._elementsHelper.createLocalTransform(t,e)}createShell(t,e){return this._elementsHelper.createShell(t,e)}createCircleExtrusion(t,e){return this._elementsHelper.createCircleExtrusion(t,e)}createGlobalTransform(t,e,s){return this._elementsHelper.createGlobalTransform(t,e,s)}createSample(t,e){return this._elementsHelper.createSample(t,e)}createItem(t,e){return this._elementsHelper.createItem(t,e)}setItem(t,e){return this._elementsHelper.setItem(t,e)}async relate(t,e,s,n){return this._elementsHelper.relate(t,e,s,n)}async unrelate(t,e,s,n){return this._elementsHelper.unrelate(t,e,s,n)}async getElements(t,e){return this._elementsHelper.get(t,e)}async createElements(t,e){return this._elementsHelper.create(t,e)}deleteElements(t,e){return this._elementsHelper.delete(t,e)}async applyChanges(t,e=[]){return this._elementsHelper.applyChanges(t,e)}async deleteData(t,e){return this._elementsHelper.deleteData(t,e)}async _update(t){await this._editHelper._update(t)}}class Ke{constructor(t,e,s){a(this,"localId");a(this,"model");a(this,"core");a(this,"config",{data:{attributesDefault:!0,relations:{IsDefinedBy:{attributes:!0,relations:!0},DefinesOcurrence:{attributes:!1,relations:!1}}}});a(this,"updateRequests",{});a(this,"createRequests",{});a(this,"removeRequests",{});a(this,"_elementChanged",!1);this.localId=t,this.core=e,this.model=s}get elementChanged(){return this._elementChanged}getRequests(){const t=Object.values(this.createRequests);this.createRequests={};const e=Object.values(this.updateRequests);this.updateRequests={};const s=Object.values(this.removeRequests);this.removeRequests={};const n=[...s,...t,...e];return n.length>0?n:null}delete(){this.createRequests[this.localId]?delete this.createRequests[this.localId]:this.removeRequests[this.localId]={type:I.DELETE_ITEM,localId:this.localId};for(const t in this.core.samples){const e=this.core.samples[t],s=parseInt(t,10);this.createRequests[e.localTransform]?delete this.createRequests[e.localTransform]:this.removeRequests[e.localTransform]={type:I.DELETE_LOCAL_TRANSFORM,localId:e.localTransform},this.createRequests[e.representation]?delete this.createRequests[e.representation]:this.removeRequests[e.representation]={type:I.DELETE_REPRESENTATION,localId:e.representation},this.createRequests[e.material]?delete this.createRequests[e.material]:this.removeRequests[e.material]={type:I.DELETE_MATERIAL,localId:e.material},this.createRequests[e.item]?delete this.createRequests[e.item]:this.removeRequests[e.item]={type:I.DELETE_GLOBAL_TRANSFORM,localId:e.item},this.createRequests[s]?delete this.createRequests[s]:this.removeRequests[s]={type:I.DELETE_SAMPLE,localId:s}}}async getData(){return(await this.model.getItemsData([this.localId],this.config.data))[0]}getGlobalTransformId(){return parseInt(Object.keys(this.core.globalTransforms)[0],10)}disposeMeshes(t,e){const s=(e==null?void 0:e.disposeGeometry)??!0,n=(e==null?void 0:e.disposeMaterial)??!0;t.removeFromParent(),t.traverse(i=>{i instanceof $&&(s&&i.geometry.dispose(),n&&i.material.dispose())})}async getMeshes(){const t=new nt,e=Object.values(this.core.globalTransforms)[0],s=R.matrixFromTransform(e);t.applyMatrix4(s);const n=new Map,i=new Map,r=Object.keys(this.core.representations).map(Number),o=await this.model.getGeometries(r),c=new Map;for(const d of o){const u=d.representationId;c.set(u,d)}for(const d in this.core.samples){const u=parseInt(d,10),l=this.core.samples[u],f=c.get(l.representation);if(!f)throw new Error(`No geometry found for representation ${l.representation}`);const{indices:p,positions:h,normals:m}=f;if(!p||!h||!m)continue;if(!n.has(l.material)){const{r:b,g:T,b:B,a:X}=this.core.materials[l.material],j=new Kt({color:new Rt(b/255,T/255,B/255),transparent:!0,opacity:X/255});j.userData.localId=l.material,n.set(l.material,j)}const w=n.get(l.material),_=this.core.localTransforms[l.localTransform],M=R.matrixFromTransform(_);if(!i.has(l.representation)){const b=new wt;b.setIndex(Array.from(p)),b.setAttribute("position",new Z(h,3)),b.setAttribute("normal",new Z(m,3)),b.userData.localId=l.representation,i.set(l.representation,b)}const x=i.get(l.representation),v=new nt;v.userData.localId=l.localTransform,t.add(v),v.applyMatrix4(M);const S=new $(x,w);S.userData.sampleId=u,v.add(S)}return t}async setMeshes(t){const e=await this.getMeshes();let s=!0;t.updateMatrix();const n=1e3;for(let l=0;l<t.matrix.elements.length;l++){const f=Math.trunc(t.matrix.elements[l]*n)/n,p=Math.trunc(e.matrix.elements[l]*n)/n;if(f!==p){s=!1;break}}if(!s){const l=parseInt(Object.keys(this.core.globalTransforms)[0],10),f=this.core.globalTransforms[l];R.transformFromMatrix(t.matrix,f),this._elementChanged=!0,this.updateRequests[l]={type:I.UPDATE_GLOBAL_TRANSFORM,localId:l,data:f}}const i=new Map,r=new Map;e.traverse(l=>{l instanceof $&&i.set(l.material.userData.localId,l.material)}),t.traverse(l=>{l instanceof $&&r.set(l.material.userData.localId,l.material)});for(const[l,f]of i){const p=r.get(l);if(!p)continue;const h=f.color.r,m=f.color.g,w=f.color.b,_=f.opacity,M=p.color.r,x=p.color.g,v=p.color.b,S=p.opacity,b=this.core.materials[l];b.r=M*255,b.g=x*255,b.b=v*255,b.a=S*255,(h!==M||m!==x||w!==v||_!==S)&&(this._elementChanged=!0,this.updateRequests[l]={type:I.UPDATE_MATERIAL,localId:l,data:b})}i.clear(),r.clear();const o=new Map,c=new Map;for(const l of t.children)l.updateMatrix(),c.set(l.userData.localId,l.matrix);for(const l of e.children)o.set(l.userData.localId,l.matrix);for(const[l,f]of o){const p=c.get(l);if(p&&!f.equals(p)){const h=this.core.localTransforms[l];R.transformFromMatrix(p,h),this._elementChanged=!0,this.updateRequests[l]={type:I.UPDATE_LOCAL_TRANSFORM,localId:l,data:h}}}o.clear(),c.clear();const d=new Map,u=new Map;t.traverse(l=>{if(l instanceof $){const f=l.geometry;u.set(f.userData.localId,f)}}),e.traverse(l=>{if(l instanceof $){const f=l.geometry;d.set(f.userData.localId,f)}});for(const[l,f]of d){const p=this.core.representations[l];if(p.representationClass===et.CIRCLE_EXTRUSION)continue;const h=u.get(l);if(!h)continue;let m=!0;const w=f.getAttribute("position"),_=h.getAttribute("position");if(w&&_)if(w.count===_.count){for(let M=0;M<w.array.length;M++)if(w.array[M]!==_.array[M]){m=!1;break}}else m=!1;m||(R.representationFromGeometry(h,p),this._elementChanged=!0,this.updateRequests[l]={type:I.UPDATE_REPRESENTATION,localId:l,data:p})}}createSamples(t){for(const e of t){const s=Math.trunc(performance.now());this.core.samples[s]=e,this.createRequests[s]={type:I.CREATE_SAMPLE,data:e}}}deleteSamples(t){this._elementChanged=!0;for(const e of t)Object.keys(this.core.samples).length!==1&&(delete this.core.samples[e],delete this.updateRequests[e],this.createRequests[e]?delete this.createRequests[e]:this.removeRequests[e]={type:I.DELETE_SAMPLE,localId:e})}async updateSamples(){const t=new Set(Object.keys(this.core.materials).map(Number)),e=new Set(Object.keys(this.core.localTransforms).map(Number)),s=new Set(Object.keys(this.core.globalTransforms).map(Number)),n=new Set(Object.keys(this.core.representations).map(Number)),i=new Set,r=new Set,o=new Set,c=new Set,d=new Set;for(const h in this.core.samples){const m=parseInt(h,10),w=this.core.samples[m];t.delete(w.material),s.delete(w.item),e.delete(w.localTransform),n.delete(w.representation),this.core.materials[w.material]||(d.add(m),i.add(w.material)),this.core.globalTransforms[w.item]||(d.add(m),r.add(w.item)),this.core.localTransforms[w.localTransform]||(d.add(m),o.add(w.localTransform)),this.core.representations[w.representation]||(d.add(m),c.add(w.representation))}for(const h of t)delete this.core.materials[h];for(const h of s)delete this.core.globalTransforms[h];for(const h of e)delete this.core.localTransforms[h];for(const h of n)delete this.core.representations[h];let u=new Map;i.size&&(u=await this.model.getMaterials(i));let l=new Map;r.size&&(l=await this.model.getGlobalTransforms(r));let f=new Map;o.size&&(f=await this.model.getLocalTransforms(o));let p=new Map;c.size&&(p=await this.model.getRepresentations(c));for(const[h,m]of u)this.core.materials[h]=m;for(const[h,m]of l)this.core.globalTransforms[h]=m;for(const[h,m]of f)this.core.localTransforms[h]=m;for(const[h,m]of p)this.core.representations[h]=m;for(const h of d){if(this.createRequests[h]){const m=this.createRequests[h];m.data=this.core.samples[h];continue}this._elementChanged=!0,this.updateRequests[h]={type:I.UPDATE_SAMPLE,localId:h,data:this.core.samples[h]}}}}class Je{async edit(t,e){return t.threads.invoke(t.modelId,"edit",[e])}async reset(t){return t.threads.invoke(t.modelId,"reset",[])}async save(t){return t.threads.invoke(t.modelId,"save",[])}async getItemsGeometry(t,e,s){const n=await t.threads.invoke(t.modelId,"getItemsGeometry",[e,s]),i=t.deltaModelId;if(!i)return n;const r=await t.threads.invoke(i,"getItemsGeometry",[e]),o=new Map;for(const c of n){const d=c[0].localId;o.set(d,c)}for(const c of r){const d=c[0].localId;o.set(d,c)}return Array.from(o.values())}async getGeometries(t,e){const s=await t.threads.invoke(t.modelId,"getGeometries",[e]),n=t.deltaModelId;if(!n)return s;const i=await t.threads.invoke(n,"getGeometries",[e]),r=new Map;for(const o of s){const c=o.representationId;r.set(c,o)}for(const o of i){const c=o.representationId;r.set(c,o)}return Array.from(r.values())}async getMaterialsIds(t){return t.threads.invoke(t.modelId,"getMaterialsIds",[])}async getMaterials(t,e){return t.threads.invoke(t.modelId,"getMaterials",[e])}async getSamplesIds(t){return t.threads.invoke(t.modelId,"getSamplesIds",[])}async getSamples(t,e){return t.threads.invoke(t.modelId,"getSamples",[e])}async getRepresentationsIds(t){return t.threads.invoke(t.modelId,"getRepresentationsIds",[])}async getRepresentations(t,e){return t.threads.invoke(t.modelId,"getRepresentations",[e])}async getLocalTransformsIds(t){return t.threads.invoke(t.modelId,"getLocalTransformsIds",[])}async getLocalTransforms(t,e){return t.threads.invoke(t.modelId,"getLocalTransforms",[e])}async getGlobalTransformsIds(t){return t.threads.invoke(t.modelId,"getGlobalTransformsIds",[])}async getGlobalTransforms(t,e){return t.threads.invoke(t.modelId,"getGlobalTransforms",[e])}async getItemsIds(t){return t.threads.invoke(t.modelId,"getItemsIds",[])}async getItems(t,e){return t.threads.invoke(t.modelId,"getItems",[e])}async getRelations(t,e){return t.threads.invoke(t.modelId,"getRelations",[e])}async getGlobalTranformsIdsOfItems(t,e){return await t.threads.invoke(t.modelId,"getGlobalTranformsIdsOfItems",[e])}async getEditedElements(t){return t.deltaModelId?t.threads.invoke(t.deltaModelId,"getItemsWithGeometry",[]):[]}async getElements(t,e){const s=await t.threads.invoke(t.modelId,"getElementsData",[e]);if(t.deltaModelId){const i=await t.threads.invoke(t.deltaModelId,"getElementsData",[e]);for(const r in i)s[r]=i[r]}const n=[];for(const i in s){const r=new Ke(Number(i),s[i],t);n.push(r)}return n}async getRequests(t){return t.threads.invoke(t.modelId,"getRequests",[])}async setRequests(t,e){return t.threads.invoke(t.modelId,"setRequests",[e])}async selectRequest(t,e){return t.threads.invoke(t.modelId,"selectRequest",[e])}}const lt=class lt{constructor(t,e,s,n){a(this,"attrsChanges",new Map);a(this,"relsChanges",new Map);a(this,"threads");a(this,"tiles",new Lt);a(this,"object",new we);a(this,"graphicsQuality",0);a(this,"deltaModelId",null);a(this,"_boxManager",new Le);a(this,"_itemsManager",new Ue);a(this,"_coordinatesManager",new qe);a(this,"_setupManager",new Pe);a(this,"_viewManager",new Ge);a(this,"_raycastManager",new Ne);a(this,"_visibilityManager",new Ve);a(this,"_highlightManager",new ke);a(this,"_sectionManager",new We);a(this,"_dataManager",new $e);a(this,"_sequenceManager",new Ye);a(this,"_bbox",new Y);a(this,"_alignmentsManager");a(this,"_meshManager");a(this,"_editManager",new Je);a(this,"_editor");a(this,"_isProcessing",!1);a(this,"_isLoaded",!1);a(this,"_frozen",!1);a(this,"_isSetup",!1);a(this,"_parentModelId",null);this.object.name=t,this.object.up.set(0,0,1),this._meshManager=e,this.threads=s,this._editor=n,this._alignmentsManager=new De(this),this.tiles.onItemSet.add(({value:i})=>this.object.add(i)),this.tiles.onBeforeDelete.add(({value:i})=>{this.object.remove(i),i.geometry.dispose(),ye.forEach(i.material,r=>r.dispose())})}get modelId(){return this.object.name}get box(){return this._bbox.clone().applyMatrix4(this.object.matrixWorld)}get isBusy(){const t=this._meshManager.requests.arePending;return!this._isLoaded||this._isProcessing||t}get frozen(){return!!this._frozen}set frozen(t){t!==this._frozen&&(this._frozen=t,!t&&this._refreshView())}get getClippingPlanesEvent(){return this._viewManager.getClippingPlanesEvent}set getClippingPlanesEvent(t){this._viewManager.getClippingPlanesEvent=t}get camera(){return this._viewManager.currentCamera}get isDeltaModel(){return this.object.userData[lt._deltaModelId]}get parentModelId(){return this._parentModelId}async dispose(){this._isLoaded=!1,await this._dataManager.dispose(this,this._meshManager,this._alignmentsManager)}async getSpatialStructure(){return this._dataManager.getSpatialStructure(this)}async getLocalIdsByGuids(t){return this._dataManager.getLocalIdsByGuids(this,t)}async getCategories(){return this._dataManager.getCategories(this)}async getItemsWithGeometryCategories(){return this._dataManager.getItemsWithGeometryCategories(this)}async getItemsWithGeometry(){return this._dataManager.getItemsWithGeometry(this)}async getItemsIdsWithGeometry(){return this._dataManager.getItemsIdsWithGeometry(this)}async getMetadata(){return this._dataManager.getMetadata(this)}async getGuidsByLocalIds(t){return this._dataManager.getGuidsByLocalIds(this,t)}async getBuffer(t=!1){return this._dataManager.getBuffer(this,t)}async getItemsOfCategories(t){return this._dataManager.getItemsOfCategories(this,t)}async getGuids(){return await this.threads.invoke(this.modelId,"getGuids",[])}async getLocalIds(){return await this.threads.invoke(this.modelId,"getLocalIds",[])}async getItemsByQuery(t,e){return this._dataManager.getItemsByQuery(this,t,e)}async getItemsMaterialDefinition(t){return await this.threads.invoke(this.modelId,"getItemsMaterialDefinition",[t])}async getItemsGeometry(t,e=Mt.GEOMETRY){return this._editManager.getItemsGeometry(this,t,e)}async getGeometries(t){return this._editManager.getGeometries(this,t)}async getItemsVolume(t){return await this.threads.invoke(this.modelId,"getItemsVolume",[t])}async getAttributeNames(){return await this.threads.invoke(this.modelId,"getAttributeNames",[])}async getAttributeValues(){return await this.threads.invoke(this.modelId,"getAttributeValues",[])}async getAttributesUniqueValues(t){return await this.threads.invoke(this.modelId,"getAttributesUniqueValues",[t])}async getAttributeTypes(){return await this.threads.invoke(this.modelId,"getAttributeTypes",[])}async getRelationNames(){return await this.threads.invoke(this.modelId,"getRelationNames",[])}async getMaxLocalId(){return this._dataManager.getMaxLocalId(this)}getItem(t){return this._itemsManager.getItem(this,t)}async getItemsChildren(t){return this._itemsManager.getItemsChildren(this,t)}async getItemsData(t,e){return this._itemsManager.getItemsData(this,t,e)}async getPositions(t){return this._coordinatesManager.getPositions(this,t)}async getCoordinates(){return this._coordinatesManager.getCoordinates(this)}async getCoordinationMatrix(){return this._coordinatesManager.getCoordinationMatrix(this)}async getMergedBox(t){return this._boxManager.getMergedBox(this,t)}async getBoxes(t){return this._boxManager.getBoxes(this,t)}async getAlignments(){return this._alignmentsManager.getAlignments()}async getHorizontalAlignments(){return this._alignmentsManager.getHorizontalAlignments()}async getVerticalAlignments(){return this._alignmentsManager.getVerticalAlignments()}getAlignmentStyles(){return this._alignmentsManager.getAlignmentStyles()}useCamera(t){this._viewManager.useCamera(t)}async rectangleRaycast(t){return this._raycastManager.rectangleRaycast(this,this._meshManager,t)}async raycast(t){return this._raycastManager.raycast(this,t)}async raycastWithSnapping(t){return this._raycastManager.raycastWithSnapping(this,t)}async setVisible(t,e){const s=[t,e];await this.threads.invoke(this.modelId,"setVisible",s)}async toggleVisible(t){const e=[t];await this.threads.invoke(this.modelId,"toggleVisible",e)}async getItemsByVisibility(t){return this._visibilityManager.getItemsByVisibility(this,t)}async getVisible(t){return this._visibilityManager.getVisible(this,t)}async resetVisible(){return this._visibilityManager.resetVisible(this)}async highlight(t,e){return this._highlightManager.highlight(this,t,e)}async getHighlight(t){return this._highlightManager.getHighlight(this,t)}async resetHighlight(t){return this._highlightManager.resetHighlight(this,t)}async getHighlightItemIds(){return this._highlightManager.getHighlightItemIds(this)}async getSection(t,e){return this._sectionManager.getSection(this,t,e)}async getMaterialsIds(){return this._editManager.getMaterialsIds(this)}async getMaterials(t){return this._editManager.getMaterials(this,t)}async getRepresentationsIds(){return this._editManager.getRepresentationsIds(this)}async getRepresentations(t){return this._editManager.getRepresentations(this,t)}async getLocalTransformsIds(){return this._editManager.getLocalTransformsIds(this)}async getLocalTransforms(t){return this._editManager.getLocalTransforms(this,t)}async getGlobalTransformsIds(){return this._editManager.getGlobalTransformsIds(this)}async getGlobalTransforms(t){return this._editManager.getGlobalTransforms(this,t)}async getSamplesIds(){return this._editManager.getSamplesIds(this)}async getSamples(t){return this._editManager.getSamples(this,t)}async getItemsIds(){return this._editManager.getItemsIds(this)}async getItems(t){return this._editManager.getItems(this,t)}async getRelations(t){return this._editManager.getRelations(this,t)}async getGlobalTranformsIdsOfItems(t){return this._editManager.getGlobalTranformsIdsOfItems(this,t)}async getEditedElements(){return this._editManager.getEditedElements(this)}async getSequenced(t,e,s){return this._sequenceManager.getSequenced(this,t,e,s)}async handleRequest(t){await this._meshManager.requests.handleRequest(this._meshManager,t)}async _getElements(t){return this._editManager.getElements(this,t)}_finishProcessing(){this._isProcessing=!1}_setDeltaModel(t){this.object.userData[lt._deltaModelId]=!0,this._parentModelId=t}async _refreshView(){if(this.frozen)return;this._isProcessing=!0;const t=this._viewManager.refreshView(this,this._meshManager),e=this._editor._update(this.modelId);await Promise.all([t,e])}async _setup(t,e,s){this._isSetup||(await this._setupManager.setup(this,this._bbox,t,e,s),this._isLoaded=!0,this._isProcessing=!0,this._isSetup=!0)}async _edit(t){return this._editManager.edit(this,t)}async _reset(){return this._editManager.reset(this)}async _save(){return this._editManager.save(this)}async _getRequests(){return this._editManager.getRequests(this)}async _setRequests(t){return this._editManager.setRequests(this,t)}async _selectRequest(t){return this._editManager.selectRequest(this,t)}};a(lt,"_deltaModelId","isDeltaModel");let _t=lt;class ts{constructor(){a(this,"list",[]);a(this,"onFinish",()=>{})}get arePending(){return this.list.length>0}async handleRequest(t,e){if(e.class===V.RECOMPUTE_MESHES)this.add(e.list),e.list=void 0;else if(e.class===V.CREATE_MATERIAL){const{materialDefinitions:s,modelId:n}=e;qt.resetColors(s),t.materials.addDefinitions(n,s),e.materialDefinitions=void 0}else e.class===V.THROW_ERROR&&console.error(e)}add(t){for(const e of t)this.insert(e)||this.list.push(e),e.tileRequestClass===L.FINISH&&this.onFinish()}clean(t){const e=this.list.filter(s=>s.modelId!==t||s.tileRequestClass!==L.FINISH);this.list=e}insert(t){const{modelId:e,tileId:s,tileRequestClass:n,tileData:i}=t;if(s===void 0)return!1;if(n===L.DELETE){const r=this.list.filter(o=>!((o.tileRequestClass===L.CREATE||o.tileRequestClass===L.DELETE)&&o.modelId===e&&o.tileId===s));this.list=r}if(n===L.CREATE){const r=this.list.filter(o=>!(o.tileRequestClass===L.CREATE&&o.modelId===e&&o.tileId===s));this.list=r}if(n===L.UPDATE){const r=this.list.find(o=>o.modelId===e&&o.tileId===s);if(r)return(r.tileRequestClass===L.CREATE||r.tileRequestClass===L.UPDATE)&&(r.tileData=i),!0}return!1}}class es{constructor(t){a(this,"_materials");a(this,"white",4294967295);this._materials=t}createMesh(t,e){const s=this._materials.getFromRequest(e);if(!("isLodMaterial"in s&&s.isLodMaterial))throw new Error("Fragments: material is not an instance of LodMaterial.");const{positions:n}=e;if(!n)throw new Error("Fragments: no positions provided to create the LOD mesh.");const i=new je,r=this.deleteAttributeEvent(t);return O.setLodBuffer(i,n,r),new Wt(i,[s])}updateVisibility(t,e){const{geometry:s}=t,{visibilityData:n,highlightData:i}=e;O.setLodVisibility(s,n),i?(O.setLodFilter(s,i),Pt.getComplementary(i,(r,o)=>{s.addGroup(r,o,0)})):s.addGroup(0,1/0,0)}processMesh(t,e){const{geometry:s}=t,{tileData:{visibilityData:n},currentLod:i}=e;if(i===Mt.WIRES&&t instanceof Wt)this.updateVisibility(t,e.tileData);else if(n&&n.position.length>0)for(let r=0;r<n.position.length;++r){const o=n.size[r]===this.white,c=n.position[r],d=o?1/0:n.size[r];s.addGroup(c,d,0)}}deleteAttributeEvent(t){function e(){delete this.array}return e}}class ss{constructor(t){a(this,"list",new Lt);a(this,"materials",new qt);a(this,"lod",new es(this.materials));a(this,"requests",new ts);a(this,"updateThreshold",4);a(this,"_updateFinished",!0);a(this,"_onUpdate");this._onUpdate=t,this.requests.onFinish=()=>this._updateFinished=!0}forceUpdateFinish(t=200){return new Promise(s=>{this._updateFinished=!1;const n=setInterval(()=>{this.update(),this._updateFinished&&(clearInterval(n),s())},t)})}update(){const t=performance.now();for(;this.requests.arePending;){const e=this.requests.list.shift();if(e&&(this.processTileRequest(e),this._onUpdate(),performance.now()-t>this.updateThreshold))return}}setTileData(t,e){const{tileId:s,itemId:n,matrix:i,aabb:r}=e;this.setMeshData(t,s,n,i),this.setupBoundings(t,r),this.updateStatus(t,e)}processTileRequest(t){const{tileRequestClass:e,tileId:s,modelId:n}=t,i=this.list.get(n);if(i)if(e===L.CREATE){if(t.objectClass===void 0)return;const r=this.create(t);this.setTileData(r,t),i.tiles.set(r.userData.tileId,r)}else if(e===L.DELETE)i.tiles.delete(s);else if(e===L.UPDATE){const r=i.tiles.get(s);r&&this.updateStatus(r,t)}else e===L.FINISH&&i._finishProcessing()}createMesh(t){const{indices:e,positions:s,normals:n,itemIds:i,faceIds:r}=t,o=new wt;this.setIndex(o,e),this.setPositions(s,o),this.setNormals(n,o),this.setItemIds(i,o),this.setFaceIds(r,o);const c=this.materials.getFromRequest(t);return new $(o,[c])}setupBoundings(t,e){const{geometry:s}=t,n=new Y().copy(e),i=new vt;n.getBoundingSphere(i),s.boundingBox=n,s.boundingSphere=i}create(t){if(t.objectClass===yt.SHELL)return this.createMesh(t);if(t.objectClass===yt.LINE){const e=new wt;return this.lod.createMesh(e,t)}throw new Error(`Fragments: object class ${t.objectClass} is not supported.`)}updateStatus(t,e){const{tileData:{highlightData:s},currentLod:n}=e,{geometry:i}=t;if(i.clearGroups(),this.lod.processMesh(t,e),!(s&&n!==Mt.WIRES))return;const r=this.materials.createHighlights(t,e);t.material=r}cleanAttributeMemory(t,e){t.attributes[e].onUpload(this.deleteAttribute(t))}setPositions(t,e){if(!t)throw new Error("Fragments: no positions provided to create the mesh.");e.setAttribute("position",new Z(t,3)),this.cleanAttributeMemory(e,"position")}setFaceIds(t,e){t&&(e.setAttribute("color",new Z(t,3)),this.cleanAttributeMemory(e,"color"))}setIndex(t,e){if(!e)throw new Error("Fragments: no indices provided to create the mesh.");t.setIndex(new Z(e,1)),t.index.onUpload(this.deleteAttribute(t))}setNormals(t,e){t&&e.setAttribute("normal",new Z(t,3,!0)),this.cleanAttributeMemory(e,"normal")}setItemIds(t,e){t&&(e.setAttribute("id",new Z(t,1,!1)),this.cleanAttributeMemory(e,"id"))}deleteAttribute(t){function e(){delete this.array}return e}setMeshData(t,e,s,n){t.userData={tileId:e,itemId:s},t.matrixAutoUpdate=!1,t.applyMatrix4(n),t.matrix.copy(n)}}class ns{constructor(){a(this,"_list",new Map);a(this,"_communicationKey",0)}setupInput(t){t.requestId=this._communicationKey++}set(t,e,s){const n=this.newHandler(e,s);this._list.set(t,n)}run(t){const e=this._list.get(t.requestId);this._list.delete(t.requestId),e(t)}newHandler(t,e){return s=>{if(s.errorInfo){t(s.errorInfo);return}e(s)}}}class q{static newThread(t){return new Worker(t,{type:"module"})}static newUpdater(t,e){return setInterval(t,e)}static getMeshComputeRequest(t,e){return{class:V.RECOMPUTE_MESHES,modelId:t,list:e}}static planeSet(t){const e=[];for(const s of t){const n=this.array(s.normal),i=s.constant,r=new W(n,i);e.push(r)}return e}static data(t){var m,w;if((t==null?void 0:t.elements)!==void 0)return q.transform(t);if((t==null?void 0:t.origin)!==void 0&&(t==null?void 0:t.direction)!==void 0)return q.beam(t);if((t==null?void 0:t.planes)!==void 0)return q.frustum(t);const i=(t==null?void 0:t.normal)!==void 0,r=(t==null?void 0:t.constant)!==void 0;if(i&&r)return q.plane(t);const c=((m=t[0])==null?void 0:m.normal)!==void 0,d=((w=t[0])==null?void 0:w.constant)!==void 0;if(c&&d)return q.planeSet(t);const l=(t==null?void 0:t.x)!==void 0,f=(t==null?void 0:t.y)!==void 0,p=(t==null?void 0:t.z)!==void 0;return l&&f&&p?q.array(t):t}static getExecuteRequest(t,e,s){const n=Array.from(s);return{class:V.EXECUTE,modelId:t,function:e,parameters:n}}static plane(t){const e=this.array(t.normal),s=t.constant;return new W(e,s)}static getRequestContent(t){const e=[];for(const s of t.list)q.setupCreateRequest(s,e),q.setupUpdateRequest(s,e);return e}static array(t){const e=new y;return e.set(t.x,t.y,t.z),e}static cleanRequests(t){const e=[],s=q;for(const n of t)s.isFinishRequest(n)||e.push(n);return e}static frustum(t){const e=this.planeSet(t.planes),[s,n,i,r,o,c]=e;return new ct(s,n,i,r,o,c)}static beam(t){const e=this.array(t.origin),s=this.array(t.direction);return new Zt(e,s)}static transform(t){const e=new K;return e.copy(t),e}static deleteUpdater(t){clearInterval(t)}static areCoresAvailable(t){const e=q.getCpuCapacity(),s=Math.max(e,2);return t<s}static isFinishRequest(t){return t.tileRequestClass===L.FINISH}static setupUpdateRequest(t,e){t.tileRequestClass===L.UPDATE&&this.addAllTileData(t,e)}static getCpuCapacity(){var e;return(e=globalThis.navigator)!=null&&e.hardwareConcurrency?navigator.hardwareConcurrency-3:0}static addAllTileData(t,e){this.addRequestTileData(t,e,"visibilityData");const s=["highlightIds"];this.addRequestTileData(t,e,"highlightData",s)}static addRequestContent(t,e,s){if(!e[t])return;const n=e[t].buffer;s.push(n)}static addRequestTileData(t,e,s,n=[]){const i=t.tileData[s];if(i){e.push(i.position.buffer),e.push(i.size.buffer);for(const r of n)e.push(t.tileData[r].buffer)}}static setupCreateRequest(t,e){if(t.tileRequestClass!==L.CREATE)return;const s=this.getCreateRequestIds();for(const n of s)this.addRequestContent(n,t,e);this.addAllTileData(t,e)}static getCreateRequestIds(){return["positions","indices","normals","itemIds"]}}class is{constructor(t){a(this,"_handlers",new ns);a(this,"_handleInput");a(this,"_port");a(this,"onInput",t=>{if(t.data.toMainThread){this._handlers.run(t.data);return}this.manageInput(t.data)});this._handleInput=t}fetchMeshCompute(t,e){const s=q,n=s.getMeshComputeRequest(t,e),i=s.getRequestContent(n);this.fetch(n,i)}fetch(t,e){return this._handlers.setupInput(t),new Promise((s,n)=>{this._handlers.set(t.requestId,n,s),this.executeConnection(t,e)})}init(t){this._port=t,this.initConnection(t)}initConnection(t){t.onmessage=this.onInput}async fetchConnection(t){if(!this._port)throw new Error("Fragments: Connection not initialized");return this._port}async executeConnection(t,e){(await this.fetchConnection(t)).postMessage(t,e)}async manageOutput(t){const e=await this.fetchConnection(t);t.toMainThread=!0,e.postMessage(t)}async manageConnection(t){try{await this._handleInput(t)}catch(e){t.errorInfo=e.toString(),console.error(e)}}async manageInput(t){await this.manageConnection(t),await this.manageOutput(t)}}class rs{constructor(t){a(this,"_modelThread",new Map);a(this,"_threadsModelAmount",new Map);a(this,"_threadPort",new Map);a(this,"_threadPath");a(this,"_placeholder");this._placeholder={},this._threadPath=t}get path(){return this._threadPath}usePlaceholder(t){this._modelThread.set(t,this._placeholder)}getAmount(t){return this._threadsModelAmount.get(t)}getThread(t){return this._modelThread.get(t)}getAndCheckThread(t){const e=this._modelThread.get(t);if(e===this._placeholder)throw new Error("Fragments: Error fetching thread!");return e}set(t,e){this._modelThread.set(t,e)}deleteModel(t){const e=this.getThreadSafe(t),n=this.getAmountSafe(e)-1;this.setAmount(e,n),this._modelThread.delete(t)}getThreadSafe(t){const e=this.getThread(t);if(!e)throw new Error(`Fragments: Thread for model ${t} not found`);return e}deleteThread(t){this._threadsModelAmount.delete(t),this._threadPort.delete(t),t.terminate()}getThreadAmount(){return this._threadsModelAmount.size}balanceThreadLoad(t){const{lessBusyThread:e,modelAmount:s}=this.getLessBusyThread();return this._threadsModelAmount.set(e,s+1),this._modelThread.set(t.modelId,e),this._threadPort.get(e)}getAmountSafe(t){const e=this.getAmount(t);if(!e)throw new Error(`Fragments: Amount for thread ${t} not found`);return e}setPort(t,e){this._threadPort.set(t,e)}setAmount(t,e){this._threadsModelAmount.set(t,e)}getPort(t){return this._threadPort.get(t)}getLessBusyThread(){let t=Number.MAX_VALUE,e=this._threadsModelAmount.keys().next().value;for(const[s,n]of this._threadsModelAmount)n<t&&(t=n,e=s);return{lessBusyThread:e,modelAmount:t}}}class os extends is{constructor(e,s){super(e);a(this,"_data");this._data=new rs(s)}delete(e){const s=this._data.getThreadSafe(e),n=this._data.getAmountSafe(s)-1;this._data.deleteModel(e),n===0&&this._data.deleteThread(s)}async invoke(e,s,n=[]){const r=q.getExecuteRequest(e,s,n);return(await this.fetch(r)).result}async fetchConnection(e){const s=this._data.getAndCheckThread(e.modelId);return s?this._data.getPort(s):this.setupNewThread(e)}setupNewThread(e){const s=q;this._data.usePlaceholder(e.modelId);const n=this._data.getThreadAmount();return s.areCoresAvailable(n)?this.newThread(e,this._data.path):this._data.balanceThreadLoad(e)}setupThread(e){const s=new MessageChannel,n=s.port1,i=s.port2;this.initConnection(n),this._data.setPort(e,n),e.postMessage(i,[i])}newThread(e,s){const n=q.newThread(s);return this.setupThread(n),this._data.setAmount(n,1),this._data.set(e.modelId,n),this._data.getPort(n)}}class cs{constructor(t){a(this,"onModelLoaded",new k);a(this,"models");a(this,"settings",{autoCoordinate:!0,maxUpdateRate:100,graphicsQuality:0});a(this,"baseCoordinates",null);a(this,"editor");a(this,"_connection");a(this,"_isDisposed",!1);a(this,"_autoRedrawInterval",null);a(this,"_lastUpdate",0);const e=this.newRequestEvent(),s=this.newUpdateEvent();this._connection=new os(e,t),this.editor=new Ze(this,this._connection),this.models=new ss(s),this.models.list.onItemDeleted.add(()=>{this.models.list.size===0&&(this.baseCoordinates=null)})}async load(t,e){const s=new _t(e.modelId,this.models,this._connection,this.editor);e.userData&&(s.object.userData=e.userData),s.frozen=!0,s.graphicsQuality=this.settings.graphicsQuality;try{if(this.models.list.set(s.modelId,s),await s._setup(t,e.raw,e.virtualModelConfig),this.settings.autoCoordinate){const i=await s.getCoordinates();if(this.baseCoordinates===null)this.baseCoordinates=i;else{const[r,o,c]=i,[d,u,l]=this.baseCoordinates,f=new y(d-r,u-o,l-c);s.object.position.add(f)}}}catch(i){throw this.models.list.delete(s.modelId),i}const{camera:n}=e;return n&&s.useCamera(n),s.frozen=!1,this.onModelLoaded.trigger(s),s}async dispose(){this._isDisposed=!0;const t=Array.from(this.models.list.values()),e=[];for(const s of t)e.push(s.dispose());await Promise.all(e),this.onModelLoaded.reset()}async disposeModel(t){const e=this.models.list.get(t);e&&await e.dispose()}async update(t=!1){if(this._isDisposed)return;const e=performance.now();if(e-this._lastUpdate<this.settings.maxUpdateRate)return;this._lastUpdate=e;const s=[];for(const n of this.models.list.values())s.push(n._refreshView());await Promise.all(s),t?await this.models.forceUpdateFinish():this.models.update()}async manageRequest(t){const e=this.models.list.get(t.modelId);e&&await e.handleRequest(t)}newUpdateEvent(){return()=>{this._autoRedrawInterval&&clearTimeout(this._autoRedrawInterval);const t=this.settings.maxUpdateRate+1;this._autoRedrawInterval=setTimeout(()=>{this.update()},t)}}newRequestEvent(){return t=>{this.manageRequest(t)}}}export{k as E,cs as F,R as G};
